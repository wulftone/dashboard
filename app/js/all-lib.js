/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.9 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.9',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value !== 'string') {
                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite and existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i += 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
                foundMap, foundI, foundStarMap, starI,
                baseParts = baseName && baseName.split('/'),
                normalizedBaseParts = baseParts,
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    if (getOwn(config.pkgs, baseName)) {
                        //If the baseName is a package name, then just treat it as one
                        //name to concat the name with.
                        normalizedBaseParts = baseParts = [baseName];
                    } else {
                        //Convert baseName to array, and lop off the last part,
                        //so that . matches that 'directory' and not name of the baseName's
                        //module. For instance, baseName of 'one/two/three', maps to
                        //'one/two/three.js', but we want the directory, 'one/two' for
                        //this normalization.
                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    }

                    name = normalizedBaseParts.concat(name.split('/'));
                    trimDots(name);

                    //Some use of packages may use a . path to reference the
                    //'main' module name, so normalize for that.
                    pkgConfig = getOwn(config.pkgs, (pkgName = name[0]));
                    name = name.join('/');
                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
                        name = pkgName;
                    }
                } else if (name.indexOf('./') === 0) {
                    // No baseName, so this is ID is resolved relative
                    // to baseUrl, pull off the leading dot.
                    name = name.substring(2);
                }
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break;
                                }
                            }
                        }
                    }

                    if (foundMap) {
                        break;
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            return name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);
                context.require([id]);
                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = normalize(name, parentName, applyMap);
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue,
                           [defQueue.length - 1, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return mod.exports;
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            var c,
                                pkg = getOwn(config.pkgs, mod.map.id);
                            // For packages, only support config targeted
                            // at the main module.
                            c = pkg ? getOwn(config.config, mod.map.id + '/' + pkg.main) :
                                      getOwn(config.config, mod.map.id);
                            return  c || {};
                        },
                        exports: defined[mod.map.id]
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var map, modId, err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                map = mod.map;
                modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            if (this.map.isDefine) {
                                //If setting exports via 'module' is in play,
                                //favor that over return value and exports. After that,
                                //favor a non-undefined return value over exports use.
                                cjsModule = this.module;
                                if (cjsModule &&
                                        cjsModule.exports !== undefined &&
                                        //Make sure it is not already the exports value
                                        cjsModule.exports !== this.exports) {
                                    exports = cjsModule.exports;
                                } else if (exports === undefined && this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths and packages since they require special processing,
                //they are additive.
                var pkgs = config.pkgs,
                    shim = config.shim,
                    objs = {
                        paths: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (prop === 'map') {
                            if (!config.map) {
                                config.map = {};
                            }
                            mixin(config[prop], value, true, true);
                        } else {
                            mixin(config[prop], value, true);
                        }
                    } else {
                        config[prop] = value;
                    }
                });

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
                        location = pkgObj.location;

                        //Create a brand new object on pkgs, since currentPackages can
                        //be passed in again, and config.pkgs is the internal transformed
                        //state for all package configs.
                        pkgs[pkgObj.name] = {
                            name: pkgObj.name,
                            location: location || pkgObj.name,
                            //Remove leading dot in main, so main paths are normalized,
                            //and remove any trailing .js, since different package
                            //envs have different conventions: some use a module name,
                            //some use a file name.
                            main: (pkgObj.main || 'main')
                                  .replace(currDirRegExp, '')
                                  .replace(jsSuffixRegExp, '')
                        };
                    });

                    //Done with modifications, assing packages back to context config
                    config.pkgs = pkgs;
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overriden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
                    parentPath;

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;
                    pkgs = config.pkgs;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');
                        pkg = getOwn(pkgs, parentModule);
                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        } else if (pkg) {
                            //If module name is just the package name, then looking
                            //for the main module.
                            if (moduleName === pkg.name) {
                                pkgPath = pkg.location + '/' + pkg.main;
                            } else {
                                pkgPath = pkg.location;
                            }
                            syms.splice(0, i, pkgPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation that a build has been done so that
                //only one script needs to be loaded anyway. This may need to be
                //reevaluated if other use cases become common.
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one.
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                 //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

/*! jQuery v2.0.3 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
*/
(function(e,undefined){var t,n,r=typeof undefined,i=e.location,o=e.document,s=o.documentElement,a=e.jQuery,u=e.$,l={},c=[],p="2.0.3",f=c.concat,h=c.push,d=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=p.trim,x=function(e,n){return new x.fn.init(e,n,t)},b=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,w=/\S+/g,T=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,k=/^-ms-/,N=/-([\da-z])/gi,E=function(e,t){return t.toUpperCase()},S=function(){o.removeEventListener("DOMContentLoaded",S,!1),e.removeEventListener("load",S,!1),x.ready()};x.fn=x.prototype={jquery:p,constructor:x,init:function(e,t,n){var r,i;if(!e)return this;if("string"==typeof e){if(r="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:T.exec(e),!r||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof x?t[0]:t,x.merge(this,x.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:o,!0)),C.test(r[1])&&x.isPlainObject(t))for(r in t)x.isFunction(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return i=o.getElementById(r[2]),i&&i.parentNode&&(this.length=1,this[0]=i),this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?n.ready(e):(e.selector!==undefined&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return d.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,t,n,r,i,o,s=arguments[0]||{},a=1,u=arguments.length,l=!1;for("boolean"==typeof s&&(l=s,s=arguments[1]||{},a=2),"object"==typeof s||x.isFunction(s)||(s={}),u===a&&(s=this,--a);u>a;a++)if(null!=(e=arguments[a]))for(t in e)n=s[t],r=e[t],s!==r&&(l&&r&&(x.isPlainObject(r)||(i=x.isArray(r)))?(i?(i=!1,o=n&&x.isArray(n)?n:[]):o=n&&x.isPlainObject(n)?n:{},s[t]=x.extend(l,o,r)):r!==undefined&&(s[t]=r));return s},x.extend({expando:"jQuery"+(p+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=a),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){(e===!0?--x.readyWait:x.isReady)||(x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(o,[x]),x.fn.trigger&&x(o).trigger("ready").off("ready")))},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[m.call(e)]||"object":typeof e},isPlainObject:function(e){if("object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}return!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:JSON.parse,parseXML:function(e){var t,n;if(!e||"string"!=typeof e)return null;try{n=new DOMParser,t=n.parseFromString(e,"text/xml")}catch(r){t=undefined}return(!t||t.getElementsByTagName("parsererror").length)&&x.error("Invalid XML: "+e),t},noop:function(){},globalEval:function(e){var t,n=eval;e=x.trim(e),e&&(1===e.indexOf("use strict")?(t=o.createElement("script"),t.text=e,o.head.appendChild(t).parentNode.removeChild(t)):n(e))},camelCase:function(e){return e.replace(k,"ms-").replace(N,E)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,s=j(e);if(n){if(s){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(s){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:function(e){return null==e?"":v.call(e)},makeArray:function(e,t){var n=t||[];return null!=e&&(j(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:g.call(t,e,n)},merge:function(e,t){var n=t.length,r=e.length,i=0;if("number"==typeof n)for(;n>i;i++)e[r++]=t[i];else while(t[i]!==undefined)e[r++]=t[i++];return e.length=r,e},grep:function(e,t,n){var r,i=[],o=0,s=e.length;for(n=!!n;s>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,s=j(e),a=[];if(s)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(a[a.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(a[a.length]=r);return f.apply([],a)},guid:1,proxy:function(e,t){var n,r,i;return"string"==typeof t&&(n=e[t],t=e,e=n),x.isFunction(e)?(r=d.call(arguments,2),i=function(){return e.apply(t||this,r.concat(d.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):undefined},access:function(e,t,n,r,i,o,s){var a=0,u=e.length,l=null==n;if("object"===x.type(n)){i=!0;for(a in n)x.access(e,t,a,n[a],!0,o,s)}else if(r!==undefined&&(i=!0,x.isFunction(r)||(s=!0),l&&(s?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(x(e),n)})),t))for(;u>a;a++)t(e[a],n,s?r:r.call(e[a],a,t(e[a],n)));return i?e:l?t.call(e):u?t(e[0],n):o},now:Date.now,swap:function(e,t,n,r){var i,o,s={};for(o in t)s[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=s[o];return i}}),x.ready.promise=function(t){return n||(n=x.Deferred(),"complete"===o.readyState?setTimeout(x.ready):(o.addEventListener("DOMContentLoaded",S,!1),e.addEventListener("load",S,!1))),n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function j(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}t=x(o),function(e,undefined){var t,n,r,i,o,s,a,u,l,c,p,f,h,d,g,m,y,v="sizzle"+-new Date,b=e.document,w=0,T=0,C=st(),k=st(),N=st(),E=!1,S=function(e,t){return e===t?(E=!0,0):0},j=typeof undefined,D=1<<31,A={}.hasOwnProperty,L=[],q=L.pop,H=L.push,O=L.push,F=L.slice,P=L.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",W="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",$=W.replace("w","w#"),B="\\["+M+"*("+W+")"+M+"*(?:([*^$|!~]?=)"+M+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+$+")|)|)"+M+"*\\]",I=":("+W+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+B.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=RegExp("^"+M+"*,"+M+"*"),X=RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=RegExp(M+"*[+~]"),Y=RegExp("="+M+"*([^\\]'\"]*)"+M+"*\\]","g"),V=RegExp(I),G=RegExp("^"+$+"$"),J={ID:RegExp("^#("+W+")"),CLASS:RegExp("^\\.("+W+")"),TAG:RegExp("^("+W.replace("w","w*")+")"),ATTR:RegExp("^"+B),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:RegExp("^(?:"+R+")$","i"),needsContext:RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Q=/^[^{]+\{\s*\[native \w/,K=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,Z=/^(?:input|select|textarea|button)$/i,et=/^h\d$/i,tt=/'|\\/g,nt=RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),rt=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{O.apply(L=F.call(b.childNodes),b.childNodes),L[b.childNodes.length].nodeType}catch(it){O={apply:L.length?function(e,t){H.apply(e,F.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function ot(e,t,r,i){var o,s,a,u,l,f,g,m,x,w;if((t?t.ownerDocument||t:b)!==p&&c(t),t=t||p,r=r||[],!e||"string"!=typeof e)return r;if(1!==(u=t.nodeType)&&9!==u)return[];if(h&&!i){if(o=K.exec(e))if(a=o[1]){if(9===u){if(s=t.getElementById(a),!s||!s.parentNode)return r;if(s.id===a)return r.push(s),r}else if(t.ownerDocument&&(s=t.ownerDocument.getElementById(a))&&y(t,s)&&s.id===a)return r.push(s),r}else{if(o[2])return O.apply(r,t.getElementsByTagName(e)),r;if((a=o[3])&&n.getElementsByClassName&&t.getElementsByClassName)return O.apply(r,t.getElementsByClassName(a)),r}if(n.qsa&&(!d||!d.test(e))){if(m=g=v,x=t,w=9===u&&e,1===u&&"object"!==t.nodeName.toLowerCase()){f=gt(e),(g=t.getAttribute("id"))?m=g.replace(tt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",l=f.length;while(l--)f[l]=m+mt(f[l]);x=U.test(e)&&t.parentNode||t,w=f.join(",")}if(w)try{return O.apply(r,x.querySelectorAll(w)),r}catch(T){}finally{g||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,r,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>i.cacheLength&&delete t[e.shift()],t[n]=r}return t}function at(e){return e[v]=!0,e}function ut(e){var t=p.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function lt(e,t){var n=e.split("|"),r=e.length;while(r--)i.attrHandle[n[r]]=t}function ct(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function pt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return at(function(t){return t=+t,at(function(n,r){var i,o=e([],n.length,t),s=o.length;while(s--)n[i=o[s]]&&(n[i]=!(r[i]=n[i]))})})}s=ot.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},n=ot.support={},c=ot.setDocument=function(e){var t=e?e.ownerDocument||e:b,r=t.defaultView;return t!==p&&9===t.nodeType&&t.documentElement?(p=t,f=t.documentElement,h=!s(t),r&&r.attachEvent&&r!==r.top&&r.attachEvent("onbeforeunload",function(){c()}),n.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),n.getElementsByTagName=ut(function(e){return e.appendChild(t.createComment("")),!e.getElementsByTagName("*").length}),n.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),n.getById=ut(function(e){return f.appendChild(e).id=v,!t.getElementsByName||!t.getElementsByName(v).length}),n.getById?(i.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(nt,rt);return function(e){return e.getAttribute("id")===t}}):(delete i.find.ID,i.filter.ID=function(e){var t=e.replace(nt,rt);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=n.getElementsByTagName?function(e,t){return typeof t.getElementsByTagName!==j?t.getElementsByTagName(e):undefined}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},i.find.CLASS=n.getElementsByClassName&&function(e,t){return typeof t.getElementsByClassName!==j&&h?t.getElementsByClassName(e):undefined},g=[],d=[],(n.qsa=Q.test(t.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||d.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll(":checked").length||d.push(":checked")}),ut(function(e){var n=t.createElement("input");n.setAttribute("type","hidden"),e.appendChild(n).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&d.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||d.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),d.push(",.*:")})),(n.matchesSelector=Q.test(m=f.webkitMatchesSelector||f.mozMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&ut(function(e){n.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!='']:x"),g.push("!=",I)}),d=d.length&&RegExp(d.join("|")),g=g.length&&RegExp(g.join("|")),y=Q.test(f.contains)||f.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},S=f.compareDocumentPosition?function(e,r){if(e===r)return E=!0,0;var i=r.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(r);return i?1&i||!n.sortDetached&&r.compareDocumentPosition(e)===i?e===t||y(b,e)?-1:r===t||y(b,r)?1:l?P.call(l,e)-P.call(l,r):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,n){var r,i=0,o=e.parentNode,s=n.parentNode,a=[e],u=[n];if(e===n)return E=!0,0;if(!o||!s)return e===t?-1:n===t?1:o?-1:s?1:l?P.call(l,e)-P.call(l,n):0;if(o===s)return ct(e,n);r=e;while(r=r.parentNode)a.unshift(r);r=n;while(r=r.parentNode)u.unshift(r);while(a[i]===u[i])i++;return i?ct(a[i],u[i]):a[i]===b?-1:u[i]===b?1:0},t):p},ot.matches=function(e,t){return ot(e,null,null,t)},ot.matchesSelector=function(e,t){if((e.ownerDocument||e)!==p&&c(e),t=t.replace(Y,"='$1']"),!(!n.matchesSelector||!h||g&&g.test(t)||d&&d.test(t)))try{var r=m.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(i){}return ot(t,p,null,[e]).length>0},ot.contains=function(e,t){return(e.ownerDocument||e)!==p&&c(e),y(e,t)},ot.attr=function(e,t){(e.ownerDocument||e)!==p&&c(e);var r=i.attrHandle[t.toLowerCase()],o=r&&A.call(i.attrHandle,t.toLowerCase())?r(e,t,!h):undefined;return o===undefined?n.attributes||!h?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null:o},ot.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},ot.uniqueSort=function(e){var t,r=[],i=0,o=0;if(E=!n.detectDuplicates,l=!n.sortStable&&e.slice(0),e.sort(S),E){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1)}return e},o=ot.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=o(t);return n},i=ot.selectors={cacheLength:50,createPseudo:at,match:J,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(nt,rt),e[3]=(e[4]||e[5]||"").replace(nt,rt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||ot.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&ot.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return J.CHILD.test(e[0])?null:(e[3]&&e[4]!==undefined?e[2]=e[4]:n&&V.test(n)&&(t=gt(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(nt,rt).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=C[e+" "];return t||(t=RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&C(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=ot.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),s="last"!==e.slice(-4),a="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,p,f,h,d,g=o!==s?"nextSibling":"previousSibling",m=t.parentNode,y=a&&t.nodeName.toLowerCase(),x=!u&&!a;if(m){if(o){while(g){p=t;while(p=p[g])if(a?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;d=g="only"===e&&!d&&"nextSibling"}return!0}if(d=[s?m.firstChild:m.lastChild],s&&x){c=m[v]||(m[v]={}),l=c[e]||[],h=l[0]===w&&l[1],f=l[0]===w&&l[2],p=h&&m.childNodes[h];while(p=++h&&p&&p[g]||(f=h=0)||d.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[w,h,f];break}}else if(x&&(l=(t[v]||(t[v]={}))[e])&&l[0]===w)f=l[1];else while(p=++h&&p&&p[g]||(f=h=0)||d.pop())if((a?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(x&&((p[v]||(p[v]={}))[e]=[w,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||ot.error("unsupported pseudo: "+e);return r[v]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?at(function(e,n){var i,o=r(e,t),s=o.length;while(s--)i=P.call(e,o[s]),e[i]=!(n[i]=o[s])}):function(e){return r(e,0,n)}):r}},pseudos:{not:at(function(e){var t=[],n=[],r=a(e.replace(z,"$1"));return r[v]?at(function(e,t,n,i){var o,s=r(e,null,i,[]),a=e.length;while(a--)(o=s[a])&&(e[a]=!(t[a]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:at(function(e){return function(t){return ot(e,t).length>0}}),contains:at(function(e){return function(t){return(t.textContent||t.innerText||o(t)).indexOf(e)>-1}}),lang:at(function(e){return G.test(e||"")||ot.error("unsupported lang: "+e),e=e.replace(nt,rt).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===f},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return et.test(e.nodeName)},input:function(e){return Z.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},i.pseudos.nth=i.pseudos.eq;for(t in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[t]=pt(t);for(t in{submit:!0,reset:!0})i.pseudos[t]=ft(t);function dt(){}dt.prototype=i.filters=i.pseudos,i.setFilters=new dt;function gt(e,t){var n,r,o,s,a,u,l,c=k[e+" "];if(c)return t?0:c.slice(0);a=e,u=[],l=i.preFilter;while(a){(!n||(r=_.exec(a)))&&(r&&(a=a.slice(r[0].length)||a),u.push(o=[])),n=!1,(r=X.exec(a))&&(n=r.shift(),o.push({value:n,type:r[0].replace(z," ")}),a=a.slice(n.length));for(s in i.filter)!(r=J[s].exec(a))||l[s]&&!(r=l[s](r))||(n=r.shift(),o.push({value:n,type:s,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?ot.error(e):k(e,u).slice(0)}function mt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function yt(e,t,n){var i=t.dir,o=n&&"parentNode"===i,s=T++;return t.first?function(t,n,r){while(t=t[i])if(1===t.nodeType||o)return e(t,n,r)}:function(t,n,a){var u,l,c,p=w+" "+s;if(a){while(t=t[i])if((1===t.nodeType||o)&&e(t,n,a))return!0}else while(t=t[i])if(1===t.nodeType||o)if(c=t[v]||(t[v]={}),(l=c[i])&&l[0]===p){if((u=l[1])===!0||u===r)return u===!0}else if(l=c[i]=[p],l[1]=e(t,n,a)||r,l[1]===!0)return!0}}function vt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,s=[],a=0,u=e.length,l=null!=t;for(;u>a;a++)(o=e[a])&&(!n||n(o,r,i))&&(s.push(o),l&&t.push(a));return s}function bt(e,t,n,r,i,o){return r&&!r[v]&&(r=bt(r)),i&&!i[v]&&(i=bt(i,o)),at(function(o,s,a,u){var l,c,p,f=[],h=[],d=s.length,g=o||Ct(t||"*",a.nodeType?[a]:a,[]),m=!e||!o&&t?g:xt(g,f,e,a,u),y=n?i||(o?e:d||r)?[]:s:m;if(n&&n(m,y,a,u),r){l=xt(y,h),r(l,[],a,u),c=l.length;while(c--)(p=l[c])&&(y[h[c]]=!(m[h[c]]=p))}if(o){if(i||e){if(i){l=[],c=y.length;while(c--)(p=y[c])&&l.push(m[c]=p);i(null,y=[],l,u)}c=y.length;while(c--)(p=y[c])&&(l=i?P.call(o,p):f[c])>-1&&(o[l]=!(s[l]=p))}}else y=xt(y===s?y.splice(d,y.length):y),i?i(null,s,y,u):O.apply(s,y)})}function wt(e){var t,n,r,o=e.length,s=i.relative[e[0].type],a=s||i.relative[" "],l=s?1:0,c=yt(function(e){return e===t},a,!0),p=yt(function(e){return P.call(t,e)>-1},a,!0),f=[function(e,n,r){return!s&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;o>l;l++)if(n=i.relative[e[l].type])f=[yt(vt(f),n)];else{if(n=i.filter[e[l].type].apply(null,e[l].matches),n[v]){for(r=++l;o>r;r++)if(i.relative[e[r].type])break;return bt(l>1&&vt(f),l>1&&mt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&wt(e.slice(l,r)),o>r&&wt(e=e.slice(r)),o>r&&mt(e))}f.push(n)}return vt(f)}function Tt(e,t){var n=0,o=t.length>0,s=e.length>0,a=function(a,l,c,f,h){var d,g,m,y=[],v=0,x="0",b=a&&[],T=null!=h,C=u,k=a||s&&i.find.TAG("*",h&&l.parentNode||l),N=w+=null==C?1:Math.random()||.1;for(T&&(u=l!==p&&l,r=n);null!=(d=k[x]);x++){if(s&&d){g=0;while(m=e[g++])if(m(d,l,c)){f.push(d);break}T&&(w=N,r=++n)}o&&((d=!m&&d)&&v--,a&&b.push(d))}if(v+=x,o&&x!==v){g=0;while(m=t[g++])m(b,y,l,c);if(a){if(v>0)while(x--)b[x]||y[x]||(y[x]=q.call(f));y=xt(y)}O.apply(f,y),T&&!a&&y.length>0&&v+t.length>1&&ot.uniqueSort(f)}return T&&(w=N,u=C),b};return o?at(a):a}a=ot.compile=function(e,t){var n,r=[],i=[],o=N[e+" "];if(!o){t||(t=gt(e)),n=t.length;while(n--)o=wt(t[n]),o[v]?r.push(o):i.push(o);o=N(e,Tt(i,r))}return o};function Ct(e,t,n){var r=0,i=t.length;for(;i>r;r++)ot(e,t[r],n);return n}function kt(e,t,r,o){var s,u,l,c,p,f=gt(e);if(!o&&1===f.length){if(u=f[0]=f[0].slice(0),u.length>2&&"ID"===(l=u[0]).type&&n.getById&&9===t.nodeType&&h&&i.relative[u[1].type]){if(t=(i.find.ID(l.matches[0].replace(nt,rt),t)||[])[0],!t)return r;e=e.slice(u.shift().value.length)}s=J.needsContext.test(e)?0:u.length;while(s--){if(l=u[s],i.relative[c=l.type])break;if((p=i.find[c])&&(o=p(l.matches[0].replace(nt,rt),U.test(u[0].type)&&t.parentNode||t))){if(u.splice(s,1),e=o.length&&mt(u),!e)return O.apply(r,o),r;break}}}return a(e,f)(o,t,!h,r,U.test(e)),r}n.sortStable=v.split("").sort(S).join("")===v,n.detectDuplicates=E,c(),n.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(p.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||lt("type|href|height|width",function(e,t,n){return n?undefined:e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),n.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||lt("value",function(e,t,n){return n||"input"!==e.nodeName.toLowerCase()?undefined:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||lt(R,function(e,t,n){var r;return n?undefined:(r=e.getAttributeNode(t))&&r.specified?r.value:e[t]===!0?t.toLowerCase():null}),x.find=ot,x.expr=ot.selectors,x.expr[":"]=x.expr.pseudos,x.unique=ot.uniqueSort,x.text=ot.getText,x.isXMLDoc=ot.isXML,x.contains=ot.contains}(e);var D={};function A(e){var t=D[e]={};return x.each(e.match(w)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?D[e]||A(e):x.extend({},e);var t,n,r,i,o,s,a=[],u=!e.once&&[],l=function(p){for(t=e.memory&&p,n=!0,s=i||0,i=0,o=a.length,r=!0;a&&o>s;s++)if(a[s].apply(p[0],p[1])===!1&&e.stopOnFalse){t=!1;break}r=!1,a&&(u?u.length&&l(u.shift()):t?a=[]:c.disable())},c={add:function(){if(a){var n=a.length;(function s(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&c.has(n)||a.push(n):n&&n.length&&"string"!==r&&s(n)})})(arguments),r?o=a.length:t&&(i=n,l(t))}return this},remove:function(){return a&&x.each(arguments,function(e,t){var n;while((n=x.inArray(t,a,n))>-1)a.splice(n,1),r&&(o>=n&&o--,s>=n&&s--)}),this},has:function(e){return e?x.inArray(e,a)>-1:!(!a||!a.length)},empty:function(){return a=[],o=0,this},disable:function(){return a=u=t=undefined,this},disabled:function(){return!a},lock:function(){return u=undefined,t||c.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!a||n&&!u||(t=t||[],t=[e,t.slice?t.slice():t],r?u.push(t):l(t)),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!n}};return c},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var s=o[0],a=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=a&&a.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[s+"With"](this===r?n.promise():this,a?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var s=o[2],a=o[3];r[o[1]]=s.add,a&&s.add(function(){n=a},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=s.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=d.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),s=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?d.call(arguments):r,n===a?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},a,u,l;if(r>1)for(a=Array(r),u=Array(r),l=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(s(t,l,n)).fail(o.reject).progress(s(t,u,a)):--i;return i||o.resolveWith(l,n),o.promise()}}),x.support=function(t){var n=o.createElement("input"),r=o.createDocumentFragment(),i=o.createElement("div"),s=o.createElement("select"),a=s.appendChild(o.createElement("option"));return n.type?(n.type="checkbox",t.checkOn=""!==n.value,t.optSelected=a.selected,t.reliableMarginRight=!0,t.boxSizingReliable=!0,t.pixelPosition=!1,n.checked=!0,t.noCloneChecked=n.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!a.disabled,n=o.createElement("input"),n.value="t",n.type="radio",t.radioValue="t"===n.value,n.setAttribute("checked","t"),n.setAttribute("name","t"),r.appendChild(n),t.checkClone=r.cloneNode(!0).cloneNode(!0).lastChild.checked,t.focusinBubbles="onfocusin"in e,i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===i.style.backgroundClip,x(function(){var n,r,s="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",a=o.getElementsByTagName("body")[0];a&&(n=o.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",a.appendChild(n).appendChild(i),i.innerHTML="",i.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",x.swap(a,null!=a.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===i.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(i,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(i,null)||{width:"4px"}).width,r=i.appendChild(o.createElement("div")),r.style.cssText=i.style.cssText=s,r.style.marginRight=r.style.width="0",i.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),a.removeChild(n))}),t):t}({});var L,q,H=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,O=/([A-Z])/g;function F(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=x.expando+Math.random()}F.uid=1,F.accepts=function(e){return e.nodeType?1===e.nodeType||9===e.nodeType:!0},F.prototype={key:function(e){if(!F.accepts(e))return 0;var t={},n=e[this.expando];if(!n){n=F.uid++;try{t[this.expando]={value:n},Object.defineProperties(e,t)}catch(r){t[this.expando]=n,x.extend(e,t)}}return this.cache[n]||(this.cache[n]={}),n},set:function(e,t,n){var r,i=this.key(e),o=this.cache[i];if("string"==typeof t)o[t]=n;else if(x.isEmptyObject(o))x.extend(this.cache[i],t);else for(r in t)o[r]=t[r];return o},get:function(e,t){var n=this.cache[this.key(e)];return t===undefined?n:n[t]},access:function(e,t,n){var r;return t===undefined||t&&"string"==typeof t&&n===undefined?(r=this.get(e,t),r!==undefined?r:this.get(e,x.camelCase(t))):(this.set(e,t,n),n!==undefined?n:t)},remove:function(e,t){var n,r,i,o=this.key(e),s=this.cache[o];if(t===undefined)this.cache[o]={};else{x.isArray(t)?r=t.concat(t.map(x.camelCase)):(i=x.camelCase(t),t in s?r=[t,i]:(r=i,r=r in s?[r]:r.match(w)||[])),n=r.length;while(n--)delete s[r[n]]}},hasData:function(e){return!x.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){e[this.expando]&&delete this.cache[e[this.expando]]}},L=new F,q=new F,x.extend({acceptData:F.accepts,hasData:function(e){return L.hasData(e)||q.hasData(e)},data:function(e,t,n){return L.access(e,t,n)},removeData:function(e,t){L.remove(e,t)},_data:function(e,t,n){return q.access(e,t,n)},_removeData:function(e,t){q.remove(e,t)}}),x.fn.extend({data:function(e,t){var n,r,i=this[0],o=0,s=null;if(e===undefined){if(this.length&&(s=L.get(i),1===i.nodeType&&!q.get(i,"hasDataAttrs"))){for(n=i.attributes;n.length>o;o++)r=n[o].name,0===r.indexOf("data-")&&(r=x.camelCase(r.slice(5)),P(i,r,s[r]));q.set(i,"hasDataAttrs",!0)}return s}return"object"==typeof e?this.each(function(){L.set(this,e)}):x.access(this,function(t){var n,r=x.camelCase(e);if(i&&t===undefined){if(n=L.get(i,e),n!==undefined)return n;if(n=L.get(i,r),n!==undefined)return n;if(n=P(i,r,undefined),n!==undefined)return n}else this.each(function(){var n=L.get(this,r);L.set(this,r,t),-1!==e.indexOf("-")&&n!==undefined&&L.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){L.remove(this,e)})}});function P(e,t,n){var r;if(n===undefined&&1===e.nodeType)if(r="data-"+t.replace(O,"-$1").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n="true"===n?!0:"false"===n?!1:"null"===n?null:+n+""===n?+n:H.test(n)?JSON.parse(n):n}catch(i){}L.set(e,t,n)}else n=undefined;return n}x.extend({queue:function(e,t,n){var r;return e?(t=(t||"fx")+"queue",r=q.get(e,t),n&&(!r||x.isArray(n)?r=q.access(e,t,x.makeArray(n)):r.push(n)),r||[]):undefined},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),s=function(){x.dequeue(e,t)
};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,s,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return q.get(e,n)||q.access(e,n,{empty:x.Callbacks("once memory").add(function(){q.remove(e,[t+"queue",n])})})}}),x.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),n>arguments.length?x.queue(this[0],e):t===undefined?this:this.each(function(){var n=x.queue(this,e,t);x._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=x.Deferred(),o=this,s=this.length,a=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=undefined),e=e||"fx";while(s--)n=q.get(o[s],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(a));return a(),i.promise(t)}});var R,M,W=/[\t\r\n\f]/g,$=/\r/g,B=/^(?:input|select|textarea|button)$/i;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[x.propFix[e]||e]})},addClass:function(e){var t,n,r,i,o,s=0,a=this.length,u="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];a>s;s++)if(n=this[s],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(W," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,s=0,a=this.length,u=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];a>s;s++)if(n=this[s],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(W," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,i=0,o=x(this),s=e.match(w)||[];while(t=s[i++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===r||"boolean"===n)&&(this.className&&q.set(this,"__className__",this.className),this.className=this.className||e===!1?"":q.get(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(W," ").indexOf(t)>=0)return!0;return!1},val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=x.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,x(this).val()):e,null==i?i="":"number"==typeof i?i+="":x.isArray(i)&&(i=x.map(i,function(e){return null==e?"":e+""})),t=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&t.set(this,i,"value")!==undefined||(this.value=i))});if(i)return t=x.valHooks[i.type]||x.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&(n=t.get(i,"value"))!==undefined?n:(n=i.value,"string"==typeof n?n.replace($,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,s=o?null:[],a=o?i+1:r.length,u=0>i?a:o?i:0;for(;a>u;u++)if(n=r[u],!(!n.selected&&u!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),s=i.length;while(s--)r=i[s],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,t,n){var i,o,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===r?x.prop(e,t,n):(1===s&&x.isXMLDoc(e)||(t=t.toLowerCase(),i=x.attrHooks[t]||(x.expr.match.bool.test(t)?M:R)),n===undefined?i&&"get"in i&&null!==(o=i.get(e,t))?o:(o=x.find.attr(e,t),null==o?undefined:o):null!==n?i&&"set"in i&&(o=i.set(e,n,t))!==undefined?o:(e.setAttribute(t,n+""),n):(x.removeAttr(e,t),undefined))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(w);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)&&(e[r]=!1),e.removeAttribute(n)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,t,n){var r,i,o,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return o=1!==s||!x.isXMLDoc(e),o&&(t=x.propFix[t]||t,i=x.propHooks[t]),n!==undefined?i&&"set"in i&&(r=i.set(e,n,t))!==undefined?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||B.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),M={set:function(e,t,n){return t===!1?x.removeAttr(e,n):e.setAttribute(n,n),n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,t){var n=x.expr.attrHandle[t]||x.find.attr;x.expr.attrHandle[t]=function(e,t,r){var i=x.expr.attrHandle[t],o=r?undefined:(x.expr.attrHandle[t]=undefined)!=n(e,t,r)?t.toLowerCase():null;return x.expr.attrHandle[t]=i,o}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,t){return x.isArray(t)?e.checked=x.inArray(x(e).val(),t)>=0:undefined}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var I=/^key/,z=/^(?:mouse|contextmenu)|click/,_=/^(?:focusinfocus|focusoutblur)$/,X=/^([^.]*)(?:\.(.+)|)$/;function U(){return!0}function Y(){return!1}function V(){try{return o.activeElement}catch(e){}}x.event={global:{},add:function(e,t,n,i,o){var s,a,u,l,c,p,f,h,d,g,m,y=q.get(e);if(y){n.handler&&(s=n,n=s.handler,o=s.selector),n.guid||(n.guid=x.guid++),(l=y.events)||(l=y.events={}),(a=y.handle)||(a=y.handle=function(e){return typeof x===r||e&&x.event.triggered===e.type?undefined:x.event.dispatch.apply(a.elem,arguments)},a.elem=e),t=(t||"").match(w)||[""],c=t.length;while(c--)u=X.exec(t[c])||[],d=m=u[1],g=(u[2]||"").split(".").sort(),d&&(f=x.event.special[d]||{},d=(o?f.delegateType:f.bindType)||d,f=x.event.special[d]||{},p=x.extend({type:d,origType:m,data:i,handler:n,guid:n.guid,selector:o,needsContext:o&&x.expr.match.needsContext.test(o),namespace:g.join(".")},s),(h=l[d])||(h=l[d]=[],h.delegateCount=0,f.setup&&f.setup.call(e,i,g,a)!==!1||e.addEventListener&&e.addEventListener(d,a,!1)),f.add&&(f.add.call(e,p),p.handler.guid||(p.handler.guid=n.guid)),o?h.splice(h.delegateCount++,0,p):h.push(p),x.event.global[d]=!0);e=null}},remove:function(e,t,n,r,i){var o,s,a,u,l,c,p,f,h,d,g,m=q.hasData(e)&&q.get(e);if(m&&(u=m.events)){t=(t||"").match(w)||[""],l=t.length;while(l--)if(a=X.exec(t[l])||[],h=g=a[1],d=(a[2]||"").split(".").sort(),h){p=x.event.special[h]||{},h=(r?p.delegateType:p.bindType)||h,f=u[h]||[],a=a[2]&&RegExp("(^|\\.)"+d.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=o=f.length;while(o--)c=f[o],!i&&g!==c.origType||n&&n.guid!==c.guid||a&&!a.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(f.splice(o,1),c.selector&&f.delegateCount--,p.remove&&p.remove.call(e,c));s&&!f.length&&(p.teardown&&p.teardown.call(e,d,m.handle)!==!1||x.removeEvent(e,h,m.handle),delete u[h])}else for(h in u)x.event.remove(e,h+t[l],n,r,!0);x.isEmptyObject(u)&&(delete m.handle,q.remove(e,"events"))}},trigger:function(t,n,r,i){var s,a,u,l,c,p,f,h=[r||o],d=y.call(t,"type")?t.type:t,g=y.call(t,"namespace")?t.namespace.split("."):[];if(a=u=r=r||o,3!==r.nodeType&&8!==r.nodeType&&!_.test(d+x.event.triggered)&&(d.indexOf(".")>=0&&(g=d.split("."),d=g.shift(),g.sort()),c=0>d.indexOf(":")&&"on"+d,t=t[x.expando]?t:new x.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=g.join("."),t.namespace_re=t.namespace?RegExp("(^|\\.)"+g.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=undefined,t.target||(t.target=r),n=null==n?[t]:x.makeArray(n,[t]),f=x.event.special[d]||{},i||!f.trigger||f.trigger.apply(r,n)!==!1)){if(!i&&!f.noBubble&&!x.isWindow(r)){for(l=f.delegateType||d,_.test(l+d)||(a=a.parentNode);a;a=a.parentNode)h.push(a),u=a;u===(r.ownerDocument||o)&&h.push(u.defaultView||u.parentWindow||e)}s=0;while((a=h[s++])&&!t.isPropagationStopped())t.type=s>1?l:f.bindType||d,p=(q.get(a,"events")||{})[t.type]&&q.get(a,"handle"),p&&p.apply(a,n),p=c&&a[c],p&&x.acceptData(a)&&p.apply&&p.apply(a,n)===!1&&t.preventDefault();return t.type=d,i||t.isDefaultPrevented()||f._default&&f._default.apply(h.pop(),n)!==!1||!x.acceptData(r)||c&&x.isFunction(r[d])&&!x.isWindow(r)&&(u=r[c],u&&(r[c]=null),x.event.triggered=d,r[d](),x.event.triggered=undefined,u&&(r[c]=u)),t.result}},dispatch:function(e){e=x.event.fix(e);var t,n,r,i,o,s=[],a=d.call(arguments),u=(q.get(this,"events")||{})[e.type]||[],l=x.event.special[e.type]||{};if(a[0]=e,e.delegateTarget=this,!l.preDispatch||l.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),t=0;while((i=s[t++])&&!e.isPropagationStopped()){e.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(o.namespace))&&(e.handleObj=o,e.data=o.data,r=((x.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,a),r!==undefined&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return l.postDispatch&&l.postDispatch.call(this,e),e.result}},handlers:function(e,t){var n,r,i,o,s=[],a=t.delegateCount,u=e.target;if(a&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!==this;u=u.parentNode||this)if(u.disabled!==!0||"click"!==e.type){for(r=[],n=0;a>n;n++)o=t[n],i=o.selector+" ",r[i]===undefined&&(r[i]=o.needsContext?x(i,this).index(u)>=0:x.find(i,this,null,[u]).length),r[i]&&r.push(o);r.length&&s.push({elem:u,handlers:r})}return t.length>a&&s.push({elem:this,handlers:t.slice(a)}),s},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,t){var n,r,i,s=t.button;return null==e.pageX&&null!=t.clientX&&(n=e.target.ownerDocument||o,r=n.documentElement,i=n.body,e.pageX=t.clientX+(r&&r.scrollLeft||i&&i.scrollLeft||0)-(r&&r.clientLeft||i&&i.clientLeft||0),e.pageY=t.clientY+(r&&r.scrollTop||i&&i.scrollTop||0)-(r&&r.clientTop||i&&i.clientTop||0)),e.which||s===undefined||(e.which=1&s?1:2&s?3:4&s?2:0),e}},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,s=e,a=this.fixHooks[i];a||(this.fixHooks[i]=a=z.test(i)?this.mouseHooks:I.test(i)?this.keyHooks:{}),r=a.props?this.props.concat(a.props):this.props,e=new x.Event(s),t=r.length;while(t--)n=r[t],e[n]=s[n];return e.target||(e.target=o),3===e.target.nodeType&&(e.target=e.target.parentNode),a.filter?a.filter(e,s):e},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==V()&&this.focus?(this.focus(),!1):undefined},delegateType:"focusin"},blur:{trigger:function(){return this===V()&&this.blur?(this.blur(),!1):undefined},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&x.nodeName(this,"input")?(this.click(),!1):undefined},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==undefined&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)},x.Event=function(e,t){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.getPreventDefault&&e.getPreventDefault()?U:Y):this.type=e,t&&x.extend(this,t),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,undefined):new x.Event(e,t)},x.Event.prototype={isDefaultPrevented:Y,isPropagationStopped:Y,isImmediatePropagationStopped:Y,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=U,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=U,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=U,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&o.addEventListener(e,r,!0)},teardown:function(){0===--n&&o.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,t,n,r,i){var o,s;if("object"==typeof e){"string"!=typeof t&&(n=n||t,t=undefined);for(s in e)this.on(s,t,n,e[s],i);return this}if(null==n&&null==r?(r=t,n=t=undefined):null==r&&("string"==typeof t?(r=n,n=undefined):(r=n,n=t,t=undefined)),r===!1)r=Y;else if(!r)return this;return 1===i&&(o=r,r=function(e){return x().off(e),o.apply(this,arguments)},r.guid=o.guid||(o.guid=x.guid++)),this.each(function(){x.event.add(this,e,r,n,t)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,x(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return(t===!1||"function"==typeof t)&&(n=t,t=undefined),n===!1&&(n=Y),this.each(function(){x.event.remove(this,e,n,t)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];return n?x.event.trigger(e,t,n,!0):undefined}});var G=/^.[^:#\[\.,]*$/,J=/^(?:parents|prev(?:Until|All))/,Q=x.expr.match.needsContext,K={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t=x(e,this),n=t.length;return this.filter(function(){var e=0;for(;n>e;e++)if(x.contains(this,t[e]))return!0})},not:function(e){return this.pushStack(et(this,e||[],!0))},filter:function(e){return this.pushStack(et(this,e||[],!1))},is:function(e){return!!et(this,"string"==typeof e&&Q.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],s=Q.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(s?s.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?g.call(x(e),this[0]):g.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function Z(e,t){while((e=e[t])&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return Z(e,"nextSibling")},prev:function(e){return Z(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return e.contentDocument||x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(K[e]||x.unique(i),J.test(e)&&i.reverse()),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,t,n){var r=[],i=n!==undefined;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&x(e).is(n))break;r.push(e)}return r},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function et(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(G.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return g.call(t,e)>=0!==n})}var tt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,nt=/<([\w:]+)/,rt=/<|&#?\w+;/,it=/<(?:script|style|link)/i,ot=/^(?:checkbox|radio)$/i,st=/checked\s*(?:[^=]|=\s*.checked.)/i,at=/^$|\/(?:java|ecma)script/i,ut=/^true\/(.*)/,lt=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ct={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ct.optgroup=ct.option,ct.tbody=ct.tfoot=ct.colgroup=ct.caption=ct.thead,ct.th=ct.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===undefined?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||o).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=pt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=pt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(mt(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&dt(mt(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++)1===e.nodeType&&(x.cleanData(mt(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var t=this[0]||{},n=0,r=this.length;if(e===undefined&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!it.test(e)&&!ct[(nt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(tt,"<$1></$2>");try{for(;r>n;n++)t=this[n]||{},1===t.nodeType&&(x.cleanData(mt(t,!1)),t.innerHTML=e);t=0}catch(i){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=f.apply([],e);var r,i,o,s,a,u,l=0,c=this.length,p=this,h=c-1,d=e[0],g=x.isFunction(d);if(g||!(1>=c||"string"!=typeof d||x.support.checkClone)&&st.test(d))return this.each(function(r){var i=p.eq(r);g&&(e[0]=d.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(r=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),i=r.firstChild,1===r.childNodes.length&&(r=i),i)){for(o=x.map(mt(r,"script"),ft),s=o.length;c>l;l++)a=r,l!==h&&(a=x.clone(a,!0,!0),s&&x.merge(o,mt(a,"script"))),t.call(this[l],a,l);if(s)for(u=o[o.length-1].ownerDocument,x.map(o,ht),l=0;s>l;l++)a=o[l],at.test(a.type||"")&&!q.access(a,"globalEval")&&x.contains(u,a)&&(a.src?x._evalUrl(a.src):x.globalEval(a.textContent.replace(lt,"")))}return this}}),x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=[],i=x(e),o=i.length-1,s=0;for(;o>=s;s++)n=s===o?this:this.clone(!0),x(i[s])[t](n),h.apply(r,n.get());return this.pushStack(r)}}),x.extend({clone:function(e,t,n){var r,i,o,s,a=e.cloneNode(!0),u=x.contains(e.ownerDocument,e);if(!(x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(s=mt(a),o=mt(e),r=0,i=o.length;i>r;r++)yt(o[r],s[r]);if(t)if(n)for(o=o||mt(e),s=s||mt(a),r=0,i=o.length;i>r;r++)gt(o[r],s[r]);else gt(e,a);return s=mt(a,"script"),s.length>0&&dt(s,!u&&mt(e,"script")),a},buildFragment:function(e,t,n,r){var i,o,s,a,u,l,c=0,p=e.length,f=t.createDocumentFragment(),h=[];for(;p>c;c++)if(i=e[c],i||0===i)if("object"===x.type(i))x.merge(h,i.nodeType?[i]:i);else if(rt.test(i)){o=o||f.appendChild(t.createElement("div")),s=(nt.exec(i)||["",""])[1].toLowerCase(),a=ct[s]||ct._default,o.innerHTML=a[1]+i.replace(tt,"<$1></$2>")+a[2],l=a[0];while(l--)o=o.lastChild;x.merge(h,o.childNodes),o=f.firstChild,o.textContent=""}else h.push(t.createTextNode(i));f.textContent="",c=0;while(i=h[c++])if((!r||-1===x.inArray(i,r))&&(u=x.contains(i.ownerDocument,i),o=mt(f.appendChild(i),"script"),u&&dt(o),n)){l=0;while(i=o[l++])at.test(i.type||"")&&n.push(i)}return f},cleanData:function(e){var t,n,r,i,o,s,a=x.event.special,u=0;for(;(n=e[u])!==undefined;u++){if(F.accepts(n)&&(o=n[q.expando],o&&(t=q.cache[o]))){if(r=Object.keys(t.events||{}),r.length)for(s=0;(i=r[s])!==undefined;s++)a[i]?x.event.remove(n,i):x.removeEvent(n,i,t.handle);q.cache[o]&&delete q.cache[o]}delete L.cache[n[L.expando]]}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}});function pt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function ft(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function ht(e){var t=ut.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function dt(e,t){var n=e.length,r=0;for(;n>r;r++)q.set(e[r],"globalEval",!t||q.get(t[r],"globalEval"))}function gt(e,t){var n,r,i,o,s,a,u,l;if(1===t.nodeType){if(q.hasData(e)&&(o=q.access(e),s=q.set(t,o),l=o.events)){delete s.handle,s.events={};for(i in l)for(n=0,r=l[i].length;r>n;n++)x.event.add(t,i,l[i][n])}L.hasData(e)&&(a=L.access(e),u=x.extend({},a),L.set(t,u))}}function mt(e,t){var n=e.getElementsByTagName?e.getElementsByTagName(t||"*"):e.querySelectorAll?e.querySelectorAll(t||"*"):[];return t===undefined||t&&x.nodeName(e,t)?x.merge([e],n):n}function yt(e,t){var n=t.nodeName.toLowerCase();"input"===n&&ot.test(e.type)?t.checked=e.checked:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}x.fn.extend({wrapAll:function(e){var t;return x.isFunction(e)?this.each(function(t){x(this).wrapAll(e.call(this,t))}):(this[0]&&(t=x(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var vt,xt,bt=/^(none|table(?!-c[ea]).+)/,wt=/^margin/,Tt=RegExp("^("+b+")(.*)$","i"),Ct=RegExp("^("+b+")(?!px)[a-z%]+$","i"),kt=RegExp("^([+-])=("+b+")","i"),Nt={BODY:"block"},Et={position:"absolute",visibility:"hidden",display:"block"},St={letterSpacing:0,fontWeight:400},jt=["Top","Right","Bottom","Left"],Dt=["Webkit","O","Moz","ms"];function At(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=Dt.length;while(i--)if(t=Dt[i]+n,t in e)return t;return r}function Lt(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function qt(t){return e.getComputedStyle(t,null)}function Ht(e,t){var n,r,i,o=[],s=0,a=e.length;for(;a>s;s++)r=e[s],r.style&&(o[s]=q.get(r,"olddisplay"),n=r.style.display,t?(o[s]||"none"!==n||(r.style.display=""),""===r.style.display&&Lt(r)&&(o[s]=q.access(r,"olddisplay",Rt(r.nodeName)))):o[s]||(i=Lt(r),(n&&"none"!==n||!i)&&q.set(r,"olddisplay",i?n:x.css(r,"display"))));for(s=0;a>s;s++)r=e[s],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[s]||"":"none"));return e}x.fn.extend({css:function(e,t){return x.access(this,function(e,t,n){var r,i,o={},s=0;if(x.isArray(t)){for(r=qt(e),i=t.length;i>s;s++)o[t[s]]=x.css(e,t[s],!1,r);return o}return n!==undefined?x.style(e,t,n):x.css(e,t)},e,t,arguments.length>1)},show:function(){return Ht(this,!0)},hide:function(){return Ht(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){Lt(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=vt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,s,a=x.camelCase(t),u=e.style;return t=x.cssProps[a]||(x.cssProps[a]=At(u,a)),s=x.cssHooks[t]||x.cssHooks[a],n===undefined?s&&"get"in s&&(i=s.get(e,!1,r))!==undefined?i:u[t]:(o=typeof n,"string"===o&&(i=kt.exec(n))&&(n=(i[1]+1)*i[2]+parseFloat(x.css(e,t)),o="number"),null==n||"number"===o&&isNaN(n)||("number"!==o||x.cssNumber[a]||(n+="px"),x.support.clearCloneStyle||""!==n||0!==t.indexOf("background")||(u[t]="inherit"),s&&"set"in s&&(n=s.set(e,n,r))===undefined||(u[t]=n)),undefined)}},css:function(e,t,n,r){var i,o,s,a=x.camelCase(t);return t=x.cssProps[a]||(x.cssProps[a]=At(e.style,a)),s=x.cssHooks[t]||x.cssHooks[a],s&&"get"in s&&(i=s.get(e,!0,n)),i===undefined&&(i=vt(e,t,r)),"normal"===i&&t in St&&(i=St[t]),""===n||n?(o=parseFloat(i),n===!0||x.isNumeric(o)?o||0:i):i}}),vt=function(e,t,n){var r,i,o,s=n||qt(e),a=s?s.getPropertyValue(t)||s[t]:undefined,u=e.style;return s&&(""!==a||x.contains(e.ownerDocument,e)||(a=x.style(e,t)),Ct.test(a)&&wt.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=s.width,u.width=r,u.minWidth=i,u.maxWidth=o)),a};function Ot(e,t,n){var r=Tt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function Ft(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,s=0;for(;4>o;o+=2)"margin"===n&&(s+=x.css(e,n+jt[o],!0,i)),r?("content"===n&&(s-=x.css(e,"padding"+jt[o],!0,i)),"margin"!==n&&(s-=x.css(e,"border"+jt[o]+"Width",!0,i))):(s+=x.css(e,"padding"+jt[o],!0,i),"padding"!==n&&(s+=x.css(e,"border"+jt[o]+"Width",!0,i)));return s}function Pt(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=qt(e),s=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=vt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Ct.test(i))return i;r=s&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+Ft(e,t,n||(s?"border":"content"),r,o)+"px"}function Rt(e){var t=o,n=Nt[e];return n||(n=Mt(e,t),"none"!==n&&n||(xt=(xt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(xt[0].contentWindow||xt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=Mt(e,t),xt.detach()),Nt[e]=n),n}function Mt(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,t){x.cssHooks[t]={get:function(e,n,r){return n?0===e.offsetWidth&&bt.test(x.css(e,"display"))?x.swap(e,Et,function(){return Pt(e,t,r)}):Pt(e,t,r):undefined},set:function(e,n,r){var i=r&&qt(e);return Ot(e,n,r?Ft(e,t,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,t){return t?x.swap(e,{display:"inline-block"},vt,[e,"marginRight"]):undefined}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,t){x.cssHooks[t]={get:function(e,n){return n?(n=vt(e,t),Ct.test(n)?x(e).position()[t]+"px":n):undefined}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+jt[r]+t]=o[r]||o[r-2]||o[0];return i}},wt.test(e)||(x.cssHooks[e+t].set=Ot)});var Wt=/%20/g,$t=/\[\]$/,Bt=/\r?\n/g,It=/^(?:submit|button|image|reset|file)$/i,zt=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&zt.test(this.nodeName)&&!It.test(e)&&(this.checked||!ot.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(Bt,"\r\n")}}):{name:t.name,value:n.replace(Bt,"\r\n")}}).get()}}),x.param=function(e,t){var n,r=[],i=function(e,t){t=x.isFunction(t)?t():null==t?"":t,r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(t===undefined&&(t=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){i(this.name,this.value)});else for(n in e)_t(n,e[n],t,i);return r.join("&").replace(Wt,"+")};function _t(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||$t.test(e)?r(e,i):_t(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)_t(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)
},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var Xt,Ut,Yt=x.now(),Vt=/\?/,Gt=/#.*$/,Jt=/([?&])_=[^&]*/,Qt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Kt=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Zt=/^(?:GET|HEAD)$/,en=/^\/\//,tn=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,nn=x.fn.load,rn={},on={},sn="*/".concat("*");try{Ut=i.href}catch(an){Ut=o.createElement("a"),Ut.href="",Ut=Ut.href}Xt=tn.exec(Ut.toLowerCase())||[];function un(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(w)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function ln(e,t,n,r){var i={},o=e===on;function s(a){var u;return i[a]=!0,x.each(e[a]||[],function(e,a){var l=a(t,n,r);return"string"!=typeof l||o||i[l]?o?!(u=l):undefined:(t.dataTypes.unshift(l),s(l),!1)}),u}return s(t.dataTypes[0])||!i["*"]&&s("*")}function cn(e,t){var n,r,i=x.ajaxSettings.flatOptions||{};for(n in t)t[n]!==undefined&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,t,n){if("string"!=typeof e&&nn)return nn.apply(this,arguments);var r,i,o,s=this,a=e.indexOf(" ");return a>=0&&(r=e.slice(a),e=e.slice(0,a)),x.isFunction(t)?(n=t,t=undefined):t&&"object"==typeof t&&(i="POST"),s.length>0&&x.ajax({url:e,type:i,dataType:"html",data:t}).done(function(e){o=arguments,s.html(r?x("<div>").append(x.parseHTML(e)).find(r):e)}).complete(n&&function(e,t){s.each(n,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ut,type:"GET",isLocal:Kt.test(Xt[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":sn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?cn(cn(e,x.ajaxSettings),t):cn(x.ajaxSettings,e)},ajaxPrefilter:un(rn),ajaxTransport:un(on),ajax:function(e,t){"object"==typeof e&&(t=e,e=undefined),t=t||{};var n,r,i,o,s,a,u,l,c=x.ajaxSetup({},t),p=c.context||c,f=c.context&&(p.nodeType||p.jquery)?x(p):x.event,h=x.Deferred(),d=x.Callbacks("once memory"),g=c.statusCode||{},m={},y={},v=0,b="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(2===v){if(!o){o={};while(t=Qt.exec(i))o[t[1].toLowerCase()]=t[2]}t=o[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===v?i:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return v||(e=y[n]=y[n]||e,m[e]=t),this},overrideMimeType:function(e){return v||(c.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>v)for(t in e)g[t]=[g[t],e[t]];else T.always(e[T.status]);return this},abort:function(e){var t=e||b;return n&&n.abort(t),k(0,t),this}};if(h.promise(T).complete=d.add,T.success=T.done,T.error=T.fail,c.url=((e||c.url||Ut)+"").replace(Gt,"").replace(en,Xt[1]+"//"),c.type=t.method||t.type||c.method||c.type,c.dataTypes=x.trim(c.dataType||"*").toLowerCase().match(w)||[""],null==c.crossDomain&&(a=tn.exec(c.url.toLowerCase()),c.crossDomain=!(!a||a[1]===Xt[1]&&a[2]===Xt[2]&&(a[3]||("http:"===a[1]?"80":"443"))===(Xt[3]||("http:"===Xt[1]?"80":"443")))),c.data&&c.processData&&"string"!=typeof c.data&&(c.data=x.param(c.data,c.traditional)),ln(rn,c,t,T),2===v)return T;u=c.global,u&&0===x.active++&&x.event.trigger("ajaxStart"),c.type=c.type.toUpperCase(),c.hasContent=!Zt.test(c.type),r=c.url,c.hasContent||(c.data&&(r=c.url+=(Vt.test(r)?"&":"?")+c.data,delete c.data),c.cache===!1&&(c.url=Jt.test(r)?r.replace(Jt,"$1_="+Yt++):r+(Vt.test(r)?"&":"?")+"_="+Yt++)),c.ifModified&&(x.lastModified[r]&&T.setRequestHeader("If-Modified-Since",x.lastModified[r]),x.etag[r]&&T.setRequestHeader("If-None-Match",x.etag[r])),(c.data&&c.hasContent&&c.contentType!==!1||t.contentType)&&T.setRequestHeader("Content-Type",c.contentType),T.setRequestHeader("Accept",c.dataTypes[0]&&c.accepts[c.dataTypes[0]]?c.accepts[c.dataTypes[0]]+("*"!==c.dataTypes[0]?", "+sn+"; q=0.01":""):c.accepts["*"]);for(l in c.headers)T.setRequestHeader(l,c.headers[l]);if(c.beforeSend&&(c.beforeSend.call(p,T,c)===!1||2===v))return T.abort();b="abort";for(l in{success:1,error:1,complete:1})T[l](c[l]);if(n=ln(on,c,t,T)){T.readyState=1,u&&f.trigger("ajaxSend",[T,c]),c.async&&c.timeout>0&&(s=setTimeout(function(){T.abort("timeout")},c.timeout));try{v=1,n.send(m,k)}catch(C){if(!(2>v))throw C;k(-1,C)}}else k(-1,"No Transport");function k(e,t,o,a){var l,m,y,b,w,C=t;2!==v&&(v=2,s&&clearTimeout(s),n=undefined,i=a||"",T.readyState=e>0?4:0,l=e>=200&&300>e||304===e,o&&(b=pn(c,T,o)),b=fn(c,b,T,l),l?(c.ifModified&&(w=T.getResponseHeader("Last-Modified"),w&&(x.lastModified[r]=w),w=T.getResponseHeader("etag"),w&&(x.etag[r]=w)),204===e||"HEAD"===c.type?C="nocontent":304===e?C="notmodified":(C=b.state,m=b.data,y=b.error,l=!y)):(y=C,(e||!C)&&(C="error",0>e&&(e=0))),T.status=e,T.statusText=(t||C)+"",l?h.resolveWith(p,[m,C,T]):h.rejectWith(p,[T,C,y]),T.statusCode(g),g=undefined,u&&f.trigger(l?"ajaxSuccess":"ajaxError",[T,c,l?m:y]),d.fireWith(p,[T,C]),u&&(f.trigger("ajaxComplete",[T,c]),--x.active||x.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,t){return x.get(e,undefined,t,"script")}}),x.each(["get","post"],function(e,t){x[t]=function(e,n,r,i){return x.isFunction(n)&&(i=i||r,r=n,n=undefined),x.ajax({url:e,type:t,dataType:i,data:n,success:r})}});function pn(e,t,n){var r,i,o,s,a=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),r===undefined&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in a)if(a[i]&&a[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}s||(s=i)}o=o||s}return o?(o!==u[0]&&u.unshift(o),n[o]):undefined}function fn(e,t,n,r){var i,o,s,a,u,l={},c=e.dataTypes.slice();if(c[1])for(s in e.converters)l[s.toLowerCase()]=e.converters[s];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(s=l[u+" "+o]||l["* "+o],!s)for(i in l)if(a=i.split(" "),a[1]===o&&(s=l[u+" "+a[0]]||l["* "+a[0]])){s===!0?s=l[i]:l[i]!==!0&&(o=a[0],c.unshift(a[1]));break}if(s!==!0)if(s&&e["throws"])t=s(t);else try{t=s(t)}catch(p){return{state:"parsererror",error:s?p:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===undefined&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),x.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=x("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),o.head.appendChild(t[0])},abort:function(){n&&n()}}}});var hn=[],dn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=hn.pop()||x.expando+"_"+Yt++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,s,a=t.jsonp!==!1&&(dn.test(t.url)?"url":"string"==typeof t.data&&!(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&dn.test(t.data)&&"data");return a||"jsonp"===t.dataTypes[0]?(i=t.jsonpCallback=x.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,a?t[a]=t[a].replace(dn,"$1"+i):t.jsonp!==!1&&(t.url+=(Vt.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return s||x.error(i+" was not called"),s[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){s=arguments},r.always(function(){e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,hn.push(i)),s&&x.isFunction(o)&&o(s[0]),s=o=undefined}),"script"):undefined}),x.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var gn=x.ajaxSettings.xhr(),mn={0:200,1223:204},yn=0,vn={};e.ActiveXObject&&x(e).on("unload",function(){for(var e in vn)vn[e]();vn=undefined}),x.support.cors=!!gn&&"withCredentials"in gn,x.support.ajax=gn=!!gn,x.ajaxTransport(function(e){var t;return x.support.cors||gn&&!e.crossDomain?{send:function(n,r){var i,o,s=e.xhr();if(s.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(i in e.xhrFields)s[i]=e.xhrFields[i];e.mimeType&&s.overrideMimeType&&s.overrideMimeType(e.mimeType),e.crossDomain||n["X-Requested-With"]||(n["X-Requested-With"]="XMLHttpRequest");for(i in n)s.setRequestHeader(i,n[i]);t=function(e){return function(){t&&(delete vn[o],t=s.onload=s.onerror=null,"abort"===e?s.abort():"error"===e?r(s.status||404,s.statusText):r(mn[s.status]||s.status,s.statusText,"string"==typeof s.responseText?{text:s.responseText}:undefined,s.getAllResponseHeaders()))}},s.onload=t(),s.onerror=t("error"),t=vn[o=yn++]=t("abort"),s.send(e.hasContent&&e.data||null)},abort:function(){t&&t()}}:undefined});var xn,bn,wn=/^(?:toggle|show|hide)$/,Tn=RegExp("^(?:([+-])=|)("+b+")([a-z%]*)$","i"),Cn=/queueHooks$/,kn=[An],Nn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Tn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),s=(x.cssNumber[e]||"px"!==o&&+r)&&Tn.exec(x.css(n.elem,e)),a=1,u=20;if(s&&s[3]!==o){o=o||s[3],i=i||[],s=+r||1;do a=a||".5",s/=a,x.style(n.elem,e,s+o);while(a!==(a=n.cur()/r)&&1!==a&&--u)}return i&&(s=n.start=+s||+r||0,n.unit=o,n.end=i[1]?s+(i[1]+1)*i[2]:+i[2]),n}]};function En(){return setTimeout(function(){xn=undefined}),xn=x.now()}function Sn(e,t,n){var r,i=(Nn[t]||[]).concat(Nn["*"]),o=0,s=i.length;for(;s>o;o++)if(r=i[o].call(n,t,e))return r}function jn(e,t,n){var r,i,o=0,s=kn.length,a=x.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;var t=xn||En(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,s=0,u=l.tweens.length;for(;u>s;s++)l.tweens[s].run(o);return a.notifyWith(e,[l,o,n]),1>o&&u?n:(a.resolveWith(e,[l]),!1)},l=a.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:xn||En(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?a.resolveWith(e,[l,t]):a.rejectWith(e,[l,t]),this}}),c=l.props;for(Dn(c,l.opts.specialEasing);s>o;o++)if(r=kn[o].call(l,e,c,l.opts))return r;return x.map(c,Sn,l),x.isFunction(l.opts.start)&&l.opts.start.call(e,l),x.fx.timer(x.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function Dn(e,t){var n,r,i,o,s;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),s=x.cssHooks[r],s&&"expand"in s){o=s.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(jn,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Nn[n]=Nn[n]||[],Nn[n].unshift(t)},prefilter:function(e,t){t?kn.unshift(e):kn.push(e)}});function An(e,t,n){var r,i,o,s,a,u,l=this,c={},p=e.style,f=e.nodeType&&Lt(e),h=q.get(e,"fxshow");n.queue||(a=x._queueHooks(e,"fx"),null==a.unqueued&&(a.unqueued=0,u=a.empty.fire,a.empty.fire=function(){a.unqueued||u()}),a.unqueued++,l.always(function(){l.always(function(){a.unqueued--,x.queue(e,"fx").length||a.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(p.display="inline-block")),n.overflow&&(p.overflow="hidden",l.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],wn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show")){if("show"!==i||!h||h[r]===undefined)continue;f=!0}c[r]=h&&h[r]||x.style(e,r)}if(!x.isEmptyObject(c)){h?"hidden"in h&&(f=h.hidden):h=q.access(e,"fxshow",{}),o&&(h.hidden=!f),f?x(e).show():l.done(function(){x(e).hide()}),l.done(function(){var t;q.remove(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)s=Sn(f?h[r]:0,r,l),r in h||(h[r]=s.start,f&&(s.end=s.start,s.start="width"===r||"height"===r?1:0))}}function Ln(e,t,n,r,i){return new Ln.prototype.init(e,t,n,r,i)}x.Tween=Ln,Ln.prototype={constructor:Ln,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=Ln.propHooks[this.prop];return e&&e.get?e.get(this):Ln.propHooks._default.get(this)},run:function(e){var t,n=Ln.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Ln.propHooks._default.set(this),this}},Ln.prototype.init.prototype=Ln.prototype,Ln.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},Ln.propHooks.scrollTop=Ln.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(qn(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Lt).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),s=function(){var t=jn(this,x.extend({},e),o);(i||q.get(this,"finish"))&&t.stop(!0)};return s.finish=s,i||o.queue===!1?this.each(s):this.queue(o.queue,s)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=undefined),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=x.timers,s=q.get(this);if(i)s[i]&&s[i].stop&&r(s[i]);else for(i in s)s[i]&&s[i].stop&&Cn.test(i)&&r(s[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));(t||!n)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=q.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,s=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;s>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function qn(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=jt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:qn("show"),slideUp:qn("hide"),slideToggle:qn("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=Ln.prototype.init,x.fx.tick=function(){var e,t=x.timers,n=0;for(xn=x.now();t.length>n;n++)e=t[n],e()||t[n]!==e||t.splice(n--,1);t.length||x.fx.stop(),xn=undefined},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){bn||(bn=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(bn),bn=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===undefined?this:this.each(function(t){x.offset.setOffset(this,e,t)});var t,n,i=this[0],o={top:0,left:0},s=i&&i.ownerDocument;if(s)return t=s.documentElement,x.contains(t,i)?(typeof i.getBoundingClientRect!==r&&(o=i.getBoundingClientRect()),n=Hn(s),{top:o.top+n.pageYOffset-t.clientTop,left:o.left+n.pageXOffset-t.clientLeft}):o},x.offset={setOffset:function(e,t,n){var r,i,o,s,a,u,l,c=x.css(e,"position"),p=x(e),f={};"static"===c&&(e.style.position="relative"),a=p.offset(),o=x.css(e,"top"),u=x.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=p.position(),s=r.top,i=r.left):(s=parseFloat(o)||0,i=parseFloat(u)||0),x.isFunction(t)&&(t=t.call(e,n,a)),null!=t.top&&(f.top=t.top-a.top+s),null!=t.left&&(f.left=t.left-a.left+i),"using"in t?t.using.call(e,f):p.css(f)}},x.fn.extend({position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===x.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(r=e.offset()),r.top+=x.css(e[0],"borderTopWidth",!0),r.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-r.top-x.css(n,"marginTop",!0),left:t.left-r.left-x.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,n){var r="pageYOffset"===n;x.fn[t]=function(i){return x.access(this,function(t,i,o){var s=Hn(t);return o===undefined?s?s[n]:t[i]:(s?s.scrollTo(r?e.pageXOffset:o,r?o:e.pageYOffset):t[i]=o,undefined)},t,i,arguments.length,null)}});function Hn(e){return x.isWindow(e)?e:9===e.nodeType&&e.defaultView}x.each({Height:"height",Width:"width"},function(e,t){x.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){x.fn[r]=function(r,i){var o=arguments.length&&(n||"boolean"!=typeof r),s=n||(r===!0||i===!0?"margin":"border");return x.access(this,function(t,n,r){var i;return x.isWindow(t)?t.document.documentElement["client"+e]:9===t.nodeType?(i=t.documentElement,Math.max(t.body["scroll"+e],i["scroll"+e],t.body["offset"+e],i["offset"+e],i["client"+e])):r===undefined?x.css(t,n,s):x.style(t,n,r,s)},t,o?r:undefined,o,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}),"object"==typeof e&&"object"==typeof e.document&&(e.jQuery=e.$=x)})(window);
/**
 * @license AngularJS v1.1.5
 * (c) 2010-2012 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, document, undefined) {
    'use strict';

////////////////////////////////////

    /**
     * @ngdoc function
     * @name angular.lowercase
     * @function
     *
     * @description Converts the specified string to lowercase.
     * @param {string} string String to be converted to lowercase.
     * @returns {string} Lowercased string.
     */
    var lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};


    /**
     * @ngdoc function
     * @name angular.uppercase
     * @function
     *
     * @description Converts the specified string to uppercase.
     * @param {string} string String to be converted to uppercase.
     * @returns {string} Uppercased string.
     */
    var uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};


    var manualLowercase = function(s) {
        return isString(s)
            ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
            : s;
    };
    var manualUppercase = function(s) {
        return isString(s)
            ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})
            : s;
    };


// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
// with correct but slower alternatives.
    if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
    }


    var /** holds major version number for IE or NaN for real browsers */
            msie              = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]),
        jqLite,           // delay binding since jQuery could be loaded after us.
        jQuery,           // delay binding
        slice             = [].slice,
        push              = [].push,
        toString          = Object.prototype.toString,


        _angular          = window.angular,
        /** @name angular */
            angular           = window.angular || (window.angular = {}),
        angularModule,
        nodeName_,
        uid               = ['0', '0', '0'];

    /**
     * @ngdoc function
     * @name angular.noConflict
     * @function
     *
     * @description
     * Restores the previous global value of angular and returns the current instance. Other libraries may already use the
     * angular namespace. Or a previous version of angular is already loaded on the page. In these cases you may want to
     * restore the previous namespace and keep a reference to angular.
     *
     * @return {Object} The current angular namespace
     */
    function noConflict() {
        var a = window.angular;
        window.angular = _angular;
        return a;
    }

    /**
     * @private
     * @param {*} obj
     * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments, ...)
     */
    function isArrayLike(obj) {
        if (!obj || (typeof obj.length !== 'number')) return false;

        // We have on object which has length property. Should we treat it as array?
        if (typeof obj.hasOwnProperty != 'function' &&
            typeof obj.constructor != 'function') {
            // This is here for IE8: it is a bogus object treat it as array;
            return true;
        } else  {
            return obj instanceof JQLite ||                      // JQLite
                (jQuery && obj instanceof jQuery) ||          // jQuery
                toString.call(obj) !== '[object Object]' ||   // some browser native object
                typeof obj.callee === 'function';              // arguments (on IE8 looks like regular obj)
        }
    }

    /**
     * @ngdoc function
     * @name angular.forEach
     * @function
     *
     * @description
     * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
     * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`
     * is the value of an object property or an array element and `key` is the object property key or
     * array element index. Specifying a `context` for the function is optional.
     *
     * Note: this function was previously known as `angular.foreach`.
     *
     <pre>
     var values = {name: 'misko', gender: 'male'};
     var log = [];
     angular.forEach(values, function(value, key){
       this.push(key + ': ' + value);
     }, log);
     expect(log).toEqual(['name: misko', 'gender:male']);
     </pre>
     *
     * @param {Object|Array} obj Object to iterate over.
     * @param {Function} iterator Iterator function.
     * @param {Object=} context Object to become context (`this`) for the iterator function.
     * @returns {Object|Array} Reference to `obj`.
     */
    function forEach(obj, iterator, context) {
        var key;
        if (obj) {
            if (isFunction(obj)){
                for (key in obj) {
                    if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key);
                    }
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context);
            } else if (isArrayLike(obj)) {
                for (key = 0; key < obj.length; key++)
                    iterator.call(context, obj[key], key);
            } else {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key);
                    }
                }
            }
        }
        return obj;
    }

    function sortedKeys(obj) {
        var keys = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys.sort();
    }

    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj);
        for ( var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }


    /**
     * when using forEach the params are value, key, but it is often useful to have key, value.
     * @param {function(string, *)} iteratorFn
     * @returns {function(*, string)}
     */
    function reverseParams(iteratorFn) {
        return function(value, key) { iteratorFn(key, value) };
    }

    /**
     * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
     * characters such as '012ABC'. The reason why we are not using simply a number counter is that
     * the number string gets longer over time, and it can also overflow, where as the nextId
     * will grow much slower, it is a string, and it will never overflow.
     *
     * @returns an unique alpha-numeric string
     */
    function nextUid() {
        var index = uid.length;
        var digit;

        while(index) {
            index--;
            digit = uid[index].charCodeAt(0);
            if (digit == 57 /*'9'*/) {
                uid[index] = 'A';
                return uid.join('');
            }
            if (digit == 90  /*'Z'*/) {
                uid[index] = '0';
            } else {
                uid[index] = String.fromCharCode(digit + 1);
                return uid.join('');
            }
        }
        uid.unshift('0');
        return uid.join('');
    }


    /**
     * Set or clear the hashkey for an object.
     * @param obj object
     * @param h the hashkey (!truthy to delete the hashkey)
     */
    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h;
        }
        else {
            delete obj.$$hashKey;
        }
    }

    /**
     * @ngdoc function
     * @name angular.extend
     * @function
     *
     * @description
     * Extends the destination object `dst` by copying all of the properties from the `src` object(s)
     * to `dst`. You can specify multiple `src` objects.
     *
     * @param {Object} dst Destination object.
     * @param {...Object} src Source object(s).
     * @returns {Object} Reference to `dst`.
     */
    function extend(dst) {
        var h = dst.$$hashKey;
        forEach(arguments, function(obj){
            if (obj !== dst) {
                forEach(obj, function(value, key){
                    dst[key] = value;
                });
            }
        });

        setHashKey(dst,h);
        return dst;
    }

    function int(str) {
        return parseInt(str, 10);
    }


    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype:parent}))(), extra);
    }

    var START_SPACE = /^\s*/;
    var END_SPACE = /\s*$/;
    function stripWhitespace(str) {
        return isString(str) ? str.replace(START_SPACE, '').replace(END_SPACE, '') : str;
    }

    /**
     * @ngdoc function
     * @name angular.noop
     * @function
     *
     * @description
     * A function that performs no operations. This function can be useful when writing code in the
     * functional style.
     <pre>
     function foo(callback) {
       var result = calculateResult();
       (callback || angular.noop)(result);
     }
     </pre>
     */
    function noop() {}
    noop.$inject = [];


    /**
     * @ngdoc function
     * @name angular.identity
     * @function
     *
     * @description
     * A function that returns its first argument. This function is useful when writing code in the
     * functional style.
     *
     <pre>
     function transformer(transformationFn, value) {
       return (transformationFn || identity)(value);
     };
     </pre>
     */
    function identity($) {return $;}
    identity.$inject = [];


    function valueFn(value) {return function() {return value;};}

    /**
     * @ngdoc function
     * @name angular.isUndefined
     * @function
     *
     * @description
     * Determines if a reference is undefined.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is undefined.
     */
    function isUndefined(value){return typeof value == 'undefined';}


    /**
     * @ngdoc function
     * @name angular.isDefined
     * @function
     *
     * @description
     * Determines if a reference is defined.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is defined.
     */
    function isDefined(value){return typeof value != 'undefined';}


    /**
     * @ngdoc function
     * @name angular.isObject
     * @function
     *
     * @description
     * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
     * considered to be objects.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is an `Object` but not `null`.
     */
    function isObject(value){return value != null && typeof value == 'object';}


    /**
     * @ngdoc function
     * @name angular.isString
     * @function
     *
     * @description
     * Determines if a reference is a `String`.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a `String`.
     */
    function isString(value){return typeof value == 'string';}


    /**
     * @ngdoc function
     * @name angular.isNumber
     * @function
     *
     * @description
     * Determines if a reference is a `Number`.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a `Number`.
     */
    function isNumber(value){return typeof value == 'number';}


    /**
     * @ngdoc function
     * @name angular.isDate
     * @function
     *
     * @description
     * Determines if a value is a date.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a `Date`.
     */
    function isDate(value){
        return toString.apply(value) == '[object Date]';
    }


    /**
     * @ngdoc function
     * @name angular.isArray
     * @function
     *
     * @description
     * Determines if a reference is an `Array`.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is an `Array`.
     */
    function isArray(value) {
        return toString.apply(value) == '[object Array]';
    }


    /**
     * @ngdoc function
     * @name angular.isFunction
     * @function
     *
     * @description
     * Determines if a reference is a `Function`.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a `Function`.
     */
    function isFunction(value){return typeof value == 'function';}


    /**
     * Checks if `obj` is a window object.
     *
     * @private
     * @param {*} obj Object to check
     * @returns {boolean} True if `obj` is a window obj.
     */
    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    }


    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }


    function isFile(obj) {
        return toString.apply(obj) === '[object File]';
    }


    function isBoolean(value) {
        return typeof value == 'boolean';
    }


    function trim(value) {
        return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
    }

    /**
     * @ngdoc function
     * @name angular.isElement
     * @function
     *
     * @description
     * Determines if a reference is a DOM element (or wrapped jQuery element).
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
     */
    function isElement(node) {
        return node &&
            (node.nodeName  // we are a direct element
                || (node.bind && node.find));  // we have a bind and find method part of jQuery API
    }

    /**
     * @param str 'key1,key2,...'
     * @returns {object} in the form of {key1:true, key2:true, ...}
     */
    function makeMap(str){
        var obj = {}, items = str.split(","), i;
        for ( i = 0; i < items.length; i++ )
            obj[ items[i] ] = true;
        return obj;
    }


    if (msie < 9) {
        nodeName_ = function(element) {
            element = element.nodeName ? element : element[0];
            return (element.scopeName && element.scopeName != 'HTML')
                ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
        };
    } else {
        nodeName_ = function(element) {
            return element.nodeName ? element.nodeName : element[0].nodeName;
        };
    }


    function map(obj, iterator, context) {
        var results = [];
        forEach(obj, function(value, index, list) {
            results.push(iterator.call(context, value, index, list));
        });
        return results;
    }


    /**
     * @description
     * Determines the number of elements in an array, the number of properties an object has, or
     * the length of a string.
     *
     * Note: This function is used to augment the Object type in Angular expressions. See
     * {@link angular.Object} for more information about Angular arrays.
     *
     * @param {Object|Array|string} obj Object, array, or string to inspect.
     * @param {boolean} [ownPropsOnly=false] Count only "own" properties in an object
     * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.
     */
    function size(obj, ownPropsOnly) {
        var size = 0, key;

        if (isArray(obj) || isString(obj)) {
            return obj.length;
        } else if (isObject(obj)){
            for (key in obj)
                if (!ownPropsOnly || obj.hasOwnProperty(key))
                    size++;
        }

        return size;
    }


    function includes(array, obj) {
        return indexOf(array, obj) != -1;
    }

    function indexOf(array, obj) {
        if (array.indexOf) return array.indexOf(obj);

        for ( var i = 0; i < array.length; i++) {
            if (obj === array[i]) return i;
        }
        return -1;
    }

    function arrayRemove(array, value) {
        var index = indexOf(array, value);
        if (index >=0)
            array.splice(index, 1);
        return value;
    }

    function isLeafNode (node) {
        if (node) {
            switch (node.nodeName) {
                case "OPTION":
                case "PRE":
                case "TITLE":
                    return true;
            }
        }
        return false;
    }

    /**
     * @ngdoc function
     * @name angular.copy
     * @function
     *
     * @description
     * Creates a deep copy of `source`, which should be an object or an array.
     *
     * * If no destination is supplied, a copy of the object or array is created.
     * * If a destination is provided, all of its elements (for array) or properties (for objects)
     *   are deleted and then all elements/properties from the source are copied to it.
     * * If  `source` is not an object or array, `source` is returned.
     *
     * Note: this function is used to augment the Object type in Angular expressions. See
     * {@link ng.$filter} for more information about Angular arrays.
     *
     * @param {*} source The source that will be used to make a copy.
     *                   Can be any type, including primitives, `null`, and `undefined`.
     * @param {(Object|Array)=} destination Destination into which the source is copied. If
     *     provided, must be of the same type as `source`.
     * @returns {*} The copy or updated `destination`, if `destination` was specified.
     */
    function copy(source, destination){
        if (isWindow(source) || isScope(source)) throw Error("Can't copy Window or Scope");
        if (!destination) {
            destination = source;
            if (source) {
                if (isArray(source)) {
                    destination = copy(source, []);
                } else if (isDate(source)) {
                    destination = new Date(source.getTime());
                } else if (isObject(source)) {
                    destination = copy(source, {});
                }
            }
        } else {
            if (source === destination) throw Error("Can't copy equivalent objects or arrays");
            if (isArray(source)) {
                destination.length = 0;
                for ( var i = 0; i < source.length; i++) {
                    destination.push(copy(source[i]));
                }
            } else {
                var h = destination.$$hashKey;
                forEach(destination, function(value, key){
                    delete destination[key];
                });
                for ( var key in source) {
                    destination[key] = copy(source[key]);
                }
                setHashKey(destination,h);
            }
        }
        return destination;
    }

    /**
     * Create a shallow copy of an object
     */
    function shallowCopy(src, dst) {
        dst = dst || {};

        for(var key in src) {
            if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
                dst[key] = src[key];
            }
        }

        return dst;
    }


    /**
     * @ngdoc function
     * @name angular.equals
     * @function
     *
     * @description
     * Determines if two objects or two values are equivalent. Supports value types, arrays and
     * objects.
     *
     * Two objects or values are considered equivalent if at least one of the following is true:
     *
     * * Both objects or values pass `===` comparison.
     * * Both objects or values are of the same type and all of their properties pass `===` comparison.
     * * Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)
     *
     * During a property comparison, properties of `function` type and properties with names
     * that begin with `$` are ignored.
     *
     * Scope and DOMWindow objects are being compared only by identify (`===`).
     *
     * @param {*} o1 Object or value to compare.
     * @param {*} o2 Object or value to compare.
     * @returns {boolean} True if arguments are equal.
     */
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 == t2) {
            if (t1 == 'object') {
                if (isArray(o1)) {
                    if ((length = o1.length) == o2.length) {
                        for(key=0; key<length; key++) {
                            if (!equals(o1[key], o2[key])) return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    return isDate(o2) && o1.getTime() == o2.getTime();
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2)) return false;
                    keySet = {};
                    for(key in o1) {
                        if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
                        if (!equals(o1[key], o2[key])) return false;
                        keySet[key] = true;
                    }
                    for(key in o2) {
                        if (!keySet[key] &&
                            key.charAt(0) !== '$' &&
                            o2[key] !== undefined &&
                            !isFunction(o2[key])) return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }


    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }

    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }


    /**
     * @ngdoc function
     * @name angular.bind
     * @function
     *
     * @description
     * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
     * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
     * known as [function currying](http://en.wikipedia.org/wiki/Currying).
     *
     * @param {Object} self Context which `fn` should be evaluated in.
     * @param {function()} fn Function to be bound.
     * @param {...*} args Optional arguments to be prebound to the `fn` function call.
     * @returns {function()} Function that wraps the `fn` with all the specified bindings.
     */
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length
                ? function() {
                return arguments.length
                    ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))
                    : fn.apply(self, curryArgs);
            }
                : function() {
                return arguments.length
                    ? fn.apply(self, arguments)
                    : fn.call(self);
            };
        } else {
            // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)
            return fn;
        }
    }


    function toJsonReplacer(key, value) {
        var val = value;

        if (/^\$+/.test(key)) {
            val = undefined;
        } else if (isWindow(value)) {
            val = '$WINDOW';
        } else if (value &&  document === value) {
            val = '$DOCUMENT';
        } else if (isScope(value)) {
            val = '$SCOPE';
        }

        return val;
    }


    /**
     * @ngdoc function
     * @name angular.toJson
     * @function
     *
     * @description
     * Serializes input into a JSON-formatted string.
     *
     * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
     * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.
     * @returns {string} Jsonified string representing `obj`.
     */
    function toJson(obj, pretty) {
        return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
    }


    /**
     * @ngdoc function
     * @name angular.fromJson
     * @function
     *
     * @description
     * Deserializes a JSON string.
     *
     * @param {string} json JSON string to deserialize.
     * @returns {Object|Array|Date|string|number} Deserialized thingy.
     */
    function fromJson(json) {
        return isString(json)
            ? JSON.parse(json)
            : json;
    }


    function toBoolean(value) {
        if (value && value.length !== 0) {
            var v = lowercase("" + value);
            value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
        } else {
            value = false;
        }
        return value;
    }

    /**
     * @returns {string} Returns the string representation of the element.
     */
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            // turns out IE does not let you set .html() on elements which
            // are not allowed to have children. So we just ignore it.
            element.html('');
        } catch(e) {}
        // As Per DOM Standards
        var TEXT_NODE = 3;
        var elemHtml = jqLite('<div>').append(element).html();
        try {
            return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :
                elemHtml.
                    match(/^(<[^>]+>)/)[1].
                    replace(/^<([\w\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });
        } catch(e) {
            return lowercase(elemHtml);
        }

    }


/////////////////////////////////////////////////

    /**
     * Parses an escaped url query string into key-value pairs.
     * @returns Object.<(string|boolean)>
     */
    function parseKeyValue(/**string*/keyValue) {
        var obj = {}, key_value, key;
        forEach((keyValue || "").split('&'), function(keyValue){
            if (keyValue) {
                key_value = keyValue.split('=');
                key = decodeURIComponent(key_value[0]);
                obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;
            }
        });
        return obj;
    }

    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
        });
        return parts.length ? parts.join('&') : '';
    }


    /**
     * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
     * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
     * segments:
     *    segment       = *pchar
     *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
     *    pct-encoded   = "%" HEXDIG HEXDIG
     *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
     *                     / "*" / "+" / "," / ";" / "="
     */
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).
            replace(/%26/gi, '&').
            replace(/%3D/gi, '=').
            replace(/%2B/gi, '+');
    }


    /**
     * This method is intended for encoding *key* or *value* parts of query component. We need a custom
     * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
     * encoded per http://tools.ietf.org/html/rfc3986:
     *    query       = *( pchar / "/" / "?" )
     *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
     *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     *    pct-encoded   = "%" HEXDIG HEXDIG
     *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
     *                     / "*" / "+" / "," / ";" / "="
     */
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).
            replace(/%40/gi, '@').
            replace(/%3A/gi, ':').
            replace(/%24/g, '$').
            replace(/%2C/gi, ',').
            replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
    }


    /**
     * @ngdoc directive
     * @name ng.directive:ngApp
     *
     * @element ANY
     * @param {angular.Module} ngApp an optional application
     *   {@link angular.module module} name to load.
     *
     * @description
     *
     * Use this directive to auto-bootstrap an application. Only
     * one directive can be used per HTML document. The directive
     * designates the root of the application and is typically placed
     * at the root of the page.
     *
     * In the example below if the `ngApp` directive would not be placed
     * on the `html` element then the document would not be compiled
     * and the `{{ 1+2 }}` would not be resolved to `3`.
     *
     * `ngApp` is the easiest way to bootstrap an application.
     *
     <doc:example>
     <doc:source>
     I can add: 1 + 2 =  {{ 1+2 }}
     </doc:source>
     </doc:example>
     *
     */
    function angularInit(element, bootstrap) {
        var elements = [element],
            appElement,
            module,
            names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],
            NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;

        function append(element) {
            element && elements.push(element);
        }

        forEach(names, function(name) {
            names[name] = true;
            append(document.getElementById(name));
            name = name.replace(':', '\\:');
            if (element.querySelectorAll) {
                forEach(element.querySelectorAll('.' + name), append);
                forEach(element.querySelectorAll('.' + name + '\\:'), append);
                forEach(element.querySelectorAll('[' + name + ']'), append);
            }
        });

        forEach(elements, function(element) {
            if (!appElement) {
                var className = ' ' + element.className + ' ';
                var match = NG_APP_CLASS_REGEXP.exec(className);
                if (match) {
                    appElement = element;
                    module = (match[2] || '').replace(/\s+/g, ',');
                } else {
                    forEach(element.attributes, function(attr) {
                        if (!appElement && names[attr.name]) {
                            appElement = element;
                            module = attr.value;
                        }
                    });
                }
            }
        });
        if (appElement) {
            bootstrap(appElement, module ? [module] : []);
        }
    }

    /**
     * @ngdoc function
     * @name angular.bootstrap
     * @description
     * Use this function to manually start up angular application.
     *
     * See: {@link guide/bootstrap Bootstrap}
     *
     * @param {Element} element DOM element which is the root of angular application.
     * @param {Array<String|Function>=} modules an array of module declarations. See: {@link angular.module modules}
     * @returns {AUTO.$injector} Returns the newly created injector for this app.
     */
    function bootstrap(element, modules) {
        var resumeBootstrapInternal = function() {
            element = jqLite(element);
            modules = modules || [];
            modules.unshift(['$provide', function($provide) {
                $provide.value('$rootElement', element);
            }]);
            modules.unshift('ng');
            var injector = createInjector(modules);
            injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animator',
                function(scope, element, compile, injector, animator) {
                    scope.$apply(function() {
                        element.data('$injector', injector);
                        compile(element)(scope);
                    });
                    animator.enabled(true);
                }]
            );
            return injector;
        };

        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;

        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return resumeBootstrapInternal();
        }

        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            });
            resumeBootstrapInternal();
        };
    }

    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator){
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : '') + letter.toLowerCase();
        });
    }

    function bindJQuery() {
        // bind to jQuery if present;
        jQuery = window.jQuery;
        // reset to jQuery or default to us.
        if (jQuery) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
            JQLitePatchJQueryRemove('remove', true);
            JQLitePatchJQueryRemove('empty');
            JQLitePatchJQueryRemove('html');
        } else {
            jqLite = JQLite;
        }
        angular.element = jqLite;
    }

    /**
     * throw error if the argument is falsy.
     */
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw new Error("Argument '" + (name || '?') + "' is " + (reason || "required"));
        }
        return arg;
    }

    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }

        assertArg(isFunction(arg), name, 'not a function, got ' +
            (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
    }

    /**
     * @ngdoc interface
     * @name angular.Module
     * @description
     *
     * Interface for configuring angular {@link angular.module modules}.
     */

    function setupModuleLoader(window) {

        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }

        return ensure(ensure(window, 'angular', Object), 'module', function() {
            /** @type {Object.<string, angular.Module>} */
            var modules = {};

            /**
             * @ngdoc function
             * @name angular.module
             * @description
             *
             * The `angular.module` is a global place for creating and registering Angular modules. All
             * modules (angular core or 3rd party) that should be available to an application must be
             * registered using this mechanism.
             *
             *
             * # Module
             *
             * A module is a collocation of services, directives, filters, and configuration information. Module
             * is used to configure the {@link AUTO.$injector $injector}.
             *
             * <pre>
             * // Create a new module
             * var myModule = angular.module('myModule', []);
             *
             * // register a new service
             * myModule.value('appName', 'MyCoolApp');
             *
             * // configure existing services inside initialization blocks.
             * myModule.config(function($locationProvider) {
     *   // Configure existing providers
     *   $locationProvider.hashPrefix('!');
     * });
             * </pre>
             *
             * Then you can create an injector and load your modules like this:
             *
             * <pre>
             * var injector = angular.injector(['ng', 'MyModule'])
             * </pre>
             *
             * However it's more likely that you'll just use
             * {@link ng.directive:ngApp ngApp} or
             * {@link angular.bootstrap} to simplify this process for you.
             *
             * @param {!string} name The name of the module to create or retrieve.
             * @param {Array.<string>=} requires If specified then new module is being created. If unspecified then the
             *        the module is being retrieved for further configuration.
             * @param {Function} configFn Optional configuration function for the module. Same as
             *        {@link angular.Module#config Module#config()}.
             * @returns {module} new module with the {@link angular.Module} api.
             */
            return function module(name, requires, configFn) {
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw Error('No module: ' + name);
                    }

                    /** @type {!Array.<Array.<*>>} */
                    var invokeQueue = [];

                    /** @type {!Array.<Function>} */
                    var runBlocks = [];

                    var config = invokeLater('$injector', 'invoke');

                    /** @type {angular.Module} */
                    var moduleInstance = {
                        // Private state
                        _invokeQueue: invokeQueue,
                        _runBlocks: runBlocks,

                        /**
                         * @ngdoc property
                         * @name angular.Module#requires
                         * @propertyOf angular.Module
                         * @returns {Array.<string>} List of module names which must be loaded before this module.
                         * @description
                         * Holds the list of modules which the injector will load before the current module is loaded.
                         */
                        requires: requires,

                        /**
                         * @ngdoc property
                         * @name angular.Module#name
                         * @propertyOf angular.Module
                         * @returns {string} Name of the module.
                         * @description
                         */
                        name: name,


                        /**
                         * @ngdoc method
                         * @name angular.Module#provider
                         * @methodOf angular.Module
                         * @param {string} name service name
                         * @param {Function} providerType Construction function for creating new instance of the service.
                         * @description
                         * See {@link AUTO.$provide#provider $provide.provider()}.
                         */
                        provider: invokeLater('$provide', 'provider'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#factory
                         * @methodOf angular.Module
                         * @param {string} name service name
                         * @param {Function} providerFunction Function for creating new instance of the service.
                         * @description
                         * See {@link AUTO.$provide#factory $provide.factory()}.
                         */
                        factory: invokeLater('$provide', 'factory'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#service
                         * @methodOf angular.Module
                         * @param {string} name service name
                         * @param {Function} constructor A constructor function that will be instantiated.
                         * @description
                         * See {@link AUTO.$provide#service $provide.service()}.
                         */
                        service: invokeLater('$provide', 'service'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#value
                         * @methodOf angular.Module
                         * @param {string} name service name
                         * @param {*} object Service instance object.
                         * @description
                         * See {@link AUTO.$provide#value $provide.value()}.
                         */
                        value: invokeLater('$provide', 'value'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#constant
                         * @methodOf angular.Module
                         * @param {string} name constant name
                         * @param {*} object Constant value.
                         * @description
                         * Because the constant are fixed, they get applied before other provide methods.
                         * See {@link AUTO.$provide#constant $provide.constant()}.
                         */
                        constant: invokeLater('$provide', 'constant', 'unshift'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#animation
                         * @methodOf angular.Module
                         * @param {string} name animation name
                         * @param {Function} animationFactory Factory function for creating new instance of an animation.
                         * @description
                         *
                         * Defines an animation hook that can be later used with {@link ng.directive:ngAnimate ngAnimate}
                         * alongside {@link ng.directive:ngAnimate#Description common ng directives} as well as custom directives.
                         * <pre>
                         * module.animation('animation-name', function($inject1, $inject2) {
           *   return {
           *     //this gets called in preparation to setup an animation
           *     setup : function(element) { ... },
           *
           *     //this gets called once the animation is run
           *     start : function(element, done, memo) { ... }
           *   }
           * })
                         * </pre>
                         *
                         * See {@link ng.$animationProvider#register $animationProvider.register()} and
                         * {@link ng.directive:ngAnimate ngAnimate} for more information.
                         */
                        animation: invokeLater('$animationProvider', 'register'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#filter
                         * @methodOf angular.Module
                         * @param {string} name Filter name.
                         * @param {Function} filterFactory Factory function for creating new instance of filter.
                         * @description
                         * See {@link ng.$filterProvider#register $filterProvider.register()}.
                         */
                        filter: invokeLater('$filterProvider', 'register'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#controller
                         * @methodOf angular.Module
                         * @param {string} name Controller name.
                         * @param {Function} constructor Controller constructor function.
                         * @description
                         * See {@link ng.$controllerProvider#register $controllerProvider.register()}.
                         */
                        controller: invokeLater('$controllerProvider', 'register'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#directive
                         * @methodOf angular.Module
                         * @param {string} name directive name
                         * @param {Function} directiveFactory Factory function for creating new instance of
                         * directives.
                         * @description
                         * See {@link ng.$compileProvider#directive $compileProvider.directive()}.
                         */
                        directive: invokeLater('$compileProvider', 'directive'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#config
                         * @methodOf angular.Module
                         * @param {Function} configFn Execute this function on module load. Useful for service
                         *    configuration.
                         * @description
                         * Use this method to register work which needs to be performed on module loading.
                         */
                        config: config,

                        /**
                         * @ngdoc method
                         * @name angular.Module#run
                         * @methodOf angular.Module
                         * @param {Function} initializationFn Execute this function after injector creation.
                         *    Useful for application initialization.
                         * @description
                         * Use this method to register work which should be performed when the injector is done
                         * loading all modules.
                         */
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };

                    if (configFn) {
                        config(configFn);
                    }

                    return  moduleInstance;

                    /**
                     * @param {string} provider
                     * @param {string} method
                     * @param {String=} insertMethod
                     * @returns {angular.Module}
                     */
                    function invokeLater(provider, method, insertMethod) {
                        return function() {
                            invokeQueue[insertMethod || 'push']([provider, method, arguments]);
                            return moduleInstance;
                        }
                    }
                });
            };
        });

    }

    /**
     * @ngdoc property
     * @name angular.version
     * @description
     * An object that contains information about the current AngularJS version. This object has the
     * following properties:
     *
     * - `full` â€“ `{string}` â€“ Full version string, such as "0.9.18".
     * - `major` â€“ `{number}` â€“ Major version number, such as "0".
     * - `minor` â€“ `{number}` â€“ Minor version number, such as "9".
     * - `dot` â€“ `{number}` â€“ Dot version number, such as "18".
     * - `codeName` â€“ `{string}` â€“ Code name of the release, such as "jiggling-armfat".
     */
    var version = {
        full: '1.1.5',    // all of these placeholder strings will be replaced by grunt's
        major: 1,    // package task
        minor: 1,
        dot: 5,
        codeName: 'triangle-squarification'
    };


    function publishExternalAPI(angular){
        extend(angular, {
            'bootstrap': bootstrap,
            'copy': copy,
            'extend': extend,
            'equals': equals,
            'element': jqLite,
            'forEach': forEach,
            'injector': createInjector,
            'noop':noop,
            'bind':bind,
            'toJson': toJson,
            'fromJson': fromJson,
            'identity':identity,
            'isUndefined': isUndefined,
            'isDefined': isDefined,
            'isString': isString,
            'isFunction': isFunction,
            'isObject': isObject,
            'isNumber': isNumber,
            'isElement': isElement,
            'isArray': isArray,
            'version': version,
            'isDate': isDate,
            'lowercase': lowercase,
            'uppercase': uppercase,
            'callbacks': {counter: 0},
            'noConflict': noConflict
        });

        angularModule = setupModuleLoader(window);
        try {
            angularModule('ngLocale');
        } catch (e) {
            angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
        }

        angularModule('ng', ['ngLocale'], ['$provide',
            function ngModule($provide) {
                $provide.provider('$compile', $CompileProvider).
                    directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        style: styleDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCsp: ngCspDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngIf: ngIfDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngSubmit: ngSubmitDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngView: ngViewDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        ngValue: ngValueDirective
                    }).
                    directive(ngAttributeAliasDirectives).
                    directive(ngEventDirectives);
                $provide.provider({
                    $anchorScroll: $AnchorScrollProvider,
                    $animation: $AnimationProvider,
                    $animator: $AnimatorProvider,
                    $browser: $BrowserProvider,
                    $cacheFactory: $CacheFactoryProvider,
                    $controller: $ControllerProvider,
                    $document: $DocumentProvider,
                    $exceptionHandler: $ExceptionHandlerProvider,
                    $filter: $FilterProvider,
                    $interpolate: $InterpolateProvider,
                    $http: $HttpProvider,
                    $httpBackend: $HttpBackendProvider,
                    $location: $LocationProvider,
                    $log: $LogProvider,
                    $parse: $ParseProvider,
                    $route: $RouteProvider,
                    $routeParams: $RouteParamsProvider,
                    $rootScope: $RootScopeProvider,
                    $q: $QProvider,
                    $sniffer: $SnifferProvider,
                    $templateCache: $TemplateCacheProvider,
                    $timeout: $TimeoutProvider,
                    $window: $WindowProvider
                });
            }
        ]);
    }

//////////////////////////////////
//JQLite
//////////////////////////////////

    /**
     * @ngdoc function
     * @name angular.element
     * @function
     *
     * @description
     * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
     * `angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if
     * jQuery is available, or a function that wraps the element or string in Angular's jQuery lite
     * implementation (commonly referred to as jqLite).
     *
     * Real jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`
     * event fired.
     *
     * jqLite is a tiny, API-compatible subset of jQuery that allows
     * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality
     * within a very small footprint, so only a subset of the jQuery API - methods, arguments and
     * invocation styles - are supported.
     *
     * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never
     * raw DOM references.
     *
     * ## Angular's jQuery lite provides the following methods:
     *
     * - [addClass()](http://api.jquery.com/addClass/)
     * - [after()](http://api.jquery.com/after/)
     * - [append()](http://api.jquery.com/append/)
     * - [attr()](http://api.jquery.com/attr/)
     * - [bind()](http://api.jquery.com/bind/) - Does not support namespaces
     * - [children()](http://api.jquery.com/children/) - Does not support selectors
     * - [clone()](http://api.jquery.com/clone/)
     * - [contents()](http://api.jquery.com/contents/)
     * - [css()](http://api.jquery.com/css/)
     * - [data()](http://api.jquery.com/data/)
     * - [eq()](http://api.jquery.com/eq/)
     * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name
     * - [hasClass()](http://api.jquery.com/hasClass/)
     * - [html()](http://api.jquery.com/html/)
     * - [next()](http://api.jquery.com/next/) - Does not support selectors
     * - [parent()](http://api.jquery.com/parent/) - Does not support selectors
     * - [prepend()](http://api.jquery.com/prepend/)
     * - [prop()](http://api.jquery.com/prop/)
     * - [ready()](http://api.jquery.com/ready/)
     * - [remove()](http://api.jquery.com/remove/)
     * - [removeAttr()](http://api.jquery.com/removeAttr/)
     * - [removeClass()](http://api.jquery.com/removeClass/)
     * - [removeData()](http://api.jquery.com/removeData/)
     * - [replaceWith()](http://api.jquery.com/replaceWith/)
     * - [text()](http://api.jquery.com/text/)
     * - [toggleClass()](http://api.jquery.com/toggleClass/)
     * - [triggerHandler()](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
     * - [unbind()](http://api.jquery.com/unbind/) - Does not support namespaces
     * - [val()](http://api.jquery.com/val/)
     * - [wrap()](http://api.jquery.com/wrap/)
     *
     * ## In addition to the above, Angular provides additional methods to both jQuery and jQuery lite:
     *
     * - `controller(name)` - retrieves the controller of the current element or its parent. By default
     *   retrieves controller associated with the `ngController` directive. If `name` is provided as
     *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
     *   `'ngModel'`).
     * - `injector()` - retrieves the injector of the current element or its parent.
     * - `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current
     *   element or its parent.
     * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
     *   parent element is reached.
     *
     * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
     * @returns {Object} jQuery object.
     */

    var jqCache = JQLite.cache = {},
        jqName = JQLite.expando = 'ng-' + new Date().getTime(),
        jqId = 1,
        addEventListenerFn = (window.document.addEventListener
            ? function(element, type, fn) {element.addEventListener(type, fn, false);}
            : function(element, type, fn) {element.attachEvent('on' + type, fn);}),
        removeEventListenerFn = (window.document.removeEventListener
            ? function(element, type, fn) {element.removeEventListener(type, fn, false); }
            : function(element, type, fn) {element.detachEvent('on' + type, fn); });

    function jqNextId() { return ++jqId; }


    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;

    /**
     * Converts snake_case to camelCase.
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
    function camelCase(name) {
        return name.
            replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            }).
            replace(MOZ_HACK_REGEXP, 'Moz$1');
    }

/////////////////////////////////////////////
// jQuery mutation patch
//
//  In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a
// $destroy event on all DOM nodes being removed.
//
/////////////////////////////////////////////

    function JQLitePatchJQueryRemove(name, dispatchThis) {
        var originalJqFn = jQuery.fn[name];
        originalJqFn = originalJqFn.$original || originalJqFn;
        removePatch.$original = originalJqFn;
        jQuery.fn[name] = removePatch;

        function removePatch() {
            var list = [this],
                fireEvent = dispatchThis,
                set, setIndex, setLength,
                element, childIndex, childLength, children,
                fns, events;

            while(list.length) {
                set = list.shift();
                for(setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
                    element = jqLite(set[setIndex]);
                    if (fireEvent) {
                        element.triggerHandler('$destroy');
                    } else {
                        fireEvent = !fireEvent;
                    }
                    for(childIndex = 0, childLength = (children = element.children()).length;
                        childIndex < childLength;
                        childIndex++) {
                        list.push(jQuery(children[childIndex]));
                    }
                }
            }
            return originalJqFn.apply(this, arguments);
        }
    }

/////////////////////////////////////////////
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        if (!(this instanceof JQLite)) {
            if (isString(element) && element.charAt(0) != '<') {
                throw Error('selectors not implemented');
            }
            return new JQLite(element);
        }

        if (isString(element)) {
            var div = document.createElement('div');
            // Read about the NoScope elements here:
            // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx
            div.innerHTML = '<div>&#160;</div>' + element; // IE insanity to make NoScope elements work!
            div.removeChild(div.firstChild); // remove the superfluous div
            JQLiteAddNodes(this, div.childNodes);
            this.remove(); // detach the elements from the temporary DOM div.
        } else {
            JQLiteAddNodes(this, element);
        }
    }

    function JQLiteClone(element) {
        return element.cloneNode(true);
    }

    function JQLiteDealoc(element){
        JQLiteRemoveData(element);
        for ( var i = 0, children = element.childNodes || []; i < children.length; i++) {
            JQLiteDealoc(children[i]);
        }
    }

    function JQLiteUnbind(element, type, fn) {
        var events = JQLiteExpandoStore(element, 'events'),
            handle = JQLiteExpandoStore(element, 'handle');

        if (!handle) return; //no listeners registered

        if (isUndefined(type)) {
            forEach(events, function(eventHandler, type) {
                removeEventListenerFn(element, type, eventHandler);
                delete events[type];
            });
        } else {
            if (isUndefined(fn)) {
                removeEventListenerFn(element, type, events[type]);
                delete events[type];
            } else {
                arrayRemove(events[type], fn);
            }
        }
    }

    function JQLiteRemoveData(element) {
        var expandoId = element[jqName],
            expandoStore = jqCache[expandoId];

        if (expandoStore) {
            if (expandoStore.handle) {
                expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
                JQLiteUnbind(element);
            }
            delete jqCache[expandoId];
            element[jqName] = undefined; // ie does not allow deletion of attributes on elements.
        }
    }

    function JQLiteExpandoStore(element, key, value) {
        var expandoId = element[jqName],
            expandoStore = jqCache[expandoId || -1];

        if (isDefined(value)) {
            if (!expandoStore) {
                element[jqName] = expandoId = jqNextId();
                expandoStore = jqCache[expandoId] = {};
            }
            expandoStore[key] = value;
        } else {
            return expandoStore && expandoStore[key];
        }
    }

    function JQLiteData(element, key, value) {
        var data = JQLiteExpandoStore(element, 'data'),
            isSetter = isDefined(value),
            keyDefined = !isSetter && isDefined(key),
            isSimpleGetter = keyDefined && !isObject(key);

        if (!data && !isSimpleGetter) {
            JQLiteExpandoStore(element, 'data', data = {});
        }

        if (isSetter) {
            data[key] = value;
        } else {
            if (keyDefined) {
                if (isSimpleGetter) {
                    // don't create data in this case.
                    return data && data[key];
                } else {
                    extend(data, key);
                }
            } else {
                return data;
            }
        }
    }

    function JQLiteHasClass(element, selector) {
        return ((" " + element.className + " ").replace(/[\n\t]/g, " ").
            indexOf( " " + selector + " " ) > -1);
    }

    function JQLiteRemoveClass(element, cssClasses) {
        if (cssClasses) {
            forEach(cssClasses.split(' '), function(cssClass) {
                element.className = trim(
                    (" " + element.className + " ")
                        .replace(/[\n\t]/g, " ")
                        .replace(" " + trim(cssClass) + " ", " ")
                );
            });
        }
    }

    function JQLiteAddClass(element, cssClasses) {
        if (cssClasses) {
            forEach(cssClasses.split(' '), function(cssClass) {
                if (!JQLiteHasClass(element, cssClass)) {
                    element.className = trim(element.className + ' ' + trim(cssClass));
                }
            });
        }
    }

    function JQLiteAddNodes(root, elements) {
        if (elements) {
            elements = (!elements.nodeName && isDefined(elements.length) && !isWindow(elements))
                ? elements
                : [ elements ];
            for(var i=0; i < elements.length; i++) {
                root.push(elements[i]);
            }
        }
    }

    function JQLiteController(element, name) {
        return JQLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');
    }

    function JQLiteInheritedData(element, name, value) {
        element = jqLite(element);

        // if element is the document object work with the html element instead
        // this makes $(document).scope() possible
        if(element[0].nodeType == 9) {
            element = element.find('html');
        }

        while (element.length) {
            if (value = element.data(name)) return value;
            element = element.parent();
        }
    }

//////////////////////////////////////////
// Functions which are declared directly.
//////////////////////////////////////////
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            var fired = false;

            function trigger() {
                if (fired) return;
                fired = true;
                fn();
            }

            // check if document already is loaded
            if (document.readyState === 'complete'){
                setTimeout(trigger);
            } else {
                this.bind('DOMContentLoaded', trigger); // works for modern browsers and IE9
                // we can not use jqLite since we are not done loading and jQuery could be loaded later.
                JQLite(window).bind('load', trigger); // fallback to window.onload for others
            }
        },
        toString: function() {
            var value = [];
            forEach(this, function(e){ value.push('' + e);});
            return '[' + value.join(', ') + ']';
        },

        eq: function(index) {
            return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },

        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };

//////////////////////////////////////////
// Functions iterating getter/setters.
// these functions return self on setter and
// value on get.
//////////////////////////////////////////
    var BOOLEAN_ATTR = {};
    forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[uppercase(value)] = true;
    });

    function getBooleanAttrName(element, name) {
        // check dom last since we will most likely fail on name
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];

        // booleanAttr is here twice to minimize DOM access
        return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
    }

    forEach({
        data: JQLiteData,
        inheritedData: JQLiteInheritedData,

        scope: function(element) {
            return JQLiteInheritedData(element, '$scope');
        },

        controller: JQLiteController ,

        injector: function(element) {
            return JQLiteInheritedData(element, '$injector');
        },

        removeAttr: function(element,name) {
            element.removeAttribute(name);
        },

        hasClass: JQLiteHasClass,

        css: function(element, name, value) {
            name = camelCase(name);

            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                var val;

                if (msie <= 8) {
                    // this is some IE specific weirdness that jQuery 1.6.4 does not sure why
                    val = element.currentStyle && element.currentStyle[name];
                    if (val === '') val = 'auto';
                }

                val = val || element.style[name];

                if (msie <= 8) {
                    // jquery weirdness :-/
                    val = (val === '') ? undefined : val;
                }

                return  val;
            }
        },

        attr: function(element, name, value){
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (!!value) {
                        element[name] = true;
                        element.setAttribute(name, lowercasedName);
                    } else {
                        element[name] = false;
                        element.removeAttribute(lowercasedName);
                    }
                } else {
                    return (element[name] ||
                        (element.attributes.getNamedItem(name)|| noop).specified)
                        ? lowercasedName
                        : undefined;
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value);
            } else if (element.getAttribute) {
                // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
                // some elements (e.g. Document) don't have get attribute, so return undefined
                var ret = element.getAttribute(name, 2);
                // normalize non-existing attributes to undefined (as jQuery)
                return ret === null ? undefined : ret;
            }
        },

        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },

        text: extend((msie < 9)
            ? function(element, value) {
            if (element.nodeType == 1 /** Element */) {
                if (isUndefined(value))
                    return element.innerText;
                element.innerText = value;
            } else {
                if (isUndefined(value))
                    return element.nodeValue;
                element.nodeValue = value;
            }
        }
            : function(element, value) {
            if (isUndefined(value)) {
                return element.textContent;
            }
            element.textContent = value;
        }, {$dv:''}),

        val: function(element, value) {
            if (isUndefined(value)) {
                return element.value;
            }
            element.value = value;
        },

        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
                JQLiteDealoc(childNodes[i]);
            }
            element.innerHTML = value;
        }
    }, function(fn, name){
        /**
         * Properties: writes return selection, reads return first value
         */
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;

            // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
            // in a way that survives minification.
            if (((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController)) ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {

                    // we are a write, but the object properties are the key/values
                    for(i=0; i < this.length; i++) {
                        if (fn === JQLiteData) {
                            // data() takes the whole object in jQuery
                            fn(this[i], arg1);
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key]);
                            }
                        }
                    }
                    // return self for chaining
                    return this;
                } else {
                    // we are a read, so read the first child.
                    if (this.length)
                        return fn(this[0], arg1, arg2);
                }
            } else {
                // we are a write, so apply to all children
                for(i=0; i < this.length; i++) {
                    fn(this[i], arg1, arg2);
                }
                // return self for chaining
                return this;
            }
            return fn.$dv;
        };
    });

    function createEventHandler(element, events) {
        var eventHandler = function (event, type) {
            if (!event.preventDefault) {
                event.preventDefault = function() {
                    event.returnValue = false; //ie
                };
            }

            if (!event.stopPropagation) {
                event.stopPropagation = function() {
                    event.cancelBubble = true; //ie
                };
            }

            if (!event.target) {
                event.target = event.srcElement || document;
            }

            if (isUndefined(event.defaultPrevented)) {
                var prevent = event.preventDefault;
                event.preventDefault = function() {
                    event.defaultPrevented = true;
                    prevent.call(event);
                };
                event.defaultPrevented = false;
            }

            event.isDefaultPrevented = function() {
                return event.defaultPrevented || event.returnValue == false;
            };

            forEach(events[type || event.type], function(fn) {
                fn.call(element, event);
            });

            // Remove monkey-patched methods (IE),
            // as they would cause memory leaks in IE8.
            if (msie <= 8) {
                // IE7/8 does not allow to delete property on native object
                event.preventDefault = null;
                event.stopPropagation = null;
                event.isDefaultPrevented = null;
            } else {
                // It shouldn't affect normal browsers (native methods are defined on prototype).
                delete event.preventDefault;
                delete event.stopPropagation;
                delete event.isDefaultPrevented;
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    }

//////////////////////////////////////////
// Functions iterating traversal.
// These functions chain results into a single
// selector.
//////////////////////////////////////////
    forEach({
        removeData: JQLiteRemoveData,

        dealoc: JQLiteDealoc,

        bind: function bindFn(element, type, fn){
            var events = JQLiteExpandoStore(element, 'events'),
                handle = JQLiteExpandoStore(element, 'handle');

            if (!events) JQLiteExpandoStore(element, 'events', events = {});
            if (!handle) JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));

            forEach(type.split(' '), function(type){
                var eventFns = events[type];

                if (!eventFns) {
                    if (type == 'mouseenter' || type == 'mouseleave') {
                        var contains = document.body.contains || document.body.compareDocumentPosition ?
                            function( a, b ) {
                                var adown = a.nodeType === 9 ? a.documentElement : a,
                                    bup = b && b.parentNode;
                                return a === bup || !!( bup && bup.nodeType === 1 && (
                                    adown.contains ?
                                        adown.contains( bup ) :
                                        a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                                    ));
                            } :
                            function( a, b ) {
                                if ( b ) {
                                    while ( (b = b.parentNode) ) {
                                        if ( b === a ) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            };

                        events[type] = [];

                        // Refer to jQuery's implementation of mouseenter & mouseleave
                        // Read about mouseenter and mouseleave:
                        // http://www.quirksmode.org/js/events_mouse.html#link8
                        var eventmap = { mouseleave : "mouseout", mouseenter : "mouseover"}
                        bindFn(element, eventmap[type], function(event) {
                            var ret, target = this, related = event.relatedTarget;
                            // For mousenter/leave call the handler if related is outside the target.
                            // NB: No relatedTarget if the mouse left/entered the browser window
                            if ( !related || (related !== target && !contains(target, related)) ){
                                handle(event, type);
                            }

                        });

                    } else {
                        addEventListenerFn(element, type, handle);
                        events[type] = [];
                    }
                    eventFns = events[type]
                }
                eventFns.push(fn);
            });
        },

        unbind: JQLiteUnbind,

        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            JQLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node){
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },

        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element){
                if (element.nodeType === 1)
                    children.push(element);
            });
            return children;
        },

        contents: function(element) {
            return element.childNodes || [];
        },

        append: function(element, node) {
            forEach(new JQLite(node), function(child){
                if (element.nodeType === 1 || element.nodeType === 11) {
                    element.appendChild(child);
                }
            });
        },

        prepend: function(element, node) {
            if (element.nodeType === 1) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child){
                    if (index) {
                        element.insertBefore(child, index);
                    } else {
                        element.appendChild(child);
                        index = child;
                    }
                });
            }
        },

        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode)[0];
            var parent = element.parentNode;
            if (parent) {
                parent.replaceChild(wrapNode, element);
            }
            wrapNode.appendChild(element);
        },

        remove: function(element) {
            JQLiteDealoc(element);
            var parent = element.parentNode;
            if (parent) parent.removeChild(element);
        },

        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            forEach(new JQLite(newElement), function(node){
                parent.insertBefore(node, index.nextSibling);
                index = node;
            });
        },

        addClass: JQLiteAddClass,
        removeClass: JQLiteRemoveClass,

        toggleClass: function(element, selector, condition) {
            if (isUndefined(condition)) {
                condition = !JQLiteHasClass(element, selector);
            }
            (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
        },

        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },

        next: function(element) {
            if (element.nextElementSibling) {
                return element.nextElementSibling;
            }

            // IE8 doesn't have nextElementSibling
            var elm = element.nextSibling;
            while (elm != null && elm.nodeType !== 1) {
                elm = elm.nextSibling;
            }
            return elm;
        },

        find: function(element, selector) {
            return element.getElementsByTagName(selector);
        },

        clone: JQLiteClone,

        triggerHandler: function(element, eventName) {
            var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];
            var event;

            forEach(eventFns, function(fn) {
                fn.call(element, {preventDefault: noop});
            });
        }
    }, function(fn, name){
        /**
         * chaining functions
         */
        JQLite.prototype[name] = function(arg1, arg2) {
            var value;
            for(var i=0; i < this.length; i++) {
                if (value == undefined) {
                    value = fn(this[i], arg1, arg2);
                    if (value !== undefined) {
                        // any function which returns a value needs to be wrapped
                        value = jqLite(value);
                    }
                } else {
                    JQLiteAddNodes(value, fn(this[i], arg1, arg2));
                }
            }
            return value == undefined ? this : value;
        };
    });

    /**
     * Computes a hash of an 'obj'.
     * Hash of a:
     *  string is string
     *  number is number as string
     *  object is either result of calling $$hashKey function on the object or uniquely generated id,
     *         that is also assigned to the $$hashKey property of the object.
     *
     * @param obj
     * @returns {string} hash string such that the same input will have the same hash string.
     *         The resulting string key is in 'type:hashKey' format.
     */
    function hashKey(obj) {
        var objType = typeof obj,
            key;

        if (objType == 'object' && obj !== null) {
            if (typeof (key = obj.$$hashKey) == 'function') {
                // must invoke on object to keep the right this
                key = obj.$$hashKey();
            } else if (key === undefined) {
                key = obj.$$hashKey = nextUid();
            }
        } else {
            key = obj;
        }

        return objType + ':' + key;
    }

    /**
     * HashMap which can use objects as keys
     */
    function HashMap(array){
        forEach(array, this.put, this);
    }
    HashMap.prototype = {
        /**
         * Store key value pair
         * @param key key to store can be any type
         * @param value value to store can be any type
         */
        put: function(key, value) {
            this[hashKey(key)] = value;
        },

        /**
         * @param key
         * @returns the value for the key
         */
        get: function(key) {
            return this[hashKey(key)];
        },

        /**
         * Remove the key/value pair
         * @param key
         */
        remove: function(key) {
            var value = this[key = hashKey(key)];
            delete this[key];
            return value;
        }
    };

    /**
     * @ngdoc function
     * @name angular.injector
     * @function
     *
     * @description
     * Creates an injector function that can be used for retrieving services as well as for
     * dependency injection (see {@link guide/di dependency injection}).
     *

     * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
     *        {@link angular.module}. The `ng` module must be explicitly added.
     * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.
     *
     * @example
     * Typical usage
     * <pre>
     *   // create an injector
     *   var $injector = angular.injector(['ng']);
     *
     *   // use the injector to kick off your application
     *   // use the type inference to auto inject arguments, or use implicit injection
     *   $injector.invoke(function($rootScope, $compile, $document){
 *     $compile($document)($rootScope);
 *     $rootScope.$digest();
 *   });
     * </pre>
     */


    /**
     * @ngdoc overview
     * @name AUTO
     * @description
     *
     * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.
     */

    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    function annotate(fn) {
        var $inject,
            fnText,
            argDecl,
            last;

        if (typeof fn == 'function') {
            if (!($inject = fn.$inject)) {
                $inject = [];
                fnText = fn.toString().replace(STRIP_COMMENTS, '');
                argDecl = fnText.match(FN_ARGS);
                forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){
                    arg.replace(FN_ARG, function(all, underscore, name){
                        $inject.push(name);
                    });
                });
                fn.$inject = $inject;
            }
        } else if (isArray(fn)) {
            last = fn.length - 1;
            assertArgFn(fn[last], 'fn');
            $inject = fn.slice(0, last);
        } else {
            assertArgFn(fn, 'fn', true);
        }
        return $inject;
    }

///////////////////////////////////////

    /**
     * @ngdoc object
     * @name AUTO.$injector
     * @function
     *
     * @description
     *
     * `$injector` is used to retrieve object instances as defined by
     * {@link AUTO.$provide provider}, instantiate types, invoke methods,
     * and load modules.
     *
     * The following always holds true:
     *
     * <pre>
     *   var $injector = angular.injector();
     *   expect($injector.get('$injector')).toBe($injector);
     *   expect($injector.invoke(function($injector){
 *     return $injector;
 *   }).toBe($injector);
     * </pre>
     *
     * # Injection Function Annotation
     *
     * JavaScript does not have annotations, and annotations are needed for dependency injection. The
     * following are all valid ways of annotating function with injection arguments and are equivalent.
     *
     * <pre>
     *   // inferred (only works if code not minified/obfuscated)
     *   $injector.invoke(function(serviceA){});
     *
     *   // annotated
     *   function explicit(serviceA) {};
     *   explicit.$inject = ['serviceA'];
     *   $injector.invoke(explicit);
     *
     *   // inline
     *   $injector.invoke(['serviceA', function(serviceA){}]);
     * </pre>
     *
     * ## Inference
     *
     * In JavaScript calling `toString()` on a function returns the function definition. The definition can then be
     * parsed and the function arguments can be extracted. *NOTE:* This does not work with minification, and obfuscation
     * tools since these tools change the argument names.
     *
     * ## `$inject` Annotation
     * By adding a `$inject` property onto a function the injection parameters can be specified.
     *
     * ## Inline
     * As an array of injection names, where the last item in the array is the function to call.
     */

    /**
     * @ngdoc method
     * @name AUTO.$injector#get
     * @methodOf AUTO.$injector
     *
     * @description
     * Return an instance of the service.
     *
     * @param {string} name The name of the instance to retrieve.
     * @return {*} The instance.
     */

    /**
     * @ngdoc method
     * @name AUTO.$injector#invoke
     * @methodOf AUTO.$injector
     *
     * @description
     * Invoke the method and supply the method arguments from the `$injector`.
     *
     * @param {!function} fn The function to invoke. The function arguments come form the function annotation.
     * @param {Object=} self The `this` for the invoked method.
     * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
     *   the `$injector` is consulted.
     * @returns {*} the value returned by the invoked `fn` function.
     */

    /**
     * @ngdoc method
     * @name AUTO.$injector#has
     * @methodOf AUTO.$injector
     *
     * @description
     * Allows the user to query if the particular service exist.
     *
     * @param {string} Name of the service to query.
     * @returns {boolean} returns true if injector has given service.
     */

    /**
     * @ngdoc method
     * @name AUTO.$injector#instantiate
     * @methodOf AUTO.$injector
     * @description
     * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies
     * all of the arguments to the constructor function as specified by the constructor annotation.
     *
     * @param {function} Type Annotated constructor function.
     * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
     *   the `$injector` is consulted.
     * @returns {Object} new instance of `Type`.
     */

    /**
     * @ngdoc method
     * @name AUTO.$injector#annotate
     * @methodOf AUTO.$injector
     *
     * @description
     * Returns an array of service names which the function is requesting for injection. This API is used by the injector
     * to determine which services need to be injected into the function when the function is invoked. There are three
     * ways in which the function can be annotated with the needed dependencies.
     *
     * # Argument names
     *
     * The simplest form is to extract the dependencies from the arguments of the function. This is done by converting
     * the function into a string using `toString()` method and extracting the argument names.
     * <pre>
     *   // Given
     *   function MyController($scope, $route) {
 *     // ...
 *   }
     *
     *   // Then
     *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
     * </pre>
     *
     * This method does not work with code minfication / obfuscation. For this reason the following annotation strategies
     * are supported.
     *
     * # The `$inject` property
     *
     * If a function has an `$inject` property and its value is an array of strings, then the strings represent names of
     * services to be injected into the function.
     * <pre>
     *   // Given
     *   var MyController = function(obfuscatedScope, obfuscatedRoute) {
 *     // ...
 *   }
     *   // Define function dependencies
     *   MyController.$inject = ['$scope', '$route'];
     *
     *   // Then
     *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
     * </pre>
     *
     * # The array notation
     *
     * It is often desirable to inline Injected functions and that's when setting the `$inject` property is very
     * inconvenient. In these situations using the array notation to specify the dependencies in a way that survives
     * minification is a better choice:
     *
     * <pre>
     *   // We wish to write this (not minification / obfuscation safe)
     *   injector.invoke(function($compile, $rootScope) {
 *     // ...
 *   });
     *
     *   // We are forced to write break inlining
     *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
 *     // ...
 *   };
     *   tmpFn.$inject = ['$compile', '$rootScope'];
     *   injector.invoke(tmpFn);
     *
     *   // To better support inline function the inline annotation is supported
     *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {
 *     // ...
 *   }]);
     *
     *   // Therefore
     *   expect(injector.annotate(
     *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])
     *    ).toEqual(['$compile', '$rootScope']);
     * </pre>
     *
     * @param {function|Array.<string|Function>} fn Function for which dependent service names need to be retrieved as described
     *   above.
     *
     * @returns {Array.<string>} The names of the services which the function requires.
     */




    /**
     * @ngdoc object
     * @name AUTO.$provide
     *
     * @description
     *
     * Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.
     * The providers share the same name as the instance they create with `Provider` suffixed to them.
     *
     * A provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of
     * a service. The Provider can have additional methods which would allow for configuration of the provider.
     *
     * <pre>
     *   function GreetProvider() {
 *     var salutation = 'Hello';
 *
 *     this.salutation = function(text) {
 *       salutation = text;
 *     };
 *
 *     this.$get = function() {
 *       return function (name) {
 *         return salutation + ' ' + name + '!';
 *       };
 *     };
 *   }
     *
     *   describe('Greeter', function(){
 *
 *     beforeEach(module(function($provide) {
 *       $provide.provider('greet', GreetProvider);
 *     }));
 *
 *     it('should greet', inject(function(greet) {
 *       expect(greet('angular')).toEqual('Hello angular!');
 *     }));
 *
 *     it('should allow configuration of salutation', function() {
 *       module(function(greetProvider) {
 *         greetProvider.salutation('Ahoj');
 *       });
 *       inject(function(greet) {
 *         expect(greet('angular')).toEqual('Ahoj angular!');
 *       });
 *     });
 * </pre>
 */

    /**
     * @ngdoc method
     * @name AUTO.$provide#provider
     * @methodOf AUTO.$provide
     * @description
     *
     * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.
     *
     * @param {string} name The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.
     * @param {(Object|function())} provider If the provider is:
     *
     *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using
     *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.
     *   - `Constructor`: a new instance of the provider will be created using
     *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.
     *
     * @returns {Object} registered provider instance
     */

    /**
     * @ngdoc method
     * @name AUTO.$provide#factory
     * @methodOf AUTO.$provide
     * @description
     *
     * A short hand for configuring services if only `$get` method is required.
     *
     * @param {string} name The name of the instance.
     * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for
     * `$provide.provider(name, {$get: $getFn})`.
     * @returns {Object} registered provider instance
     */


    /**
     * @ngdoc method
     * @name AUTO.$provide#service
     * @methodOf AUTO.$provide
     * @description
     *
     * A short hand for registering service of given class.
     *
     * @param {string} name The name of the instance.
     * @param {Function} constructor A class (constructor function) that will be instantiated.
     * @returns {Object} registered provider instance
     */


    /**
     * @ngdoc method
     * @name AUTO.$provide#value
     * @methodOf AUTO.$provide
     * @description
     *
     * A short hand for configuring services if the `$get` method is a constant.
     *
     * @param {string} name The name of the instance.
     * @param {*} value The value.
     * @returns {Object} registered provider instance
     */


    /**
     * @ngdoc method
     * @name AUTO.$provide#constant
     * @methodOf AUTO.$provide
     * @description
     *
     * A constant value, but unlike {@link AUTO.$provide#value value} it can be injected
     * into configuration function (other modules) and it is not interceptable by
     * {@link AUTO.$provide#decorator decorator}.
     *
     * @param {string} name The name of the constant.
     * @param {*} value The constant value.
     * @returns {Object} registered instance
     */


    /**
     * @ngdoc method
     * @name AUTO.$provide#decorator
     * @methodOf AUTO.$provide
     * @description
     *
     * Decoration of service, allows the decorator to intercept the service instance creation. The
     * returned instance may be the original instance, or a new instance which delegates to the
     * original instance.
     *
     * @param {string} name The name of the service to decorate.
     * @param {function()} decorator This function will be invoked when the service needs to be
     *    instantiated. The function is called using the {@link AUTO.$injector#invoke
     *    injector.invoke} method and is therefore fully injectable. Local injection arguments:
     *
     *    * `$delegate` - The original service instance, which can be monkey patched, configured,
     *      decorated or delegated to.
     */


    function createInjector(modulesToLoad) {
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap(),
            providerCache = {
                $provide: {
                    provider: supportObject(provider),
                    factory: supportObject(factory),
                    service: supportObject(service),
                    value: supportObject(value),
                    constant: supportObject(constant),
                    decorator: decorator
                }
            },
            providerInjector = (providerCache.$injector =
                createInternalInjector(providerCache, function() {
                    throw Error("Unknown provider: " + path.join(' <- '));
                })),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector =
                createInternalInjector(instanceCache, function(servicename) {
                    var provider = providerInjector.get(servicename + providerSuffix);
                    return instanceInjector.invoke(provider.$get, provider);
                }));


        forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });

        return instanceInjector;

        ////////////////////////////////////
        // $provider
        ////////////////////////////////////

        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            }
        }

        function provider(name, provider_) {
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw Error('Provider ' + name + ' must define $get factory method.');
            }
            return providerCache[name + providerSuffix] = provider_;
        }

        function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }

        function service(name, constructor) {
            return factory(name, ['$injector', function($injector) {
                return $injector.instantiate(constructor);
            }]);
        }

        function value(name, value) { return factory(name, valueFn(value)); }

        function constant(name, value) {
            providerCache[name] = value;
            instanceCache[name] = value;
        }

        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix),
                orig$get = origProvider.$get;

            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
            };
        }

        ////////////////////////////////////
        // Module Loading
        ////////////////////////////////////
        function loadModules(modulesToLoad){
            var runBlocks = [];
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.put(module, true);
                if (isString(module)) {
                    var moduleFn = angularModule(module);
                    runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

                    try {
                        for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
                            var invokeArgs = invokeQueue[i],
                                provider = providerInjector.get(invokeArgs[0]);

                            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                        }
                    } catch (e) {
                        if (e.message) e.message += ' from ' + module;
                        throw e;
                    }
                } else if (isFunction(module)) {
                    try {
                        runBlocks.push(providerInjector.invoke(module));
                    } catch (e) {
                        if (e.message) e.message += ' from ' + module;
                        throw e;
                    }
                } else if (isArray(module)) {
                    try {
                        runBlocks.push(providerInjector.invoke(module));
                    } catch (e) {
                        if (e.message) e.message += ' from ' + String(module[module.length - 1]);
                        throw e;
                    }
                } else {
                    assertArgFn(module, 'module');
                }
            });
            return runBlocks;
        }

        ////////////////////////////////////
        // internal Injector
        ////////////////////////////////////

        function createInternalInjector(cache, factory) {

            function getService(serviceName) {
                if (typeof serviceName !== 'string') {
                    throw Error('Service name expected');
                }
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw Error('Circular dependency: ' + path.join(' <- '));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        return cache[serviceName] = factory(serviceName);
                    } finally {
                        path.shift();
                    }
                }
            }

            function invoke(fn, self, locals){
                var args = [],
                    $inject = annotate(fn),
                    length, i,
                    key;

                for(i = 0, length = $inject.length; i < length; i++) {
                    key = $inject[i];
                    args.push(
                        locals && locals.hasOwnProperty(key)
                            ? locals[key]
                            : getService(key)
                    );
                }
                if (!fn.$inject) {
                    // this means that we must be an array.
                    fn = fn[length];
                }


                // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke
                switch (self ? -1 : args.length) {
                    case  0: return fn();
                    case  1: return fn(args[0]);
                    case  2: return fn(args[0], args[1]);
                    case  3: return fn(args[0], args[1], args[2]);
                    case  4: return fn(args[0], args[1], args[2], args[3]);
                    case  5: return fn(args[0], args[1], args[2], args[3], args[4]);
                    case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                    case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
                    case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
                    case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
                    default: return fn.apply(self, args);
                }
            }

            function instantiate(Type, locals) {
                var Constructor = function() {},
                    instance, returnedValue;

                // Check if Type is annotated and use just the given function at n-1 as parameter
                // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
                Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
                instance = new Constructor();
                returnedValue = invoke(Type, instance, locals);

                return isObject(returnedValue) ? returnedValue : instance;
            }

            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }

    /**
     * @ngdoc function
     * @name ng.$anchorScroll
     * @requires $window
     * @requires $location
     * @requires $rootScope
     *
     * @description
     * When called, it checks current value of `$location.hash()` and scroll to related element,
     * according to rules specified in
     * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.
     *
     * It also watches the `$location.hash()` and scroll whenever it changes to match any anchor.
     * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.
     */
    function $AnchorScrollProvider() {

        var autoScrollingEnabled = true;

        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };

        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
            var document = $window.document;

            // helper function to get first anchor from a NodeList
            // can't use filter.filter, as it accepts only instances of Array
            // and IE can't convert NodeList to an array using [].slice
            // TODO(vojta): use filter if we change it to accept lists as well
            function getFirstAnchor(list) {
                var result = null;
                forEach(list, function(element) {
                    if (!result && lowercase(element.nodeName) === 'a') result = element;
                });
                return result;
            }

            function scroll() {
                var hash = $location.hash(), elm;

                // empty hash, scroll to the top of the page
                if (!hash) $window.scrollTo(0, 0);

                // element with given id
                else if ((elm = document.getElementById(hash))) elm.scrollIntoView();

                // first anchor with given name :-D
                else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();

                // no element and hash == 'top', scroll to the top of the page
                else if (hash === 'top') $window.scrollTo(0, 0);
            }

            // does not scroll when user clicks on anchor link that is currently on
            // (no url change, no $location.hash() change), browser native does scroll
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
                    function autoScrollWatchAction() {
                        $rootScope.$evalAsync(scroll);
                    });
            }

            return scroll;
        }];
    }


    /**
     * @ngdoc object
     * @name ng.$animationProvider
     * @description
     *
     * The $AnimationProvider provider allows developers to register and access custom JavaScript animations directly inside
     * of a module.
     *
     */
    $AnimationProvider.$inject = ['$provide'];
    function $AnimationProvider($provide) {
        var suffix = 'Animation';

        /**
         * @ngdoc function
         * @name ng.$animation#register
         * @methodOf ng.$animationProvider
         *
         * @description
         * Registers a new injectable animation factory function. The factory function produces the animation object which
         * has these two properties:
         *
         *   * `setup`: `function(Element):*` A function which receives the starting state of the element. The purpose
         *   of this function is to get the element ready for animation. Optionally the function returns an memento which
         *   is passed to the `start` function.
         *   * `start`: `function(Element, doneFunction, *)` The element to animate, the `doneFunction` to be called on
         *   element animation completion, and an optional memento from the `setup` function.
         *
         * @param {string} name The name of the animation.
         * @param {function} factory The factory function that will be executed to return the animation object.
         *
         */
        this.register = function(name, factory) {
            $provide.factory(camelCase(name) + suffix, factory);
        };

        this.$get = ['$injector', function($injector) {
            /**
             * @ngdoc function
             * @name ng.$animation
             * @function
             *
             * @description
             * The $animation service is used to retrieve any defined animation functions. When executed, the $animation service
             * will return a object that contains the setup and start functions that were defined for the animation.
             *
             * @param {String} name Name of the animation function to retrieve. Animation functions are registered and stored
             *        inside of the AngularJS DI so a call to $animate('custom') is the same as injecting `customAnimation`
             *        via dependency injection.
             * @return {Object} the animation object which contains the `setup` and `start` functions that perform the animation.
             */
            return function $animation(name) {
                if (name) {
                    var animationName = camelCase(name) + suffix;
                    if ($injector.has(animationName)) {
                        return $injector.get(animationName);
                    }
                }
            };
        }];
    }

// NOTE: this is a pseudo directive.

    /**
     * @ngdoc directive
     * @name ng.directive:ngAnimate
     *
     * @description
     * The `ngAnimate` directive works as an attribute that is attached alongside pre-existing directives.
     * It effects how the directive will perform DOM manipulation. This allows for complex animations to take place
     * without burdening the directive which uses the animation with animation details. The built in directives
     * `ngRepeat`, `ngInclude`, `ngSwitch`, `ngShow`, `ngHide` and `ngView` already accept `ngAnimate` directive.
     * Custom directives can take advantage of animation through {@link ng.$animator $animator service}.
     *
     * Below is a more detailed breakdown of the supported callback events provided by pre-exisitng ng directives:
     *
     * | Directive                                                 | Supported Animations                               |
     * |========================================================== |====================================================|
     * | {@link ng.directive:ngRepeat#animations ngRepeat}         | enter, leave and move                              |
     * | {@link ng.directive:ngView#animations ngView}             | enter and leave                                    |
     * | {@link ng.directive:ngInclude#animations ngInclude}       | enter and leave                                    |
     * | {@link ng.directive:ngSwitch#animations ngSwitch}         | enter and leave                                    |
     * | {@link ng.directive:ngIf#animations ngIf}                 | enter and leave                                    |
     * | {@link ng.directive:ngShow#animations ngShow & ngHide}    | show and hide                                      |
     *
     * You can find out more information about animations upon visiting each directive page.
     *
     * Below is an example of a directive that makes use of the ngAnimate attribute:
     *
     * <pre>
     * <!-- you can also use data-ng-animate, ng:animate or x-ng-animate as well -->
     * <ANY ng-directive ng-animate="{event1: 'animation-name', event2: 'animation-name-2'}"></ANY>
     *
     * <!-- you can also use a short hand -->
     * <ANY ng-directive ng-animate=" 'animation' "></ANY>
     * <!-- which expands to -->
     * <ANY ng-directive ng-animate="{ enter: 'animation-enter', leave: 'animation-leave', ...}"></ANY>
     *
     * <!-- keep in mind that ng-animate can take expressions -->
     * <ANY ng-directive ng-animate=" computeCurrentAnimation() "></ANY>
     * </pre>
     *
     * The `event1` and `event2` attributes refer to the animation events specific to the directive that has been assigned.
     *
     * Keep in mind that if an animation is running, no child element of such animation can also be animated.
     *
     * <h2>CSS-defined Animations</h2>
     * By default, ngAnimate attaches two CSS classes per animation event to the DOM element to achieve the animation.
     * It is up to you, the developer, to ensure that the animations take place using cross-browser CSS3 transitions as
     * well as CSS animations.
     *
     * The following code below demonstrates how to perform animations using **CSS transitions** with ngAnimate:
     *
     * <pre>
     * <style type="text/css">
     * /&#42;
     *  The animate-enter CSS class is the event name that you
     *  have provided within the ngAnimate attribute.
     * &#42;/
     * .animate-enter {
 *  -webkit-transition: 1s linear all; /&#42; Safari/Chrome &#42;/
 *  -moz-transition: 1s linear all; /&#42; Firefox &#42;/
 *  -o-transition: 1s linear all; /&#42; Opera &#42;/
 *  transition: 1s linear all; /&#42; IE10+ and Future Browsers &#42;/
 *
 *  /&#42; The animation preparation code &#42;/
 *  opacity: 0;
 * }
     *
     * /&#42;
     *  Keep in mind that you want to combine both CSS
     *  classes together to avoid any CSS-specificity
     *  conflicts
     * &#42;/
     * .animate-enter.animate-enter-active {
 *  /&#42; The animation code itself &#42;/
 *  opacity: 1;
 * }
     * </style>
     *
     * <div ng-directive ng-animate="{enter: 'animate-enter'}"></div>
     * </pre>
     *
     * The following code below demonstrates how to perform animations using **CSS animations** with ngAnimate:
     *
     * <pre>
     * <style type="text/css">
     * .animate-enter {
 *   -webkit-animation: enter_sequence 1s linear; /&#42; Safari/Chrome &#42;/
 *   -moz-animation: enter_sequence 1s linear; /&#42; Firefox &#42;/
 *   -o-animation: enter_sequence 1s linear; /&#42; Opera &#42;/
 *   animation: enter_sequence 1s linear; /&#42; IE10+ and Future Browsers &#42;/
 * }
     * &#64-webkit-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
     * &#64-moz-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
     * &#64-o-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
     * &#64keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
     * </style>
     *
     * <div ng-directive ng-animate="{enter: 'animate-enter'}"></div>
     * </pre>
     *
     * ngAnimate will first examine any CSS animation code and then fallback to using CSS transitions.
     *
     * Upon DOM mutation, the event class is added first, then the browser is allowed to reflow the content and then,
     * the active class is added to trigger the animation. The ngAnimate directive will automatically extract the duration
     * of the animation to determine when the animation ends. Once the animation is over then both CSS classes will be
     * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end
     * immediately resulting in a DOM element that is at it's final state. This final state is when the DOM element
     * has no CSS transition/animation classes surrounding it.
     *
     * <h2>JavaScript-defined Animations</h2>
     * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations to browsers that do not
     * yet support them, then you can make use of JavaScript animations defined inside of your AngularJS module.
     *
     * <pre>
     * var ngModule = angular.module('YourApp', []);
     * ngModule.animation('animate-enter', function() {
 *   return {
 *     setup : function(element) {
 *       //prepare the element for animation
 *       element.css({ 'opacity': 0 });
 *       var memo = "..."; //this value is passed to the start function
 *       return memo;
 *     },
 *     start : function(element, done, memo) {
 *       //start the animation
 *       element.animate({
 *         'opacity' : 1
 *       }, function() {
 *         //call when the animation is complete
 *         done()
 *       });
 *     }
 *   }
 * });
     * </pre>
     *
     * As you can see, the JavaScript code follows a similar template to the CSS3 animations. Once defined, the animation
     * can be used in the same way with the ngAnimate attribute. Keep in mind that, when using JavaScript-enabled
     * animations, ngAnimate will also add in the same CSS classes that CSS-enabled animations do (even if you're not using
     * CSS animations) to animated the element, but it will not attempt to find any CSS3 transition or animation duration/delay values.
     * It will instead close off the animation once the provided done function is executed. So it's important that you
     * make sure your animations remember to fire off the done function once the animations are complete.
     *
     * @param {expression} ngAnimate Used to configure the DOM manipulation animations.
     *
     */

    var $AnimatorProvider = function() {
        var NG_ANIMATE_CONTROLLER = '$ngAnimateController';
        var rootAnimateController = {running:true};

        this.$get = ['$animation', '$window', '$sniffer', '$rootElement', '$rootScope',
            function($animation, $window, $sniffer, $rootElement, $rootScope) {
                $rootElement.data(NG_ANIMATE_CONTROLLER, rootAnimateController);

                /**
                 * @ngdoc function
                 * @name ng.$animator
                 * @function
                 *
                 * @description
                 * The $animator.create service provides the DOM manipulation API which is decorated with animations.
                 *
                 * @param {Scope} scope the scope for the ng-animate.
                 * @param {Attributes} attr the attributes object which contains the ngAnimate key / value pair. (The attributes are
                 *        passed into the linking function of the directive using the `$animator`.)
                 * @return {object} the animator object which contains the enter, leave, move, show, hide and animate methods.
                 */
                var AnimatorService = function(scope, attrs) {
                    var animator = {};

                    /**
                     * @ngdoc function
                     * @name ng.animator#enter
                     * @methodOf ng.$animator
                     * @function
                     *
                     * @description
                     * Injects the element object into the DOM (inside of the parent element) and then runs the enter animation.
                     *
                     * @param {jQuery/jqLite element} element the element that will be the focus of the enter animation
                     * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the enter animation
                     * @param {jQuery/jqLite element} after the sibling element (which is the previous element) of the element that will be the focus of the enter animation
                     */
                    animator.enter = animateActionFactory('enter', insert, noop);

                    /**
                     * @ngdoc function
                     * @name ng.animator#leave
                     * @methodOf ng.$animator
                     * @function
                     *
                     * @description
                     * Runs the leave animation operation and, upon completion, removes the element from the DOM.
                     *
                     * @param {jQuery/jqLite element} element the element that will be the focus of the leave animation
                     * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the leave animation
                     */
                    animator.leave = animateActionFactory('leave', noop, remove);

                    /**
                     * @ngdoc function
                     * @name ng.animator#move
                     * @methodOf ng.$animator
                     * @function
                     *
                     * @description
                     * Fires the move DOM operation. Just before the animation starts, the animator will either append it into the parent container or
                     * add the element directly after the after element if present. Then the move animation will be run.
                     *
                     * @param {jQuery/jqLite element} element the element that will be the focus of the move animation
                     * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the move animation
                     * @param {jQuery/jqLite element} after the sibling element (which is the previous element) of the element that will be the focus of the move animation
                     */
                    animator.move = animateActionFactory('move', move, noop);

                    /**
                     * @ngdoc function
                     * @name ng.animator#show
                     * @methodOf ng.$animator
                     * @function
                     *
                     * @description
                     * Reveals the element by setting the CSS property `display` to `block` and then starts the show animation directly after.
                     *
                     * @param {jQuery/jqLite element} element the element that will be rendered visible or hidden
                     */
                    animator.show = animateActionFactory('show', show, noop);

                    /**
                     * @ngdoc function
                     * @name ng.animator#hide
                     * @methodOf ng.$animator
                     *
                     * @description
                     * Starts the hide animation first and sets the CSS `display` property to `none` upon completion.
                     *
                     * @param {jQuery/jqLite element} element the element that will be rendered visible or hidden
                     */
                    animator.hide = animateActionFactory('hide', noop, hide);

                    /**
                     * @ngdoc function
                     * @name ng.animator#animate
                     * @methodOf ng.$animator
                     *
                     * @description
                     * Triggers a custom animation event to be executed on the given element
                     *
                     * @param {jQuery/jqLite element} element that will be animated
                     */
                    animator.animate = function(event, element) {
                        animateActionFactory(event, noop, noop)(element);
                    }
                    return animator;

                    function animateActionFactory(type, beforeFn, afterFn) {
                        return function(element, parent, after) {
                            var ngAnimateValue = scope.$eval(attrs.ngAnimate);
                            var className = ngAnimateValue
                                ? isObject(ngAnimateValue) ? ngAnimateValue[type] : ngAnimateValue + '-' + type
                                : '';
                            var animationPolyfill = $animation(className);
                            var polyfillSetup = animationPolyfill && animationPolyfill.setup;
                            var polyfillStart = animationPolyfill && animationPolyfill.start;
                            var polyfillCancel = animationPolyfill && animationPolyfill.cancel;

                            if (!className) {
                                beforeFn(element, parent, after);
                                afterFn(element, parent, after);
                            } else {
                                var activeClassName = className + '-active';

                                if (!parent) {
                                    parent = after ? after.parent() : element.parent();
                                }
                                if ((!$sniffer.transitions && !polyfillSetup && !polyfillStart) ||
                                    (parent.inheritedData(NG_ANIMATE_CONTROLLER) || noop).running) {
                                    beforeFn(element, parent, after);
                                    afterFn(element, parent, after);
                                    return;
                                }

                                var animationData = element.data(NG_ANIMATE_CONTROLLER) || {};
                                if(animationData.running) {
                                    (polyfillCancel || noop)(element);
                                    animationData.done();
                                }

                                element.data(NG_ANIMATE_CONTROLLER, {running:true, done:done});
                                element.addClass(className);
                                beforeFn(element, parent, after);
                                if (element.length == 0) return done();

                                var memento = (polyfillSetup || noop)(element);

                                // $window.setTimeout(beginAnimation, 0); this was causing the element not to animate
                                // keep at 1 for animation dom rerender
                                $window.setTimeout(beginAnimation, 1);
                            }

                            function parseMaxTime(str) {
                                var total = 0, values = isString(str) ? str.split(/\s*,\s*/) : [];
                                forEach(values, function(value) {
                                    total = Math.max(parseFloat(value) || 0, total);
                                });
                                return total;
                            }

                            function beginAnimation() {
                                element.addClass(activeClassName);
                                if (polyfillStart) {
                                    polyfillStart(element, done, memento);
                                } else if (isFunction($window.getComputedStyle)) {
                                    //one day all browsers will have these properties
                                    var w3cAnimationProp = 'animation';
                                    var w3cTransitionProp = 'transition';

                                    //but some still use vendor-prefixed styles 
                                    var vendorAnimationProp = $sniffer.vendorPrefix + 'Animation';
                                    var vendorTransitionProp = $sniffer.vendorPrefix + 'Transition';

                                    var durationKey = 'Duration',
                                        delayKey = 'Delay',
                                        animationIterationCountKey = 'IterationCount',
                                        duration = 0;

                                    //we want all the styles defined before and after
                                    var ELEMENT_NODE = 1;
                                    forEach(element, function(element) {
                                        if (element.nodeType == ELEMENT_NODE) {
                                            var w3cProp = w3cTransitionProp,
                                                vendorProp = vendorTransitionProp,
                                                iterations = 1,
                                                elementStyles = $window.getComputedStyle(element) || {};

                                            //use CSS Animations over CSS Transitions
                                            if(parseFloat(elementStyles[w3cAnimationProp + durationKey]) > 0 ||
                                                parseFloat(elementStyles[vendorAnimationProp + durationKey]) > 0) {
                                                w3cProp = w3cAnimationProp;
                                                vendorProp = vendorAnimationProp;
                                                iterations = Math.max(parseInt(elementStyles[w3cProp    + animationIterationCountKey]) || 0,
                                                    parseInt(elementStyles[vendorProp + animationIterationCountKey]) || 0,
                                                    iterations);
                                            }

                                            var parsedDelay     = Math.max(parseMaxTime(elementStyles[w3cProp     + delayKey]),
                                                parseMaxTime(elementStyles[vendorProp  + delayKey]));

                                            var parsedDuration  = Math.max(parseMaxTime(elementStyles[w3cProp     + durationKey]),
                                                parseMaxTime(elementStyles[vendorProp  + durationKey]));

                                            duration = Math.max(parsedDelay + (iterations * parsedDuration), duration);
                                        }
                                    });
                                    $window.setTimeout(done, duration * 1000);
                                } else {
                                    done();
                                }
                            }

                            function done() {
                                if(!done.run) {
                                    done.run = true;
                                    afterFn(element, parent, after);
                                    element.removeClass(className);
                                    element.removeClass(activeClassName);
                                    element.removeData(NG_ANIMATE_CONTROLLER);
                                }
                            }
                        };
                    }

                    function show(element) {
                        element.css('display', '');
                    }

                    function hide(element) {
                        element.css('display', 'none');
                    }

                    function insert(element, parent, after) {
                        if (after) {
                            after.after(element);
                        } else {
                            parent.append(element);
                        }
                    }

                    function remove(element) {
                        element.remove();
                    }

                    function move(element, parent, after) {
                        // Do not remove element before insert. Removing will cause data associated with the
                        // element to be dropped. Insert will implicitly do the remove.
                        insert(element, parent, after);
                    }
                };

                /**
                 * @ngdoc function
                 * @name ng.animator#enabled
                 * @methodOf ng.$animator
                 * @function
                 *
                 * @param {Boolean=} If provided then set the animation on or off.
                 * @return {Boolean} Current animation state.
                 *
                 * @description
                 * Globally enables/disables animations.
                 *
                 */
                AnimatorService.enabled = function(value) {
                    if (arguments.length) {
                        rootAnimateController.running = !value;
                    }
                    return !rootAnimateController.running;
                };

                return AnimatorService;
            }];
    };

    /**
     * ! This is a private undocumented service !
     *
     * @name ng.$browser
     * @requires $log
     * @description
     * This object has two goals:
     *
     * - hide all the global state in the browser caused by the window object
     * - abstract away all the browser specific features and inconsistencies
     *
     * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`
     * service, which can be used for convenient testing of the application without the interaction with
     * the real browser apis.
     */
    /**
     * @param {object} window The global window object.
     * @param {object} document jQuery wrapped document.
     * @param {function()} XHR XMLHttpRequest constructor.
     * @param {object} $log console.log or an object with the same interface.
     * @param {object} $sniffer $sniffer service
     */
    function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};

        self.isMock = false;

        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];

        // TODO(vojta): remove this temporary api
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };

        /**
         * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`
         * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.
         */
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                outstandingRequestCount--;
                if (outstandingRequestCount === 0) {
                    while(outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()();
                        } catch (e) {
                            $log.error(e);
                        }
                    }
                }
            }
        }

        /**
         * @private
         * Note: this method is used only by scenario runner
         * TODO(vojta): prefix this method with $$ ?
         * @param {function()} callback Function that will be called when no outstanding request
         */
        self.notifyWhenNoOutstandingRequests = function(callback) {
            // force browser to execute all pollFns - this is needed so that cookies and other pollers fire
            // at some deterministic time in respect to the test runner's actions. Leaving things up to the
            // regular poller would result in flaky tests.
            forEach(pollFns, function(pollFn){ pollFn(); });

            if (outstandingRequestCount === 0) {
                callback();
            } else {
                outstandingRequestCallbacks.push(callback);
            }
        };

        //////////////////////////////////////////////////////////////
        // Poll Watcher API
        //////////////////////////////////////////////////////////////
        var pollFns = [],
            pollTimeout;

        /**
         * @name ng.$browser#addPollFn
         * @methodOf ng.$browser
         *
         * @param {function()} fn Poll function to add
         *
         * @description
         * Adds a function to the list of functions that poller periodically executes,
         * and starts polling if not started yet.
         *
         * @returns {function()} the added function
         */
        self.addPollFn = function(fn) {
            if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
            pollFns.push(fn);
            return fn;
        };

        /**
         * @param {number} interval How often should browser call poll functions (ms)
         * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.
         *
         * @description
         * Configures the poller to run in the specified intervals, using the specified
         * setTimeout fn and kicks it off.
         */
        function startPoller(interval, setTimeout) {
            (function check() {
                forEach(pollFns, function(pollFn){ pollFn(); });
                pollTimeout = setTimeout(check, interval);
            })();
        }

        //////////////////////////////////////////////////////////////
        // URL API
        //////////////////////////////////////////////////////////////

        var lastBrowserUrl = location.href,
            baseElement = document.find('base');

        /**
         * @name ng.$browser#url
         * @methodOf ng.$browser
         *
         * @description
         * GETTER:
         * Without any argument, this method just returns current value of location.href.
         *
         * SETTER:
         * With at least one argument, this method sets url to new value.
         * If html5 history api supported, pushState/replaceState is used, otherwise
         * location.href/location.replace is used.
         * Returns its own instance to allow chaining
         *
         * NOTE: this api is intended for use only by the $location service. Please use the
         * {@link ng.$location $location service} to change url.
         *
         * @param {string} url New url (when used as setter)
         * @param {boolean=} replace Should new url replace current history record ?
         */
        self.url = function(url, replace) {
            // setter
            if (url) {
                if (lastBrowserUrl == url) return;
                lastBrowserUrl = url;
                if ($sniffer.history) {
                    if (replace) history.replaceState(null, '', url);
                    else {
                        history.pushState(null, '', url);
                        // Crazy Opera Bug: http://my.opera.com/community/forums/topic.dml?id=1185462
                        baseElement.attr('href', baseElement.attr('href'));
                    }
                } else {
                    if (replace) location.replace(url);
                    else location.href = url;
                }
                return self;
                // getter
            } else {
                // the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
                return location.href.replace(/%27/g,"'");
            }
        };

        var urlChangeListeners = [],
            urlChangeInit = false;

        function fireUrlChange() {
            if (lastBrowserUrl == self.url()) return;

            lastBrowserUrl = self.url();
            forEach(urlChangeListeners, function(listener) {
                listener(self.url());
            });
        }

        /**
         * @name ng.$browser#onUrlChange
         * @methodOf ng.$browser
         * @TODO(vojta): refactor to use node's syntax for events
         *
         * @description
         * Register callback function that will be called, when url changes.
         *
         * It's only called when the url is changed by outside of angular:
         * - user types different url into address bar
         * - user clicks on history (forward/back) button
         * - user clicks on a link
         *
         * It's not called when url is changed by $browser.url() method
         *
         * The listener gets called with new url as parameter.
         *
         * NOTE: this api is intended for use only by the $location service. Please use the
         * {@link ng.$location $location service} to monitor url changes in angular apps.
         *
         * @param {function(string)} listener Listener function to be called when url changes.
         * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
         */
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
                // don't fire popstate when user change the address bar and don't fire hashchange when url
                // changed by push/replaceState

                // html5 history api - popstate event
                if ($sniffer.history) jqLite(window).bind('popstate', fireUrlChange);
                // hashchange event
                if ($sniffer.hashchange) jqLite(window).bind('hashchange', fireUrlChange);
                // polling
                else self.addPollFn(fireUrlChange);

                urlChangeInit = true;
            }

            urlChangeListeners.push(callback);
            return callback;
        };

        //////////////////////////////////////////////////////////////
        // Misc API
        //////////////////////////////////////////////////////////////

        /**
         * Returns current <base href>
         * (always relative - without domain)
         *
         * @returns {string=}
         */
        self.baseHref = function() {
            var href = baseElement.attr('href');
            return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
        };

        //////////////////////////////////////////////////////////////
        // Cookies API
        //////////////////////////////////////////////////////////////
        var lastCookies = {};
        var lastCookieString = '';
        var cookiePath = self.baseHref();

        /**
         * @name ng.$browser#cookies
         * @methodOf ng.$browser
         *
         * @param {string=} name Cookie name
         * @param {string=} value Cookie value
         *
         * @description
         * The cookies method provides a 'private' low level access to browser cookies.
         * It is not meant to be used directly, use the $cookie service instead.
         *
         * The return values vary depending on the arguments that the method was called with as follows:
         * <ul>
         *   <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>
         *   <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>
         *   <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>
         * </ul>
         *
         * @returns {Object} Hash of all cookies (if called without any parameter)
         */
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;

            if (name) {
                if (value === undefined) {
                    rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
                } else {
                    if (isString(value)) {
                        cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;

                        // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
                        // - 300 cookies
                        // - 20 cookies per unique domain
                        // - 4096 bytes per cookie
                        if (cookieLength > 4096) {
                            $log.warn("Cookie '"+ name +"' possibly not set or overflowed because it was too large ("+
                                cookieLength + " > 4096 bytes)!");
                        }
                    }
                }
            } else {
                if (rawDocument.cookie !== lastCookieString) {
                    lastCookieString = rawDocument.cookie;
                    cookieArray = lastCookieString.split("; ");
                    lastCookies = {};

                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf('=');
                        if (index > 0) { //ignore nameless cookies
                            var name = unescape(cookie.substring(0, index));
                            // the first value that is seen for a cookie is the most
                            // specific one.  values for the same cookie name that
                            // follow are for less specific paths.
                            if (lastCookies[name] === undefined) {
                                lastCookies[name] = unescape(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            }
        };


        /**
         * @name ng.$browser#defer
         * @methodOf ng.$browser
         * @param {function()} fn A function, who's execution should be defered.
         * @param {number=} [delay=0] of milliseconds to defer the function execution.
         * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
         *
         * @description
         * Executes a fn asynchronously via `setTimeout(fn, delay)`.
         *
         * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using
         * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed
         * via `$browser.defer.flush()`.
         *
         */
        self.defer = function(fn, delay) {
            var timeoutId;
            outstandingRequestCount++;
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                completeOutstandingRequest(fn);
            }, delay || 0);
            pendingDeferIds[timeoutId] = true;
            return timeoutId;
        };


        /**
         * @name ng.$browser#defer.cancel
         * @methodOf ng.$browser.defer
         *
         * @description
         * Cancels a defered task identified with `deferId`.
         *
         * @param {*} deferId Token returned by the `$browser.defer` function.
         * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully canceled.
         */
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                completeOutstandingRequest(noop);
                return true;
            }
            return false;
        };

    }

    function $BrowserProvider(){
        this.$get = ['$window', '$log', '$sniffer', '$document',
            function( $window,   $log,   $sniffer,   $document){
                return new Browser($window, $document, $log, $sniffer);
            }];
    }

    /**
     * @ngdoc object
     * @name ng.$cacheFactory
     *
     * @description
     * Factory that constructs cache objects.
     *
     *
     * @param {string} cacheId Name or id of the newly created cache.
     * @param {object=} options Options object that specifies the cache behavior. Properties:
     *
     *   - `{number=}` `capacity` â€” turns the cache into LRU cache.
     *
     * @returns {object} Newly created cache object with the following set of methods:
     *
     * - `{object}` `info()` â€” Returns id, size, and options of cache.
     * - `{{*}}` `put({string} key, {*} value)` â€” Puts a new key-value pair into the cache and returns it.
     * - `{{*}}` `get({string} key)` â€” Returns cached value for `key` or undefined for cache miss.
     * - `{void}` `remove({string} key)` â€” Removes a key-value pair from the cache.
     * - `{void}` `removeAll()` â€” Removes all cached values.
     * - `{void}` `destroy()` â€” Removes references to this cache from $cacheFactory.
     *
     */
    function $CacheFactoryProvider() {

        this.$get = function() {
            var caches = {};

            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw Error('cacheId ' + cacheId + ' taken');
                }

                var size = 0,
                    stats = extend({}, options, {id: cacheId}),
                    data = {},
                    capacity = (options && options.capacity) || Number.MAX_VALUE,
                    lruHash = {},
                    freshEnd = null,
                    staleEnd = null;

                return caches[cacheId] = {

                    put: function(key, value) {
                        var lruEntry = lruHash[key] || (lruHash[key] = {key: key});

                        refresh(lruEntry);

                        if (isUndefined(value)) return;
                        if (!(key in data)) size++;
                        data[key] = value;

                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }

                        return value;
                    },


                    get: function(key) {
                        var lruEntry = lruHash[key];

                        if (!lruEntry) return;

                        refresh(lruEntry);

                        return data[key];
                    },


                    remove: function(key) {
                        var lruEntry = lruHash[key];

                        if (!lruEntry) return;

                        if (lruEntry == freshEnd) freshEnd = lruEntry.p;
                        if (lruEntry == staleEnd) staleEnd = lruEntry.n;
                        link(lruEntry.n,lruEntry.p);

                        delete lruHash[key];
                        delete data[key];
                        size--;
                    },


                    removeAll: function() {
                        data = {};
                        size = 0;
                        lruHash = {};
                        freshEnd = staleEnd = null;
                    },


                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },


                    info: function() {
                        return extend({}, stats, {size: size});
                    }
                };


                /**
                 * makes the `entry` the freshEnd of the LRU linked list
                 */
                function refresh(entry) {
                    if (entry != freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd == entry) {
                            staleEnd = entry.n;
                        }

                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }


                /**
                 * bidirectionally links two entries of the LRU linked list
                 */
                function link(nextEntry, prevEntry) {
                    if (nextEntry != prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
                        if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
                    }
                }
            }


            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };


            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };


            return cacheFactory;
        };
    }

    /**
     * @ngdoc object
     * @name ng.$templateCache
     *
     * @description
     * Cache used for storing html templates.
     *
     * See {@link ng.$cacheFactory $cacheFactory}.
     *
     */
    function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
            return $cacheFactory('templates');
        }];
    }

    /* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!
     *
     * DOM-related variables:
     *
     * - "node" - DOM Node
     * - "element" - DOM Element or Node
     * - "$node" or "$element" - jqLite-wrapped node or element
     *
     *
     * Compiler related stuff:
     *
     * - "linkFn" - linking fn of a single directive
     * - "nodeLinkFn" - function that aggregates all linking fns for a particular node
     * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node
     * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)
     */


    var NON_ASSIGNABLE_MODEL_EXPRESSION = 'Non-assignable model expression: ';


    /**
     * @ngdoc function
     * @name ng.$compile
     * @function
     *
     * @description
     * Compiles a piece of HTML string or DOM into a template and produces a template function, which
     * can then be used to link {@link ng.$rootScope.Scope scope} and the template together.
     *
     * The compilation is a process of walking the DOM tree and trying to match DOM elements to
     * {@link ng.$compileProvider#directive directives}. For each match it
     * executes corresponding template function and collects the
     * instance functions into a single template function which is then returned.
     *
     * The template function can then be used once to produce the view or as it is the case with
     * {@link ng.directive:ngRepeat repeater} many-times, in which
     * case each call results in a view that is a DOM clone of the original template.
     *
     <doc:example module="compile">
     <doc:source>
     <script>
     // declare a new module, and inject the $compileProvider
     angular.module('compile', [], function($compileProvider) {
        // configure new 'compile' directive by passing a directive
        // factory function. The factory function injects the '$compile'
        $compileProvider.directive('compile', function($compile) {
          // directive factory creates a link function
          return function(scope, element, attrs) {
            scope.$watch(
              function(scope) {
                 // watch the 'compile' expression for changes
                return scope.$eval(attrs.compile);
              },
              function(value) {
                // when the 'compile' expression changes
                // assign it into the current DOM
                element.html(value);

                // compile the new DOM and link it to the current
                // scope.
                // NOTE: we only compile .childNodes so that
                // we don't get into infinite loop compiling ourselves
                $compile(element.contents())(scope);
              }
            );
          };
        })
      });

     function Ctrl($scope) {
        $scope.name = 'Angular';
        $scope.html = 'Hello {{name}}';
      }
     </script>
     <div ng-controller="Ctrl">
     <input ng-model="name"> <br>
     <textarea ng-model="html"></textarea> <br>
     <div compile="html"></div>
     </div>
     </doc:source>
     <doc:scenario>
     it('should auto compile', function() {
       expect(element('div[compile]').text()).toBe('Hello Angular');
       input('html').enter('{{name}}!');
       expect(element('div[compile]').text()).toBe('Angular!');
     });
     </doc:scenario>
     </doc:example>

     *
     *
     * @param {string|DOMElement} element Element or HTML string to compile into a template function.
     * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.
     * @param {number} maxPriority only apply directives lower then given priority (Only effects the
     *                 root element(s), not their children)
     * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template
     * (a DOM element/tree) to a scope. Where:
     *
     *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.
     *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
     *               `template` and call the `cloneAttachFn` function allowing the caller to attach the
     *               cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
     *               called as: <br> `cloneAttachFn(clonedElement, scope)` where:
     *
     *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
     *      * `scope` - is the current scope with which the linking function is working with.
     *
     * Calling the linking function returns the element of the template. It is either the original element
     * passed in, or the clone of the element if the `cloneAttachFn` is provided.
     *
     * After linking the view is not updated until after a call to $digest which typically is done by
     * Angular automatically.
     *
     * If you need access to the bound view, there are two ways to do it:
     *
     * - If you are not asking the linking function to clone the template, create the DOM element(s)
     *   before you send them to the compiler and keep this reference around.
     *   <pre>
     *     var element = $compile('<p>{{total}}</p>')(scope);
     *   </pre>
     *
     * - if on the other hand, you need the element to be cloned, the view reference from the original
     *   example would not point to the clone, but rather to the original template that was cloned. In
     *   this case, you can access the clone via the cloneAttachFn:
     *   <pre>
     *     var templateHTML = angular.element('<p>{{total}}</p>'),
     *         scope = ....;
     *
     *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {
 *       //attach the clone to DOM document at the right place
 *     });
     *
     *     //now we have reference to the cloned DOM via `clone`
     *   </pre>
     *
     *
     * For information on how the compiler works, see the
     * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
     */


    /**
     * @ngdoc service
     * @name ng.$compileProvider
     * @function
     *
     * @description
     */
    $CompileProvider.$inject = ['$provide'];
    function $CompileProvider($provide) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,
            MULTI_ROOT_TEMPLATE_ERROR = 'Template must have exactly one root element. was: ',
            urlSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/;


        /**
         * @ngdoc function
         * @name ng.$compileProvider#directive
         * @methodOf ng.$compileProvider
         * @function
         *
         * @description
         * Register a new directives with the compiler.
         *
         * @param {string} name Name of the directive in camel-case. (ie <code>ngBind</code> which will match as
         *                <code>ng-bind</code>).
         * @param {function} directiveFactory An injectable directive factory function. See {@link guide/directive} for more
         *                info.
         * @returns {ng.$compileProvider} Self for chaining.
         */
        this.directive = function registerDirective(name, directiveFactory) {
            if (isString(name)) {
                assertArg(directiveFactory, 'directive');
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
                        function($injector, $exceptionHandler) {
                            var directives = [];
                            forEach(hasDirectives[name], function(directiveFactory) {
                                try {
                                    var directive = $injector.invoke(directiveFactory);
                                    if (isFunction(directive)) {
                                        directive = { compile: valueFn(directive) };
                                    } else if (!directive.compile && directive.link) {
                                        directive.compile = valueFn(directive.link);
                                    }
                                    directive.priority = directive.priority || 0;
                                    directive.name = directive.name || name;
                                    directive.require = directive.require || (directive.controller && directive.name);
                                    directive.restrict = directive.restrict || 'A';
                                    directives.push(directive);
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            });
                            return directives;
                        }]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };


        /**
         * @ngdoc function
         * @name ng.$compileProvider#urlSanitizationWhitelist
         * @methodOf ng.$compileProvider
         * @function
         *
         * @description
         * Retrieves or overrides the default regular expression that is used for whitelisting of safe
         * urls during a[href] sanitization.
         *
         * The sanitization is a security measure aimed at prevent XSS attacks via html links.
         *
         * Any url about to be assigned to a[href] via data-binding is first normalized and turned into an
         * absolute url. Afterwards the url is matched against the `urlSanitizationWhitelist` regular
         * expression. If a match is found the original url is written into the dom. Otherwise the
         * absolute url is prefixed with `'unsafe:'` string and only then it is written into the DOM.
         *
         * @param {RegExp=} regexp New regexp to whitelist urls with.
         * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
         *    chaining otherwise.
         */
        this.urlSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                urlSanitizationWhitelist = regexp;
                return this;
            }
            return urlSanitizationWhitelist;
        };


        this.$get = [
            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',
            '$controller', '$rootScope', '$document',
            function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,
                     $controller,   $rootScope,   $document) {

                var Attributes = function(element, attr) {
                    this.$$element = element;
                    this.$attr = attr || {};
                };

                Attributes.prototype = {
                    $normalize: directiveNormalize,


                    /**
                     * Set a normalized attribute on the element in a way such that all directives
                     * can share the attribute. This function properly handles boolean attributes.
                     * @param {string} key Normalized key. (ie ngAttribute)
                     * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
                     * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
                     *     Defaults to true.
                     * @param {string=} attrName Optional none normalized name. Defaults to key.
                     */
                    $set: function(key, value, writeAttr, attrName) {
                        var booleanKey = getBooleanAttrName(this.$$element[0], key),
                            $$observers = this.$$observers,
                            normalizedVal;

                        if (booleanKey) {
                            this.$$element.prop(key, value);
                            attrName = booleanKey;
                        }

                        this[key] = value;

                        // translate normalized key to actual key
                        if (attrName) {
                            this.$attr[key] = attrName;
                        } else {
                            attrName = this.$attr[key];
                            if (!attrName) {
                                this.$attr[key] = attrName = snake_case(key, '-');
                            }
                        }


                        // sanitize a[href] values
                        if (nodeName_(this.$$element[0]) === 'A' && key === 'href') {
                            urlSanitizationNode.setAttribute('href', value);

                            // href property always returns normalized absolute url, so we can match against that
                            normalizedVal = urlSanitizationNode.href;
                            if (!normalizedVal.match(urlSanitizationWhitelist)) {
                                this[key] = value = 'unsafe:' + normalizedVal;
                            }
                        }


                        if (writeAttr !== false) {
                            if (value === null || value === undefined) {
                                this.$$element.removeAttr(attrName);
                            } else {
                                this.$$element.attr(attrName, value);
                            }
                        }

                        // fire observers
                        $$observers && forEach($$observers[key], function(fn) {
                            try {
                                fn(value);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                    },


                    /**
                     * Observe an interpolated attribute.
                     * The observer will never be called, if given attribute is not interpolated.
                     *
                     * @param {string} key Normalized key. (ie ngAttribute) .
                     * @param {function(*)} fn Function that will be called whenever the attribute value changes.
                     * @returns {function(*)} the `fn` Function passed in.
                     */
                    $observe: function(key, fn) {
                        var attrs = this,
                            $$observers = (attrs.$$observers || (attrs.$$observers = {})),
                            listeners = ($$observers[key] || ($$observers[key] = []));

                        listeners.push(fn);
                        $rootScope.$evalAsync(function() {
                            if (!listeners.$$inter) {
                                // no one registered attribute interpolation function, so lets call it manually
                                fn(attrs[key]);
                            }
                        });
                        return fn;
                    }
                };

                var urlSanitizationNode = $document[0].createElement('a'),
                    startSymbol = $interpolate.startSymbol(),
                    endSymbol = $interpolate.endSymbol(),
                    denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')
                        ? identity
                        : function denormalizeTemplate(template) {
                        return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                    },
                    NG_ATTR_BINDING = /^ngAttr[A-Z]/;


                return compile;

                //================================

                function compile($compileNodes, transcludeFn, maxPriority) {
                    if (!($compileNodes instanceof jqLite)) {
                        // jquery always rewraps, whereas we need to preserve the original selector so that we can modify it.
                        $compileNodes = jqLite($compileNodes);
                    }
                    // We can not compile top level text elements since text nodes can be merged and we will
                    // not be able to attach scope data to them, so we will wrap them in <span>
                    forEach($compileNodes, function(node, index){
                        if (node.nodeType == 3 /* text node */ && node.nodeValue.match(/\S+/) /* non-empty */ ) {
                            $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
                        }
                    });
                    var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);
                    return function publicLinkFn(scope, cloneConnectFn){
                        assertArg(scope, 'scope');
                        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
                        // and sometimes changes the structure of the DOM.
                        var $linkNode = cloneConnectFn
                            ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!
                            : $compileNodes;

                        // Attach scope only to non-text nodes.
                        for(var i = 0, ii = $linkNode.length; i<ii; i++) {
                            var node = $linkNode[i];
                            if (node.nodeType == 1 /* element */ || node.nodeType == 9 /* document */) {
                                $linkNode.eq(i).data('$scope', scope);
                            }
                        }
                        safeAddClass($linkNode, 'ng-scope');
                        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);
                        return $linkNode;
                    };
                }

                function wrongMode(localName, mode) {
                    throw Error("Unsupported '" + mode + "' for '" + localName + "'.");
                }

                function safeAddClass($element, className) {
                    try {
                        $element.addClass(className);
                    } catch(e) {
                        // ignore, since it means that we are trying to set class on
                        // SVG element, where class name is read-only.
                    }
                }

                /**
                 * Compile function matches each node in nodeList against the directives. Once all directives
                 * for a particular node are collected their compile functions are executed. The compile
                 * functions return values - the linking functions - are combined into a composite linking
                 * function, which is the a linking function for the node.
                 *
                 * @param {NodeList} nodeList an array of nodes or NodeList to compile
                 * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
                 *        scope argument is auto-generated to the new child of the transcluded parent scope.
                 * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then the
                 *        rootElement must be set the jqLite collection of the compile root. This is
                 *        needed so that the jqLite collection items can be replaced with widgets.
                 * @param {number=} max directive priority
                 * @returns {?function} A composite linking function of all of the matched directives or null.
                 */
                function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {
                    var linkFns = [],
                        nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;

                    for(var i = 0; i < nodeList.length; i++) {
                        attrs = new Attributes();

                        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
                        directives = collectDirectives(nodeList[i], [], attrs, maxPriority);

                        nodeLinkFn = (directives.length)
                            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement)
                            : null;

                        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length)
                            ? null
                            : compileNodes(nodeList[i].childNodes,
                            nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);

                        linkFns.push(nodeLinkFn);
                        linkFns.push(childLinkFn);
                        linkFnFound = (linkFnFound || nodeLinkFn || childLinkFn);
                    }

                    // return a linking function if we have found anything, null otherwise
                    return linkFnFound ? compositeLinkFn : null;

                    function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
                        var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;

                        // copy nodeList so that linking doesn't break due to live list updates.
                        var stableNodeList = [];
                        for (i = 0, ii = nodeList.length; i < ii; i++) {
                            stableNodeList.push(nodeList[i]);
                        }

                        for(i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
                            node = stableNodeList[n];
                            nodeLinkFn = linkFns[i++];
                            childLinkFn = linkFns[i++];

                            if (nodeLinkFn) {
                                if (nodeLinkFn.scope) {
                                    childScope = scope.$new(isObject(nodeLinkFn.scope));
                                    jqLite(node).data('$scope', childScope);
                                } else {
                                    childScope = scope;
                                }
                                childTranscludeFn = nodeLinkFn.transclude;
                                if (childTranscludeFn || (!boundTranscludeFn && transcludeFn)) {
                                    nodeLinkFn(childLinkFn, childScope, node, $rootElement,
                                        (function(transcludeFn) {
                                            return function(cloneFn) {
                                                var transcludeScope = scope.$new();
                                                transcludeScope.$$transcluded = true;

                                                return transcludeFn(transcludeScope, cloneFn).
                                                    bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                                            };
                                        })(childTranscludeFn || transcludeFn)
                                    );
                                } else {
                                    nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
                                }
                            } else if (childLinkFn) {
                                childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
                            }
                        }
                    }
                }


                /**
                 * Looks for directives on the given node and adds them to the directive collection which is
                 * sorted.
                 *
                 * @param node Node to search.
                 * @param directives An array to which the directives are added to. This array is sorted before
                 *        the function returns.
                 * @param attrs The shared attrs object which is used to populate the normalized attributes.
                 * @param {number=} maxPriority Max directive priority.
                 */
                function collectDirectives(node, directives, attrs, maxPriority) {
                    var nodeType = node.nodeType,
                        attrsMap = attrs.$attr,
                        match,
                        className;

                    switch(nodeType) {
                        case 1: /* Element */
                            // use the node name: <directive>
                            addDirective(directives,
                                directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);

                            // iterate over the attributes
                            for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,
                                     j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                attr = nAttrs[j];
                                if (attr.specified) {
                                    name = attr.name;
                                    // support ngAttr attribute binding
                                    ngAttrName = directiveNormalize(name);
                                    if (NG_ATTR_BINDING.test(ngAttrName)) {
                                        name = ngAttrName.substr(6).toLowerCase();
                                    }
                                    nName = directiveNormalize(name.toLowerCase());
                                    attrsMap[nName] = name;
                                    attrs[nName] = value = trim((msie && name == 'href')
                                        ? decodeURIComponent(node.getAttribute(name, 2))
                                        : attr.value);
                                    if (getBooleanAttrName(node, nName)) {
                                        attrs[nName] = true; // presence means true
                                    }
                                    addAttrInterpolateDirective(node, directives, value, nName);
                                    addDirective(directives, nName, 'A', maxPriority);
                                }
                            }

                            // use class as directive
                            className = node.className;
                            if (isString(className) && className !== '') {
                                while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                                    nName = directiveNormalize(match[2]);
                                    if (addDirective(directives, nName, 'C', maxPriority)) {
                                        attrs[nName] = trim(match[3]);
                                    }
                                    className = className.substr(match.index + match[0].length);
                                }
                            }
                            break;
                        case 3: /* Text Node */
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;
                        case 8: /* Comment */
                            try {
                                match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                                if (match) {
                                    nName = directiveNormalize(match[1]);
                                    if (addDirective(directives, nName, 'M', maxPriority)) {
                                        attrs[nName] = trim(match[2]);
                                    }
                                }
                            } catch (e) {
                                // turns out that under some circumstances IE9 throws errors when one attempts to read comment's node value.
                                // Just ignore it and continue. (Can't seem to reproduce in test case.)
                            }
                            break;
                    }

                    directives.sort(byPriority);
                    return directives;
                }


                /**
                 * Once the directives have been collected, their compile functions are executed. This method
                 * is responsible for inlining directive templates as well as terminating the application
                 * of the directives if the terminal directive has been reached.
                 *
                 * @param {Array} directives Array of collected directives to execute their compile function.
                 *        this needs to be pre-sorted by priority order.
                 * @param {Node} compileNode The raw DOM node to apply the compile functions to
                 * @param {Object} templateAttrs The shared attribute function
                 * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
                 *        scope argument is auto-generated to the new child of the transcluded parent scope.
                 * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
                 *        argument has the root jqLite array so that we can replace nodes on it.
                 * @returns linkFn
                 */
                function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {
                    var terminalPriority = -Number.MAX_VALUE,
                        preLinkFns = [],
                        postLinkFns = [],
                        newScopeDirective = null,
                        newIsolateScopeDirective = null,
                        templateDirective = null,
                        $compileNode = templateAttrs.$$element = jqLite(compileNode),
                        directive,
                        directiveName,
                        $template,
                        transcludeDirective,
                        childTranscludeFn = transcludeFn,
                        controllerDirectives,
                        linkFn,
                        directiveValue;

                    // executes all directives on the current element
                    for(var i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        $template = undefined;

                        if (terminalPriority > directive.priority) {
                            break; // prevent further processing of directives
                        }

                        if (directiveValue = directive.scope) {
                            assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);
                            if (isObject(directiveValue)) {
                                safeAddClass($compileNode, 'ng-isolate-scope');
                                newIsolateScopeDirective = directive;
                            }
                            safeAddClass($compileNode, 'ng-scope');
                            newScopeDirective = newScopeDirective || directive;
                        }

                        directiveName = directive.name;

                        if (directiveValue = directive.controller) {
                            controllerDirectives = controllerDirectives || {};
                            assertNoDuplicate("'" + directiveName + "' controller",
                                controllerDirectives[directiveName], directive, $compileNode);
                            controllerDirectives[directiveName] = directive;
                        }

                        if (directiveValue = directive.transclude) {
                            assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);
                            transcludeDirective = directive;
                            terminalPriority = directive.priority;
                            if (directiveValue == 'element') {
                                $template = jqLite(compileNode);
                                $compileNode = templateAttrs.$$element =
                                    jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                                compileNode = $compileNode[0];
                                replaceWith(jqCollection, jqLite($template[0]), compileNode);
                                childTranscludeFn = compile($template, transcludeFn, terminalPriority);
                            } else {
                                $template = jqLite(JQLiteClone(compileNode)).contents();
                                $compileNode.html(''); // clear contents
                                childTranscludeFn = compile($template, transcludeFn);
                            }
                        }

                        if (directive.template) {
                            assertNoDuplicate('template', templateDirective, directive, $compileNode);
                            templateDirective = directive;

                            directiveValue = (isFunction(directive.template))
                                ? directive.template($compileNode, templateAttrs)
                                : directive.template;

                            directiveValue = denormalizeTemplate(directiveValue);

                            if (directive.replace) {
                                $template = jqLite('<div>' +
                                    trim(directiveValue) +
                                    '</div>').contents();
                                compileNode = $template[0];

                                if ($template.length != 1 || compileNode.nodeType !== 1) {
                                    throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);
                                }

                                replaceWith(jqCollection, $compileNode, compileNode);

                                var newTemplateAttrs = {$attr: {}};

                                // combine directives from the original node and from the template:
                                // - take the array of directives for this element
                                // - split it into two parts, those that were already applied and those that weren't
                                // - collect directives from the template, add them to the second group and sort them
                                // - append the second group with new directives to the first group
                                directives = directives.concat(
                                    collectDirectives(
                                        compileNode,
                                        directives.splice(i + 1, directives.length - (i + 1)),
                                        newTemplateAttrs
                                    )
                                );
                                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

                                ii = directives.length;
                            } else {
                                $compileNode.html(directiveValue);
                            }
                        }

                        if (directive.templateUrl) {
                            assertNoDuplicate('template', templateDirective, directive, $compileNode);
                            templateDirective = directive;
                            nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i),
                                nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace,
                                childTranscludeFn);
                            ii = directives.length;
                        } else if (directive.compile) {
                            try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                if (isFunction(linkFn)) {
                                    addLinkFns(null, linkFn);
                                } else if (linkFn) {
                                    addLinkFns(linkFn.pre, linkFn.post);
                                }
                            } catch (e) {
                                $exceptionHandler(e, startingTag($compileNode));
                            }
                        }

                        if (directive.terminal) {
                            nodeLinkFn.terminal = true;
                            terminalPriority = Math.max(terminalPriority, directive.priority);
                        }

                    }

                    nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;
                    nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;

                    // might be normal or delayed nodeLinkFn depending on if templateUrl is present
                    return nodeLinkFn;

                    ////////////////////

                    function addLinkFns(pre, post) {
                        if (pre) {
                            pre.require = directive.require;
                            preLinkFns.push(pre);
                        }
                        if (post) {
                            post.require = directive.require;
                            postLinkFns.push(post);
                        }
                    }


                    function getControllers(require, $element) {
                        var value, retrievalMethod = 'data', optional = false;
                        if (isString(require)) {
                            while((value = require.charAt(0)) == '^' || value == '?') {
                                require = require.substr(1);
                                if (value == '^') {
                                    retrievalMethod = 'inheritedData';
                                }
                                optional = optional || value == '?';
                            }
                            value = $element[retrievalMethod]('$' + require + 'Controller');
                            if (!value && !optional) {
                                throw Error("No controller: " + require);
                            }
                            return value;
                        } else if (isArray(require)) {
                            value = [];
                            forEach(require, function(require) {
                                value.push(getControllers(require, $element));
                            });
                        }
                        return value;
                    }


                    function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                        var attrs, $element, i, ii, linkFn, controller;

                        if (compileNode === linkNode) {
                            attrs = templateAttrs;
                        } else {
                            attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
                        }
                        $element = attrs.$$element;

                        if (newIsolateScopeDirective) {
                            var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;

                            var parentScope = scope.$parent || scope;

                            forEach(newIsolateScopeDirective.scope, function(definiton, scopeName) {
                                var match = definiton.match(LOCAL_REGEXP) || [],
                                    attrName = match[3] || scopeName,
                                    optional = (match[2] == '?'),
                                    mode = match[1], // @, =, or &
                                    lastValue,
                                    parentGet, parentSet;

                                scope.$$isolateBindings[scopeName] = mode + attrName;

                                switch (mode) {

                                    case '@': {
                                        attrs.$observe(attrName, function(value) {
                                            scope[scopeName] = value;
                                        });
                                        attrs.$$observers[attrName].$$scope = parentScope;
                                        if( attrs[attrName] ) {
                                            // If the attribute has been provided then we trigger an interpolation to ensure the value is there for use in the link fn
                                            scope[scopeName] = $interpolate(attrs[attrName])(parentScope);
                                        }
                                        break;
                                    }

                                    case '=': {
                                        if (optional && !attrs[attrName]) {
                                            return;
                                        }
                                        parentGet = $parse(attrs[attrName]);
                                        parentSet = parentGet.assign || function() {
                                            // reset the change, or we will throw this exception on every $digest
                                            lastValue = scope[scopeName] = parentGet(parentScope);
                                            throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] +
                                                ' (directive: ' + newIsolateScopeDirective.name + ')');
                                        };
                                        lastValue = scope[scopeName] = parentGet(parentScope);
                                        scope.$watch(function parentValueWatch() {
                                            var parentValue = parentGet(parentScope);

                                            if (parentValue !== scope[scopeName]) {
                                                // we are out of sync and need to copy
                                                if (parentValue !== lastValue) {
                                                    // parent changed and it has precedence
                                                    lastValue = scope[scopeName] = parentValue;
                                                } else {
                                                    // if the parent can be assigned then do so
                                                    parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                                                }
                                            }
                                            return parentValue;
                                        });
                                        break;
                                    }

                                    case '&': {
                                        parentGet = $parse(attrs[attrName]);
                                        scope[scopeName] = function(locals) {
                                            return parentGet(parentScope, locals);
                                        };
                                        break;
                                    }

                                    default: {
                                        throw Error('Invalid isolate scope definition for directive ' +
                                            newIsolateScopeDirective.name + ': ' + definiton);
                                    }
                                }
                            });
                        }

                        if (controllerDirectives) {
                            forEach(controllerDirectives, function(directive) {
                                var locals = {
                                    $scope: scope,
                                    $element: $element,
                                    $attrs: attrs,
                                    $transclude: boundTranscludeFn
                                };

                                controller = directive.controller;
                                if (controller == '@') {
                                    controller = attrs[directive.name];
                                }

                                $element.data(
                                    '$' + directive.name + 'Controller',
                                    $controller(controller, locals));
                            });
                        }

                        // PRELINKING
                        for(i = 0, ii = preLinkFns.length; i < ii; i++) {
                            try {
                                linkFn = preLinkFns[i];
                                linkFn(scope, $element, attrs,
                                    linkFn.require && getControllers(linkFn.require, $element));
                            } catch (e) {
                                $exceptionHandler(e, startingTag($element));
                            }
                        }

                        // RECURSION
                        childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);

                        // POSTLINKING
                        for(i = 0, ii = postLinkFns.length; i < ii; i++) {
                            try {
                                linkFn = postLinkFns[i];
                                linkFn(scope, $element, attrs,
                                    linkFn.require && getControllers(linkFn.require, $element));
                            } catch (e) {
                                $exceptionHandler(e, startingTag($element));
                            }
                        }
                    }
                }


                /**
                 * looks up the directive and decorates it with exception handling and proper parameters. We
                 * call this the boundDirective.
                 *
                 * @param {string} name name of the directive to look up.
                 * @param {string} location The directive must be found in specific format.
                 *   String containing any of theses characters:
                 *
                 *   * `E`: element name
                 *   * `A': attribute
                 *   * `C`: class
                 *   * `M`: comment
                 * @returns true if directive was added.
                 */
                function addDirective(tDirectives, name, location, maxPriority) {
                    var match = false;
                    if (hasDirectives.hasOwnProperty(name)) {
                        for(var directive, directives = $injector.get(name + Suffix),
                                i = 0, ii = directives.length; i<ii; i++) {
                            try {
                                directive = directives[i];
                                if ( (maxPriority === undefined || maxPriority > directive.priority) &&
                                    directive.restrict.indexOf(location) != -1) {
                                    tDirectives.push(directive);
                                    match = true;
                                }
                            } catch(e) { $exceptionHandler(e); }
                        }
                    }
                    return match;
                }


                /**
                 * When the element is replaced with HTML template then the new attributes
                 * on the template need to be merged with the existing attributes in the DOM.
                 * The desired effect is to have both of the attributes present.
                 *
                 * @param {object} dst destination attributes (original DOM)
                 * @param {object} src source attributes (from the directive template)
                 */
                function mergeTemplateAttributes(dst, src) {
                    var srcAttr = src.$attr,
                        dstAttr = dst.$attr,
                        $element = dst.$$element;

                    // reapply the old attributes to the new element
                    forEach(dst, function(value, key) {
                        if (key.charAt(0) != '$') {
                            if (src[key]) {
                                value += (key === 'style' ? ';' : ' ') + src[key];
                            }
                            dst.$set(key, value, true, srcAttr[key]);
                        }
                    });

                    // copy the new attributes on the old attrs object
                    forEach(src, function(value, key) {
                        if (key == 'class') {
                            safeAddClass($element, value);
                            dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
                        } else if (key == 'style') {
                            $element.attr('style', $element.attr('style') + ';' + value);
                        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                            dst[key] = value;
                            dstAttr[key] = srcAttr[key];
                        }
                    });
                }


                function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs,
                                            $rootElement, replace, childTranscludeFn) {
                    var linkQueue = [],
                        afterTemplateNodeLinkFn,
                        afterTemplateChildLinkFn,
                        beforeTemplateCompileNode = $compileNode[0],
                        origAsyncDirective = directives.shift(),
                    // The fact that we have to copy and patch the directive seems wrong!
                        derivedSyncDirective = extend({}, origAsyncDirective, {
                            controller: null, templateUrl: null, transclude: null, scope: null
                        }),
                        templateUrl = (isFunction(origAsyncDirective.templateUrl))
                            ? origAsyncDirective.templateUrl($compileNode, tAttrs)
                            : origAsyncDirective.templateUrl;

                    $compileNode.html('');

                    $http.get(templateUrl, {cache: $templateCache}).
                        success(function(content) {
                            var compileNode, tempTemplateAttrs, $template;

                            content = denormalizeTemplate(content);

                            if (replace) {
                                $template = jqLite('<div>' + trim(content) + '</div>').contents();
                                compileNode = $template[0];

                                if ($template.length != 1 || compileNode.nodeType !== 1) {
                                    throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);
                                }

                                tempTemplateAttrs = {$attr: {}};
                                replaceWith($rootElement, $compileNode, compileNode);
                                collectDirectives(compileNode, directives, tempTemplateAttrs);
                                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                            } else {
                                compileNode = beforeTemplateCompileNode;
                                $compileNode.html(content);
                            }

                            directives.unshift(derivedSyncDirective);
                            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);
                            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);


                            while(linkQueue.length) {
                                var scope = linkQueue.shift(),
                                    beforeTemplateLinkNode = linkQueue.shift(),
                                    linkRootElement = linkQueue.shift(),
                                    controller = linkQueue.shift(),
                                    linkNode = compileNode;

                                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                    // it was cloned therefore we have to clone as well.
                                    linkNode = JQLiteClone(compileNode);
                                    replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                                }

                                afterTemplateNodeLinkFn(function() {
                                    beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);
                                }, scope, linkNode, $rootElement, controller);
                            }
                            linkQueue = null;
                        }).
                        error(function(response, code, headers, config) {
                            throw Error('Failed to load template: ' + config.url);
                        });

                    return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
                        if (linkQueue) {
                            linkQueue.push(scope);
                            linkQueue.push(node);
                            linkQueue.push(rootElement);
                            linkQueue.push(controller);
                        } else {
                            afterTemplateNodeLinkFn(function() {
                                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
                            }, scope, node, rootElement, controller);
                        }
                    };
                }


                /**
                 * Sorting function for bound directives.
                 */
                function byPriority(a, b) {
                    return b.priority - a.priority;
                }


                function assertNoDuplicate(what, previousDirective, directive, element) {
                    if (previousDirective) {
                        throw Error('Multiple directives [' + previousDirective.name + ', ' +
                            directive.name + '] asking for ' + what + ' on: ' +  startingTag(element));
                    }
                }


                function addTextInterpolateDirective(directives, text) {
                    var interpolateFn = $interpolate(text, true);
                    if (interpolateFn) {
                        directives.push({
                            priority: 0,
                            compile: valueFn(function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent(),
                                    bindings = parent.data('$binding') || [];
                                bindings.push(interpolateFn);
                                safeAddClass(parent.data('$binding', bindings), 'ng-binding');
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            })
                        });
                    }
                }


                function addAttrInterpolateDirective(node, directives, value, name) {
                    var interpolateFn = $interpolate(value, true);

                    // no interpolation found -> ignore
                    if (!interpolateFn) return;


                    directives.push({
                        priority: 100,
                        compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
                            var $$observers = (attr.$$observers || (attr.$$observers = {}));

                            // we need to interpolate again, in case the attribute value has been updated
                            // (e.g. by another directive's compile function)
                            interpolateFn = $interpolate(attr[name], true);

                            // if attribute was updated so that there is no interpolation going on we don't want to
                            // register any observers
                            if (!interpolateFn) return;

                            attr[name] = interpolateFn(scope);
                            ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                            (attr.$$observers && attr.$$observers[name].$$scope || scope).
                                $watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    attr.$set(name, value);
                                });
                        })
                    });
                }


                /**
                 * This is a special jqLite.replaceWith, which can replace items which
                 * have no parents, provided that the containing jqLite collection is provided.
                 *
                 * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
                 *    in the root of the tree.
                 * @param {JqLite} $element The jqLite element which we are going to replace. We keep the shell,
                 *    but replace its DOM node reference.
                 * @param {Node} newNode The new DOM node.
                 */
                function replaceWith($rootElement, $element, newNode) {
                    var oldNode = $element[0],
                        parent = oldNode.parentNode,
                        i, ii;

                    if ($rootElement) {
                        for(i = 0, ii = $rootElement.length; i < ii; i++) {
                            if ($rootElement[i] == oldNode) {
                                $rootElement[i] = newNode;
                                break;
                            }
                        }
                    }

                    if (parent) {
                        parent.replaceChild(newNode, oldNode);
                    }

                    newNode[jqLite.expando] = oldNode[jqLite.expando];
                    $element[0] = newNode;
                }
            }];
    }

    var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
    /**
     * Converts all accepted directives format into proper directive name.
     * All of these will become 'myDirective':
     *   my:DiRective
     *   my-directive
     *   x-my-directive
     *   data-my:directive
     *
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
    }

    /**
     * @ngdoc object
     * @name ng.$compile.directive.Attributes
     * @description
     *
     * A shared object between directive compile / linking functions which contains normalized DOM element
     * attributes. The the values reflect current binding state `{{ }}`. The normalization is needed
     * since all of these are treated as equivalent in Angular:
     *
     *          <span ng:bind="a" ng-bind="a" data-ng-bind="a" x-ng-bind="a">
     */

    /**
     * @ngdoc property
     * @name ng.$compile.directive.Attributes#$attr
     * @propertyOf ng.$compile.directive.Attributes
     * @returns {object} A map of DOM element attribute names to the normalized name. This is
     *          needed to do reverse lookup from normalized name back to actual name.
     */


    /**
     * @ngdoc function
     * @name ng.$compile.directive.Attributes#$set
     * @methodOf ng.$compile.directive.Attributes
     * @function
     *
     * @description
     * Set DOM element attribute value.
     *
     *
     * @param {string} name Normalized element attribute name of the property to modify. The name is
     *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
     *          property to the original name.
     * @param {string} value Value to set the attribute to. The value can be an interpolated string.
     */



    /**
     * Closure compiler type information
     */

    function nodesetLinkingFn(
        /* angular.Scope */ scope,
        /* NodeList */ nodeList,
        /* Element */ rootElement,
        /* function(Function) */ boundTranscludeFn
        ){}

    function directiveLinkingFn(
        /* nodesetLinkingFn */ nodesetLinkingFn,
        /* angular.Scope */ scope,
        /* Node */ node,
        /* Element */ rootElement,
        /* function(Function) */ boundTranscludeFn
        ){}

    /**
     * @ngdoc object
     * @name ng.$controllerProvider
     * @description
     * The {@link ng.$controller $controller service} is used by Angular to create new
     * controllers.
     *
     * This provider allows controller registration via the
     * {@link ng.$controllerProvider#register register} method.
     */
    function $ControllerProvider() {
        var controllers = {},
            CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;


        /**
         * @ngdoc function
         * @name ng.$controllerProvider#register
         * @methodOf ng.$controllerProvider
         * @param {string} name Controller name
         * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
         *    annotations in the array notation).
         */
        this.register = function(name, constructor) {
            if (isObject(name)) {
                extend(controllers, name)
            } else {
                controllers[name] = constructor;
            }
        };


        this.$get = ['$injector', '$window', function($injector, $window) {

            /**
             * @ngdoc function
             * @name ng.$controller
             * @requires $injector
             *
             * @param {Function|string} constructor If called with a function then it's considered to be the
             *    controller constructor function. Otherwise it's considered to be a string which is used
             *    to retrieve the controller constructor using the following steps:
             *
             *    * check if a controller with given name is registered via `$controllerProvider`
             *    * check if evaluating the string on the current scope returns a constructor
             *    * check `window[constructor]` on the global `window` object
             *
             * @param {Object} locals Injection locals for Controller.
             * @return {Object} Instance of given controller.
             *
             * @description
             * `$controller` service is responsible for instantiating controllers.
             *
             * It's just a simple call to {@link AUTO.$injector $injector}, but extracted into
             * a service, so that one can override this service with {@link https://gist.github.com/1649788
             * BC version}.
             */
            return function(expression, locals) {
                var instance, match, constructor, identifier;

                if(isString(expression)) {
                    match = expression.match(CNTRL_REG),
                        constructor = match[1],
                        identifier = match[3];
                    expression = controllers.hasOwnProperty(constructor)
                        ? controllers[constructor]
                        : getter(locals.$scope, constructor, true) || getter($window, constructor, true);

                    assertArgFn(expression, constructor, true);
                }

                instance = $injector.instantiate(expression, locals);

                if (identifier) {
                    if (typeof locals.$scope !== 'object') {
                        throw new Error('Can not export controller as "' + identifier + '". ' +
                            'No scope object provided!');
                    }

                    locals.$scope[identifier] = instance;
                }

                return instance;
            };
        }];
    }

    /**
     * @ngdoc object
     * @name ng.$document
     * @requires $window
     *
     * @description
     * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`
     * element.
     */
    function $DocumentProvider(){
        this.$get = ['$window', function(window){
            return jqLite(window.document);
        }];
    }

    /**
     * @ngdoc function
     * @name ng.$exceptionHandler
     * @requires $log
     *
     * @description
     * Any uncaught exception in angular expressions is delegated to this service.
     * The default implementation simply delegates to `$log.error` which logs it into
     * the browser console.
     *
     * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
     * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.
     *
     * @param {Error} exception Exception associated with the error.
     * @param {string=} cause optional information about the context in which
     *       the error was thrown.
     *
     */
    function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        }];
    }

    /**
     * @ngdoc object
     * @name ng.$interpolateProvider
     * @function
     *
     * @description
     *
     * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
     */
    function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';

        /**
         * @ngdoc method
         * @name ng.$interpolateProvider#startSymbol
         * @methodOf ng.$interpolateProvider
         * @description
         * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
   *
   * @param {string=} value new value to set the starting symbol to.
         * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
         */
        this.startSymbol = function(value){
            if (value) {
                startSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };

        /**
         * @ngdoc method
         * @name ng.$interpolateProvider#endSymbol
         * @methodOf ng.$interpolateProvider
         * @description
         * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
         *
         * @param {string=} value new value to set the ending symbol to.
         * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
         */
        this.endSymbol = function(value){
            if (value) {
                endSymbol = value;
                return this;
            } else {
                return endSymbol;
            }
        };


        this.$get = ['$parse', '$exceptionHandler', function($parse, $exceptionHandler) {
            var startSymbolLength = startSymbol.length,
                endSymbolLength = endSymbol.length;

            /**
             * @ngdoc function
             * @name ng.$interpolate
             * @function
             *
             * @requires $parse
             *
             * @description
             *
             * Compiles a string with markup into an interpolation function. This service is used by the
             * HTML {@link ng.$compile $compile} service for data binding. See
             * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
             * interpolation markup.
             *
             *
             <pre>
             var $interpolate = ...; // injected
             var exp = $interpolate('Hello {{name}}!');
             expect(exp({name:'Angular'}).toEqual('Hello Angular!');
             </pre>
             *
             *
             * @param {string} text The text with markup to interpolate.
             * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
             *    embedded expression in order to return an interpolation function. Strings with no
             *    embedded expression will return null for the interpolation function.
             * @returns {function(context)} an interpolation function which is used to compute the interpolated
             *    string. The function has these parameters:
             *
             *    * `context`: an object against which any expressions embedded in the strings are evaluated
             *      against.
             *
             */
            function $interpolate(text, mustHaveExpression) {
                var startIndex,
                    endIndex,
                    index = 0,
                    parts = [],
                    length = text.length,
                    hasInterpolation = false,
                    fn,
                    exp,
                    concat = [];

                while(index < length) {
                    if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &&
                        ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {
                        (index != startIndex) && parts.push(text.substring(index, startIndex));
                        parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
                        fn.exp = exp;
                        index = endIndex + endSymbolLength;
                        hasInterpolation = true;
                    } else {
                        // we did not find anything, so we have to add the remainder to the parts array
                        (index != length) && parts.push(text.substring(index));
                        index = length;
                    }
                }

                if (!(length = parts.length)) {
                    // we added, nothing, must have been an empty string.
                    parts.push('');
                    length = 1;
                }

                if (!mustHaveExpression  || hasInterpolation) {
                    concat.length = length;
                    fn = function(context) {
                        try {
                            for(var i = 0, ii = length, part; i<ii; i++) {
                                if (typeof (part = parts[i]) == 'function') {
                                    part = part(context);
                                    if (part == null || part == undefined) {
                                        part = '';
                                    } else if (typeof part != 'string') {
                                        part = toJson(part);
                                    }
                                }
                                concat[i] = part;
                            }
                            return concat.join('');
                        }
                        catch(err) {
                            var newErr = new Error('Error while interpolating: ' + text + '\n' + err.toString());
                            $exceptionHandler(newErr);
                        }
                    };
                    fn.exp = text;
                    fn.parts = parts;
                    return fn;
                }
            }


            /**
             * @ngdoc method
             * @name ng.$interpolate#startSymbol
             * @methodOf ng.$interpolate
             * @description
             * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
     *
     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change
             * the symbol.
             *
             * @returns {string} start symbol.
             */
            $interpolate.startSymbol = function() {
                return startSymbol;
            }


            /**
             * @ngdoc method
             * @name ng.$interpolate#endSymbol
             * @methodOf ng.$interpolate
             * @description
             * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
             *
             * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change
             * the symbol.
             *
             * @returns {string} start symbol.
             */
            $interpolate.endSymbol = function() {
                return endSymbol;
            }

            return $interpolate;
        }];
    }

    var SERVER_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/,
        PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
        DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};


    /**
     * Encode path using encodeUriSegment, ignoring forward slashes
     *
     * @param {string} path Path to encode
     * @returns {string}
     */
    function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;

        while (i--) {
            segments[i] = encodeUriSegment(segments[i]);
        }

        return segments.join('/');
    }

    function matchUrl(url, obj) {
        var match = SERVER_MATCH.exec(url);

        obj.$$protocol = match[1];
        obj.$$host = match[3];
        obj.$$port = int(match[5]) || DEFAULT_PORTS[match[1]] || null;
    }

    function matchAppUrl(url, obj) {
        var match = PATH_MATCH.exec(url);

        obj.$$path = decodeURIComponent(match[1]);
        obj.$$search = parseKeyValue(match[3]);
        obj.$$hash = decodeURIComponent(match[5] || '');

        // make sure path starts with '/';
        if (obj.$$path && obj.$$path.charAt(0) != '/') obj.$$path = '/' + obj.$$path;
    }


    function composeProtocolHostPort(protocol, host, port) {
        return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
    }

    /**
     *
     * @param {string} begin
     * @param {string} whole
     * @param {string} otherwise
     * @returns {string} returns text from whole after begin or otherwise if it does not begin with expected string.
     */
    function beginsWith(begin, whole, otherwise) {
        return whole.indexOf(begin) == 0 ? whole.substr(begin.length) : otherwise;
    }


    function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
    }


    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
    }

    /* return the server only */
    function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
    }


    /**
     * LocationHtml5Url represents an url
     * This object is exposed as $location service when HTML5 mode is enabled and supported
     *
     * @constructor
     * @param {string} appBase application base URL
     * @param {string} basePrefix url path prefix
     */
    function LocationHtml5Url(appBase, basePrefix) {
        basePrefix = basePrefix || '';
        var appBaseNoFile = stripFile(appBase);
        /**
         * Parse given html5 (regular) url string into properties
         * @param {string} newAbsoluteUrl HTML5 url
         * @private
         */
        this.$$parse = function(url) {
            var parsed = {}
            matchUrl(url, parsed);
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) {
                throw Error('Invalid url "' + url + '", missing path prefix "' + appBaseNoFile + '".');
            }
            matchAppUrl(pathUrl, parsed);
            extend(this, parsed);
            if (!this.$$path) {
                this.$$path = '/';
            }

            this.$$compose();
        };

        /**
         * Compose url and update `absUrl` property
         * @private
         */
        this.$$compose = function() {
            var search = toKeyValue(this.$$search),
                hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

            this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'
        };

        this.$$rewrite = function(url) {
            var appUrl, prevAppUrl;

            if ( (appUrl = beginsWith(appBase, url)) !== undefined ) {
                prevAppUrl = appUrl;
                if ( (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ) {
                    return appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
                } else {
                    return appBase + prevAppUrl;
                }
            } else if ( (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ) {
                return appBaseNoFile + appUrl;
            } else if (appBaseNoFile == url + '/') {
                return appBaseNoFile;
            }
        }
    }


    /**
     * LocationHashbangUrl represents url
     * This object is exposed as $location service when html5 history api is disabled or not supported
     *
     * @constructor
     * @param {string} appBase application base URL
     * @param {string} hashPrefix hashbang prefix
     */
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);

        /**
         * Parse given hashbang url into properties
         * @param {string} url Hashbang url
         * @private
         */
        this.$$parse = function(url) {
            matchUrl(url, this);
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            if (!isString(withoutBaseUrl)) {
                throw new Error('Invalid url "' + url + '", does not start with "' + appBase +  '".');
            }
            var withoutHashUrl = withoutBaseUrl.charAt(0) == '#' ? beginsWith(hashPrefix, withoutBaseUrl) : withoutBaseUrl;
            if (!isString(withoutHashUrl)) {
                throw new Error('Invalid url "' + url + '", missing hash prefix "' + hashPrefix + '".');
            }
            matchAppUrl(withoutHashUrl, this);
            this.$$compose();
        };

        /**
         * Compose hashbang url and update `absUrl` property
         * @private
         */
        this.$$compose = function() {
            var search = toKeyValue(this.$$search),
                hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

            this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };

        this.$$rewrite = function(url) {
            if(stripHash(appBase) == stripHash(url)) {
                return url;
            }
        }
    }


    /**
     * LocationHashbangUrl represents url
     * This object is exposed as $location service when html5 history api is enabled but the browser
     * does not support it.
     *
     * @constructor
     * @param {string} appBase application base URL
     * @param {string} hashPrefix hashbang prefix
     */
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        LocationHashbangUrl.apply(this, arguments);

        var appBaseNoFile = stripFile(appBase);

        this.$$rewrite = function(url) {
            var appUrl;

            if ( appBase == stripHash(url) ) {
                return url;
            } else if ( (appUrl = beginsWith(appBaseNoFile, url)) ) {
                return appBase + hashPrefix + appUrl;
            } else if ( appBaseNoFile === url + '/') {
                return appBaseNoFile;
            }
        }
    }


    LocationHashbangInHtml5Url.prototype =
        LocationHashbangUrl.prototype =
            LocationHtml5Url.prototype = {

                /**
                 * Has any change been replacing ?
                 * @private
                 */
                $$replace: false,

                /**
                 * @ngdoc method
                 * @name ng.$location#absUrl
                 * @methodOf ng.$location
                 *
                 * @description
                 * This method is getter only.
                 *
                 * Return full url representation with all segments encoded according to rules specified in
                 * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.
                 *
                 * @return {string} full url
                 */
                absUrl: locationGetter('$$absUrl'),

                /**
                 * @ngdoc method
                 * @name ng.$location#url
                 * @methodOf ng.$location
                 *
                 * @description
                 * This method is getter / setter.
                 *
                 * Return url (e.g. `/path?a=b#hash`) when called without any parameter.
                 *
                 * Change path, search and hash, when called with parameter and return `$location`.
                 *
                 * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)
                 * @return {string} url
                 */
                url: function(url, replace) {
                    if (isUndefined(url))
                        return this.$$url;

                    var match = PATH_MATCH.exec(url);
                    if (match[1]) this.path(decodeURIComponent(match[1]));
                    if (match[2] || match[1]) this.search(match[3] || '');
                    this.hash(match[5] || '', replace);

                    return this;
                },

                /**
                 * @ngdoc method
                 * @name ng.$location#protocol
                 * @methodOf ng.$location
                 *
                 * @description
                 * This method is getter only.
                 *
                 * Return protocol of current url.
                 *
                 * @return {string} protocol of current url
                 */
                protocol: locationGetter('$$protocol'),

                /**
                 * @ngdoc method
                 * @name ng.$location#host
                 * @methodOf ng.$location
                 *
                 * @description
                 * This method is getter only.
                 *
                 * Return host of current url.
                 *
                 * @return {string} host of current url.
                 */
                host: locationGetter('$$host'),

                /**
                 * @ngdoc method
                 * @name ng.$location#port
                 * @methodOf ng.$location
                 *
                 * @description
                 * This method is getter only.
                 *
                 * Return port of current url.
                 *
                 * @return {Number} port
                 */
                port: locationGetter('$$port'),

                /**
                 * @ngdoc method
                 * @name ng.$location#path
                 * @methodOf ng.$location
                 *
                 * @description
                 * This method is getter / setter.
                 *
                 * Return path of current url when called without any parameter.
                 *
                 * Change path when called with parameter and return `$location`.
                 *
                 * Note: Path should always begin with forward slash (/), this method will add the forward slash
                 * if it is missing.
                 *
                 * @param {string=} path New path
                 * @return {string} path
                 */
                path: locationGetterSetter('$$path', function(path) {
                    return path.charAt(0) == '/' ? path : '/' + path;
                }),

                /**
                 * @ngdoc method
                 * @name ng.$location#search
                 * @methodOf ng.$location
                 *
                 * @description
                 * This method is getter / setter.
                 *
                 * Return search part (as object) of current url when called without any parameter.
                 *
                 * Change search part when called with parameter and return `$location`.
                 *
                 * @param {string|object<string,string>=} search New search params - string or hash object
                 * @param {string=} paramValue If `search` is a string, then `paramValue` will override only a
                 *    single search parameter. If the value is `null`, the parameter will be deleted.
                 *
                 * @return {string} search
                 */
                search: function(search, paramValue) {
                    if (isUndefined(search))
                        return this.$$search;

                    if (isDefined(paramValue)) {
                        if (paramValue === null) {
                            delete this.$$search[search];
                        } else {
                            this.$$search[search] = paramValue;
                        }
                    } else {
                        this.$$search = isString(search) ? parseKeyValue(search) : search;
                    }

                    this.$$compose();
                    return this;
                },

                /**
                 * @ngdoc method
                 * @name ng.$location#hash
                 * @methodOf ng.$location
                 *
                 * @description
                 * This method is getter / setter.
                 *
                 * Return hash fragment when called without any parameter.
                 *
                 * Change hash fragment when called with parameter and return `$location`.
                 *
                 * @param {string=} hash New hash fragment
                 * @return {string} hash
                 */
                hash: locationGetterSetter('$$hash', identity),

                /**
                 * @ngdoc method
                 * @name ng.$location#replace
                 * @methodOf ng.$location
                 *
                 * @description
                 * If called, all changes to $location during current `$digest` will be replacing current history
                 * record, instead of adding new one.
                 */
                replace: function() {
                    this.$$replace = true;
                    return this;
                }
            };

    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }


    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value))
                return this[property];

            this[property] = preprocess(value);
            this.$$compose();

            return this;
        };
    }


    /**
     * @ngdoc object
     * @name ng.$location
     *
     * @requires $browser
     * @requires $sniffer
     * @requires $rootElement
     *
     * @description
     * The $location service parses the URL in the browser address bar (based on the
     * {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL
     * available to your application. Changes to the URL in the address bar are reflected into
     * $location service and changes to $location are reflected into the browser address bar.
     *
     * **The $location service:**
     *
     * - Exposes the current URL in the browser address bar, so you can
     *   - Watch and observe the URL.
     *   - Change the URL.
     * - Synchronizes the URL with the browser when the user
     *   - Changes the address bar.
     *   - Clicks the back or forward button (or clicks a History link).
     *   - Clicks on a link.
     * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
     *
     * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular
     * Services: Using $location}
     */

    /**
     * @ngdoc object
     * @name ng.$locationProvider
     * @description
     * Use the `$locationProvider` to configure how the application deep linking paths are stored.
     */
    function $LocationProvider(){
        var hashPrefix = '',
            html5Mode = false;

        /**
         * @ngdoc property
         * @name ng.$locationProvider#hashPrefix
         * @methodOf ng.$locationProvider
         * @description
         * @param {string=} prefix Prefix for hash part (containing path and search)
         * @returns {*} current value if used as getter or itself (chaining) if used as setter
         */
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };

        /**
         * @ngdoc property
         * @name ng.$locationProvider#html5Mode
         * @methodOf ng.$locationProvider
         * @description
         * @param {string=} mode Use HTML5 strategy if available.
         * @returns {*} current value if used as getter or itself (chaining) if used as setter
         */
        this.html5Mode = function(mode) {
            if (isDefined(mode)) {
                html5Mode = mode;
                return this;
            } else {
                return html5Mode;
            }
        };

        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
            function( $rootScope,   $browser,   $sniffer,   $rootElement) {
                var $location,
                    LocationMode,
                    baseHref = $browser.baseHref(),
                    initialUrl = $browser.url(),
                    appBase;

                if (html5Mode) {
                    appBase = baseHref ? serverBase(initialUrl) + baseHref : initialUrl;
                    LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
                } else {
                    appBase = stripHash(initialUrl);
                    LocationMode = LocationHashbangUrl;
                }
                $location = new LocationMode(appBase, '#' + hashPrefix);
                $location.$$parse($location.$$rewrite(initialUrl));

                $rootElement.bind('click', function(event) {
                    // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
                    // currently we open nice url link and redirect then

                    if (event.ctrlKey || event.metaKey || event.which == 2) return;

                    var elm = jqLite(event.target);

                    // traverse the DOM up to find first A tag
                    while (lowercase(elm[0].nodeName) !== 'a') {
                        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
                        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    }

                    var absHref = elm.prop('href');
                    var rewrittenUrl = $location.$$rewrite(absHref);

                    if (absHref && !elm.attr('target') && rewrittenUrl && !event.isDefaultPrevented()) {
                        event.preventDefault();
                        if (rewrittenUrl != $browser.url()) {
                            // update location manually
                            $location.$$parse(rewrittenUrl);
                            $rootScope.$apply();
                            // hack to work around FF6 bug 684208 when scenario runner clicks on links
                            window.angular['ff-684208-preventDefault'] = true;
                        }
                    }
                });


                // rewrite hashbang url <> html5 url
                if ($location.absUrl() != initialUrl) {
                    $browser.url($location.absUrl(), true);
                }

                // update $location when $browser url changes
                $browser.onUrlChange(function(newUrl) {
                    if ($location.absUrl() != newUrl) {
                        if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {
                            $browser.url($location.absUrl());
                            return;
                        }
                        $rootScope.$evalAsync(function() {
                            var oldUrl = $location.absUrl();

                            $location.$$parse(newUrl);
                            afterLocationChange(oldUrl);
                        });
                        if (!$rootScope.$$phase) $rootScope.$digest();
                    }
                });

                // update browser
                var changeCounter = 0;
                $rootScope.$watch(function $locationWatch() {
                    var oldUrl = $browser.url();
                    var currentReplace = $location.$$replace;

                    if (!changeCounter || oldUrl != $location.absUrl()) {
                        changeCounter++;
                        $rootScope.$evalAsync(function() {
                            if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).
                                defaultPrevented) {
                                $location.$$parse(oldUrl);
                            } else {
                                $browser.url($location.absUrl(), currentReplace);
                                afterLocationChange(oldUrl);
                            }
                        });
                    }
                    $location.$$replace = false;

                    return changeCounter;
                });

                return $location;

                function afterLocationChange(oldUrl) {
                    $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
                }
            }];
    }

    /**
     * @ngdoc object
     * @name ng.$log
     * @requires $window
     *
     * @description
     * Simple service for logging. Default implementation writes the message
     * into the browser's console (if present).
     *
     * The main purpose of this service is to simplify debugging and troubleshooting.
     *
     * @example
     <example>
     <file name="script.js">
     function LogCtrl($scope, $log) {
         $scope.$log = $log;
         $scope.message = 'Hello World!';
       }
     </file>
     <file name="index.html">
     <div ng-controller="LogCtrl">
     <p>Reload this page with open console, enter text and hit the log button...</p>
     Message:
     <input type="text" ng-model="message"/>
     <button ng-click="$log.log(message)">log</button>
     <button ng-click="$log.warn(message)">warn</button>
     <button ng-click="$log.info(message)">info</button>
     <button ng-click="$log.error(message)">error</button>
     </div>
     </file>
     </example>
     */

    /**
     * @ngdoc object
     * @name ng.$logProvider
     * @description
     * Use the `$logProvider` to configure how the application logs messages
     */
    function $LogProvider(){
        var debug = true,
            self = this;

        /**
         * @ngdoc property
         * @name ng.$logProvider#debugEnabled
         * @methodOf ng.$logProvider
         * @description
         * @param {string=} flag enable or disable debug level messages
         * @returns {*} current value if used as getter or itself (chaining) if used as setter
         */
        this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };

        this.$get = ['$window', function($window){
            return {
                /**
                 * @ngdoc method
                 * @name ng.$log#log
                 * @methodOf ng.$log
                 *
                 * @description
                 * Write a log message
                 */
                log: consoleLog('log'),

                /**
                 * @ngdoc method
                 * @name ng.$log#warn
                 * @methodOf ng.$log
                 *
                 * @description
                 * Write a warning message
                 */
                warn: consoleLog('warn'),

                /**
                 * @ngdoc method
                 * @name ng.$log#info
                 * @methodOf ng.$log
                 *
                 * @description
                 * Write an information message
                 */
                info: consoleLog('info'),

                /**
                 * @ngdoc method
                 * @name ng.$log#error
                 * @methodOf ng.$log
                 *
                 * @description
                 * Write an error message
                 */
                error: consoleLog('error'),

                /**
                 * @ngdoc method
                 * @name ng.$log#debug
                 * @methodOf ng.$log
                 *
                 * @description
                 * Write a debug message
                 */
                debug: (function () {
                    var fn = consoleLog('debug');

                    return function() {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    }
                }())
            };

            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
                            ? 'Error: ' + arg.message + '\n' + arg.stack
                            : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
                    }
                }
                return arg;
            }

            function consoleLog(type) {
                var console = $window.console || {},
                    logFn = console[type] || console.log || noop;

                if (logFn.apply) {
                    return function() {
                        var args = [];
                        forEach(arguments, function(arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }

                // we are IE which either doesn't have window.console => this is noop and we do nothing,
                // or we are IE where console.log doesn't have apply so we log at least first 2 args
                return function(arg1, arg2) {
                    logFn(arg1, arg2);
                }
            }
        }];
    }

    var OPERATORS = {
        'null':function(){return null;},
        'true':function(){return true;},
        'false':function(){return false;},
        undefined:noop,
        '+':function(self, locals, a,b){
            a=a(self, locals); b=b(self, locals);
            if (isDefined(a)) {
                if (isDefined(b)) {
                    return a + b;
                }
                return a;
            }
            return isDefined(b)?b:undefined;},
        '-':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},
        '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},
        '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},
        '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},
        '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},
        '=':noop,
        '===':function(self, locals, a, b){return a(self, locals)===b(self, locals);},
        '!==':function(self, locals, a, b){return a(self, locals)!==b(self, locals);},
        '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},
        '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},
        '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},
        '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},
        '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},
        '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},
        '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},
        '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},
        '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},
//    '|':function(self, locals, a,b){return a|b;},
        '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},
        '!':function(self, locals, a){return !a(self, locals);}
    };
    var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};

    function lex(text, csp){
        var tokens = [],
            token,
            index = 0,
            json = [],
            ch,
            lastCh = ':'; // can start regexp

        while (index < text.length) {
            ch = text.charAt(index);
            if (is('"\'')) {
                readString(ch);
            } else if (isNumber(ch) || is('.') && isNumber(peek())) {
                readNumber();
            } else if (isIdent(ch)) {
                readIdent();
                // identifiers can only be if the preceding char was a { or ,
                if (was('{,') && json[0]=='{' &&
                    (token=tokens[tokens.length-1])) {
                    token.json = token.text.indexOf('.') == -1;
                }
            } else if (is('(){}[].,;:?')) {
                tokens.push({
                    index:index,
                    text:ch,
                    json:(was(':[,') && is('{[')) || is('}]:,')
                });
                if (is('{[')) json.unshift(ch);
                if (is('}]')) json.shift();
                index++;
            } else if (isWhitespace(ch)) {
                index++;
                continue;
            } else {
                var ch2 = ch + peek(),
                    ch3 = ch2 + peek(2),
                    fn = OPERATORS[ch],
                    fn2 = OPERATORS[ch2],
                    fn3 = OPERATORS[ch3];
                if (fn3) {
                    tokens.push({index:index, text:ch3, fn:fn3});
                    index += 3;
                } else if (fn2) {
                    tokens.push({index:index, text:ch2, fn:fn2});
                    index += 2;
                } else if (fn) {
                    tokens.push({index:index, text:ch, fn:fn, json: was('[,:') && is('+-')});
                    index += 1;
                } else {
                    throwError("Unexpected next character ", index, index+1);
                }
            }
            lastCh = ch;
        }
        return tokens;

        function is(chars) {
            return chars.indexOf(ch) != -1;
        }

        function was(chars) {
            return chars.indexOf(lastCh) != -1;
        }

        function peek(i) {
            var num = i || 1;
            return index + num < text.length ? text.charAt(index + num) : false;
        }
        function isNumber(ch) {
            return '0' <= ch && ch <= '9';
        }
        function isWhitespace(ch) {
            return ch == ' ' || ch == '\r' || ch == '\t' ||
                ch == '\n' || ch == '\v' || ch == '\u00A0'; // IE treats non-breaking space as \u00A0
        }
        function isIdent(ch) {
            return 'a' <= ch && ch <= 'z' ||
                'A' <= ch && ch <= 'Z' ||
                '_' == ch || ch == '$';
        }
        function isExpOperator(ch) {
            return ch == '-' || ch == '+' || isNumber(ch);
        }

        function throwError(error, start, end) {
            end = end || index;
            throw Error("Lexer Error: " + error + " at column" +
                (isDefined(start)
                    ? "s " + start +  "-" + index + " [" + text.substring(start, end) + "]"
                    : " " + end) +
                " in expression [" + text + "].");
        }

        function readNumber() {
            var number = "";
            var start = index;
            while (index < text.length) {
                var ch = lowercase(text.charAt(index));
                if (ch == '.' || isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = peek();
                    if (ch == 'e' && isExpOperator(peekCh)) {
                        number += ch;
                    } else if (isExpOperator(ch) &&
                        peekCh && isNumber(peekCh) &&
                        number.charAt(number.length - 1) == 'e') {
                        number += ch;
                    } else if (isExpOperator(ch) &&
                        (!peekCh || !isNumber(peekCh)) &&
                        number.charAt(number.length - 1) == 'e') {
                        throwError('Invalid exponent');
                    } else {
                        break;
                    }
                }
                index++;
            }
            number = 1 * number;
            tokens.push({index:start, text:number, json:true,
                fn:function() {return number;}});
        }
        function readIdent() {
            var ident = "",
                start = index,
                lastDot, peekIndex, methodName, ch;

            while (index < text.length) {
                ch = text.charAt(index);
                if (ch == '.' || isIdent(ch) || isNumber(ch)) {
                    if (ch == '.') lastDot = index;
                    ident += ch;
                } else {
                    break;
                }
                index++;
            }

            //check if this is not a method invocation and if it is back out to last dot
            if (lastDot) {
                peekIndex = index;
                while(peekIndex < text.length) {
                    ch = text.charAt(peekIndex);
                    if (ch == '(') {
                        methodName = ident.substr(lastDot - start + 1);
                        ident = ident.substr(0, lastDot - start);
                        index = peekIndex;
                        break;
                    }
                    if(isWhitespace(ch)) {
                        peekIndex++;
                    } else {
                        break;
                    }
                }
            }


            var token = {
                index:start,
                text:ident
            };

            if (OPERATORS.hasOwnProperty(ident)) {
                token.fn = token.json = OPERATORS[ident];
            } else {
                var getter = getterFn(ident, csp);
                token.fn = extend(function(self, locals) {
                    return (getter(self, locals));
                }, {
                    assign: function(self, value) {
                        return setter(self, ident, value);
                    }
                });
            }

            tokens.push(token);

            if (methodName) {
                tokens.push({
                    index:lastDot,
                    text: '.',
                    json: false
                });
                tokens.push({
                    index: lastDot + 1,
                    text: methodName,
                    json: false
                });
            }
        }

        function readString(quote) {
            var start = index;
            index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (index < text.length) {
                var ch = text.charAt(index);
                rawString += ch;
                if (escape) {
                    if (ch == 'u') {
                        var hex = text.substring(index + 1, index + 5);
                        if (!hex.match(/[\da-f]{4}/i))
                            throwError( "Invalid unicode escape [\\u" + hex + "]");
                        index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        if (rep) {
                            string += rep;
                        } else {
                            string += ch;
                        }
                    }
                    escape = false;
                } else if (ch == '\\') {
                    escape = true;
                } else if (ch == quote) {
                    index++;
                    tokens.push({
                        index:start,
                        text:rawString,
                        string:string,
                        json:true,
                        fn:function() { return string; }
                    });
                    return;
                } else {
                    string += ch;
                }
                index++;
            }
            throwError("Unterminated quote", start);
        }
    }

/////////////////////////////////////////

    function parser(text, json, $filter, csp){
        var ZERO = valueFn(0),
            value,
            tokens = lex(text, csp),
            assignment = _assignment,
            functionCall = _functionCall,
            fieldAccess = _fieldAccess,
            objectIndex = _objectIndex,
            filterChain = _filterChain;

        if(json){
            // The extra level of aliasing is here, just in case the lexer misses something, so that
            // we prevent any accidental execution in JSON.
            assignment = logicalOR;
            functionCall =
                fieldAccess =
                    objectIndex =
                        filterChain =
                            function() { throwError("is not valid json", {text:text, index:0}); };
            value = primary();
        } else {
            value = statements();
        }
        if (tokens.length !== 0) {
            throwError("is an unexpected token", tokens[0]);
        }
        value.literal = !!value.literal;
        value.constant = !!value.constant;
        return value;

        ///////////////////////////////////
        function throwError(msg, token) {
            throw Error("Syntax Error: Token '" + token.text +
                "' " + msg + " at column " +
                (token.index + 1) + " of the expression [" +
                text + "] starting at [" + text.substring(token.index) + "].");
        }

        function peekToken() {
            if (tokens.length === 0)
                throw Error("Unexpected end of expression: " + text);
            return tokens[0];
        }

        function peek(e1, e2, e3, e4) {
            if (tokens.length > 0) {
                var token = tokens[0];
                var t = token.text;
                if (t==e1 || t==e2 || t==e3 || t==e4 ||
                    (!e1 && !e2 && !e3 && !e4)) {
                    return token;
                }
            }
            return false;
        }

        function expect(e1, e2, e3, e4){
            var token = peek(e1, e2, e3, e4);
            if (token) {
                if (json && !token.json) {
                    throwError("is not valid json", token);
                }
                tokens.shift();
                return token;
            }
            return false;
        }

        function consume(e1){
            if (!expect(e1)) {
                throwError("is unexpected, expecting [" + e1 + "]", peek());
            }
        }

        function unaryFn(fn, right) {
            return extend(function(self, locals) {
                return fn(self, locals, right);
            }, {
                constant:right.constant
            });
        }

        function ternaryFn(left, middle, right){
            return extend(function(self, locals){
                return left(self, locals) ? middle(self, locals) : right(self, locals);
            }, {
                constant: left.constant && middle.constant && right.constant
            });
        }

        function binaryFn(left, fn, right) {
            return extend(function(self, locals) {
                return fn(self, locals, left, right);
            }, {
                constant:left.constant && right.constant
            });
        }

        function statements() {
            var statements = [];
            while(true) {
                if (tokens.length > 0 && !peek('}', ')', ';', ']'))
                    statements.push(filterChain());
                if (!expect(';')) {
                    // optimize for the common case where there is only one statement.
                    // TODO(size): maybe we should not support multiple statements?
                    return statements.length == 1
                        ? statements[0]
                        : function(self, locals){
                        var value;
                        for ( var i = 0; i < statements.length; i++) {
                            var statement = statements[i];
                            if (statement)
                                value = statement(self, locals);
                        }
                        return value;
                    };
                }
            }
        }

        function _filterChain() {
            var left = expression();
            var token;
            while(true) {
                if ((token = expect('|'))) {
                    left = binaryFn(left, token.fn, filter());
                } else {
                    return left;
                }
            }
        }

        function filter() {
            var token = expect();
            var fn = $filter(token.text);
            var argsFn = [];
            while(true) {
                if ((token = expect(':'))) {
                    argsFn.push(expression());
                } else {
                    var fnInvoke = function(self, locals, input){
                        var args = [input];
                        for ( var i = 0; i < argsFn.length; i++) {
                            args.push(argsFn[i](self, locals));
                        }
                        return fn.apply(self, args);
                    };
                    return function() {
                        return fnInvoke;
                    };
                }
            }
        }

        function expression() {
            return assignment();
        }

        function _assignment() {
            var left = ternary();
            var right;
            var token;
            if ((token = expect('='))) {
                if (!left.assign) {
                    throwError("implies assignment but [" +
                        text.substring(0, token.index) + "] can not be assigned to", token);
                }
                right = ternary();
                return function(scope, locals){
                    return left.assign(scope, right(scope, locals), locals);
                };
            } else {
                return left;
            }
        }

        function ternary() {
            var left = logicalOR();
            var middle;
            var token;
            if((token = expect('?'))){
                middle = ternary();
                if((token = expect(':'))){
                    return ternaryFn(left, middle, ternary());
                }
                else {
                    throwError('expected :', token);
                }
            }
            else {
                return left;
            }
        }

        function logicalOR() {
            var left = logicalAND();
            var token;
            while(true) {
                if ((token = expect('||'))) {
                    left = binaryFn(left, token.fn, logicalAND());
                } else {
                    return left;
                }
            }
        }

        function logicalAND() {
            var left = equality();
            var token;
            if ((token = expect('&&'))) {
                left = binaryFn(left, token.fn, logicalAND());
            }
            return left;
        }

        function equality() {
            var left = relational();
            var token;
            if ((token = expect('==','!=','===','!=='))) {
                left = binaryFn(left, token.fn, equality());
            }
            return left;
        }

        function relational() {
            var left = additive();
            var token;
            if ((token = expect('<', '>', '<=', '>='))) {
                left = binaryFn(left, token.fn, relational());
            }
            return left;
        }

        function additive() {
            var left = multiplicative();
            var token;
            while ((token = expect('+','-'))) {
                left = binaryFn(left, token.fn, multiplicative());
            }
            return left;
        }

        function multiplicative() {
            var left = unary();
            var token;
            while ((token = expect('*','/','%'))) {
                left = binaryFn(left, token.fn, unary());
            }
            return left;
        }

        function unary() {
            var token;
            if (expect('+')) {
                return primary();
            } else if ((token = expect('-'))) {
                return binaryFn(ZERO, token.fn, unary());
            } else if ((token = expect('!'))) {
                return unaryFn(token.fn, unary());
            } else {
                return primary();
            }
        }


        function primary() {
            var primary;
            if (expect('(')) {
                primary = filterChain();
                consume(')');
            } else if (expect('[')) {
                primary = arrayDeclaration();
            } else if (expect('{')) {
                primary = object();
            } else {
                var token = expect();
                primary = token.fn;
                if (!primary) {
                    throwError("not a primary expression", token);
                }
                if (token.json) {
                    primary.constant = primary.literal = true;
                }
            }

            var next, context;
            while ((next = expect('(', '[', '.'))) {
                if (next.text === '(') {
                    primary = functionCall(primary, context);
                    context = null;
                } else if (next.text === '[') {
                    context = primary;
                    primary = objectIndex(primary);
                } else if (next.text === '.') {
                    context = primary;
                    primary = fieldAccess(primary);
                } else {
                    throwError("IMPOSSIBLE");
                }
            }
            return primary;
        }

        function _fieldAccess(object) {
            var field = expect().text;
            var getter = getterFn(field, csp);
            return extend(
                function(scope, locals, self) {
                    return getter(self || object(scope, locals), locals);
                },
                {
                    assign:function(scope, value, locals) {
                        return setter(object(scope, locals), field, value);
                    }
                }
            );
        }

        function _objectIndex(obj) {
            var indexFn = expression();
            consume(']');
            return extend(
                function(self, locals){
                    var o = obj(self, locals),
                        i = indexFn(self, locals),
                        v, p;

                    if (!o) return undefined;
                    v = o[i];
                    if (v && v.then) {
                        p = v;
                        if (!('$$v' in v)) {
                            p.$$v = undefined;
                            p.then(function(val) { p.$$v = val; });
                        }
                        v = v.$$v;
                    }
                    return v;
                }, {
                    assign:function(self, value, locals){
                        return obj(self, locals)[indexFn(self, locals)] = value;
                    }
                });
        }

        function _functionCall(fn, contextGetter) {
            var argsFn = [];
            if (peekToken().text != ')') {
                do {
                    argsFn.push(expression());
                } while (expect(','));
            }
            consume(')');
            return function(scope, locals){
                var args = [],
                    context = contextGetter ? contextGetter(scope, locals) : scope;

                for ( var i = 0; i < argsFn.length; i++) {
                    args.push(argsFn[i](scope, locals));
                }
                var fnPtr = fn(scope, locals, context) || noop;
                // IE stupidity!
                return fnPtr.apply
                    ? fnPtr.apply(context, args)
                    : fnPtr(args[0], args[1], args[2], args[3], args[4]);
            };
        }

        // This is used with json array declaration
        function arrayDeclaration () {
            var elementFns = [];
            var allConstant = true;
            if (peekToken().text != ']') {
                do {
                    var elementFn = expression();
                    elementFns.push(elementFn);
                    if (!elementFn.constant) {
                        allConstant = false;
                    }
                } while (expect(','));
            }
            consume(']');
            return extend(function(self, locals){
                var array = [];
                for ( var i = 0; i < elementFns.length; i++) {
                    array.push(elementFns[i](self, locals));
                }
                return array;
            }, {
                literal:true,
                constant:allConstant
            });
        }

        function object () {
            var keyValues = [];
            var allConstant = true;
            if (peekToken().text != '}') {
                do {
                    var token = expect(),
                        key = token.string || token.text;
                    consume(":");
                    var value = expression();
                    keyValues.push({key:key, value:value});
                    if (!value.constant) {
                        allConstant = false;
                    }
                } while (expect(','));
            }
            consume('}');
            return extend(function(self, locals){
                var object = {};
                for ( var i = 0; i < keyValues.length; i++) {
                    var keyValue = keyValues[i];
                    object[keyValue.key] = keyValue.value(self, locals);
                }
                return object;
            }, {
                literal:true,
                constant:allConstant
            });
        }
    }

//////////////////////////////////////////////////
// Parser helper functions
//////////////////////////////////////////////////

    function setter(obj, path, setValue) {
        var element = path.split('.');
        for (var i = 0; element.length > 1; i++) {
            var key = element.shift();
            var propertyObj = obj[key];
            if (!propertyObj) {
                propertyObj = {};
                obj[key] = propertyObj;
            }
            obj = propertyObj;
        }
        obj[element.shift()] = setValue;
        return setValue;
    }

    /**
     * Return the value accessible from the object by path. Any undefined traversals are ignored
     * @param {Object} obj starting object
     * @param {string} path path to traverse
     * @param {boolean=true} bindFnToScope
     * @returns value as accessible by path
     */
//TODO(misko): this function needs to be removed
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;

        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }

    var getterFnCache = {};

    /**
     * Implementation of the "Black Hole" variant from:
     * - http://jsperf.com/angularjs-parse-getter/4
     * - http://jsperf.com/path-evaluation-simplified/7
     */
    function cspSafeGetterFn(key0, key1, key2, key3, key4) {
        return function(scope, locals) {
            var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,
                promise;

            if (pathVal === null || pathVal === undefined) return pathVal;

            pathVal = pathVal[key0];
            if (pathVal && pathVal.then) {
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) { promise.$$v = val; });
                }
                pathVal = pathVal.$$v;
            }
            if (!key1 || pathVal === null || pathVal === undefined) return pathVal;

            pathVal = pathVal[key1];
            if (pathVal && pathVal.then) {
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) { promise.$$v = val; });
                }
                pathVal = pathVal.$$v;
            }
            if (!key2 || pathVal === null || pathVal === undefined) return pathVal;

            pathVal = pathVal[key2];
            if (pathVal && pathVal.then) {
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) { promise.$$v = val; });
                }
                pathVal = pathVal.$$v;
            }
            if (!key3 || pathVal === null || pathVal === undefined) return pathVal;

            pathVal = pathVal[key3];
            if (pathVal && pathVal.then) {
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) { promise.$$v = val; });
                }
                pathVal = pathVal.$$v;
            }
            if (!key4 || pathVal === null || pathVal === undefined) return pathVal;

            pathVal = pathVal[key4];
            if (pathVal && pathVal.then) {
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) { promise.$$v = val; });
                }
                pathVal = pathVal.$$v;
            }
            return pathVal;
        };
    }

    function getterFn(path, csp) {
        if (getterFnCache.hasOwnProperty(path)) {
            return getterFnCache[path];
        }

        var pathKeys = path.split('.'),
            pathKeysLength = pathKeys.length,
            fn;

        if (csp) {
            fn = (pathKeysLength < 6)
                ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4])
                : function(scope, locals) {
                var i = 0, val;
                do {
                    val = cspSafeGetterFn(
                        pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++]
                    )(scope, locals);

                    locals = undefined; // clear after first iteration
                    scope = val;
                } while (i < pathKeysLength);
                return val;
            }
        } else {
            var code = 'var l, fn, p;\n';
            forEach(pathKeys, function(key, index) {
                code += 'if(s === null || s === undefined) return s;\n' +
                    'l=s;\n' +
                    's='+ (index
                    // we simply dereference 's' on any .dot notation
                    ? 's'
                    // but if we are first then we check locals first, and if so read it first
                    : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' +
                    'if (s && s.then) {\n' +
                    ' if (!("$$v" in s)) {\n' +
                    ' p=s;\n' +
                    ' p.$$v = undefined;\n' +
                    ' p.then(function(v) {p.$$v=v;});\n' +
                    '}\n' +
                    ' s=s.$$v\n' +
                    '}\n';
            });
            code += 'return s;';
            fn = Function('s', 'k', code); // s=scope, k=locals
            fn.toString = function() { return code; };
        }

        return getterFnCache[path] = fn;
    }

///////////////////////////////////

    /**
     * @ngdoc function
     * @name ng.$parse
     * @function
     *
     * @description
     *
     * Converts Angular {@link guide/expression expression} into a function.
     *
     * <pre>
     *   var getter = $parse('user.name');
     *   var setter = getter.assign;
     *   var context = {user:{name:'angular'}};
     *   var locals = {user:{name:'local'}};
     *
     *   expect(getter(context)).toEqual('angular');
     *   setter(context, 'newValue');
     *   expect(context.user.name).toEqual('newValue');
     *   expect(getter(context, locals)).toEqual('local');
     * </pre>
     *
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` â€“ `{object}` â€“ an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` â€“ `{object=}` â€“ local variables context object, useful for overriding values in
     *      `context`.
     *
     *    The returned function also has the following properties:
     *      * `literal` â€“ `{boolean}` â€“ whether the expression's top-level node is a JavaScript
     *        literal.
     *      * `constant` â€“ `{boolean}` â€“ whether the expression is made entirely of JavaScript
     *        constant literals.
     *      * `assign` â€“ `{?function(context, value)}` â€“ if the expression is assignable, this will be
     *        set to a function to change its value on the given context.
     *
     */
    function $ParseProvider() {
        var cache = {};
        this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {
            return function(exp) {
                switch(typeof exp) {
                    case 'string':
                        return cache.hasOwnProperty(exp)
                            ? cache[exp]
                            : cache[exp] =  parser(exp, false, $filter, $sniffer.csp);
                    case 'function':
                        return exp;
                    default:
                        return noop;
                }
            };
        }];
    }

    /**
     * @ngdoc service
     * @name ng.$q
     * @requires $rootScope
     *
     * @description
     * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).
     *
     * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
     * interface for interacting with an object that represents the result of an action that is
     * performed asynchronously, and may or may not be finished at any given point in time.
     *
     * From the perspective of dealing with error handling, deferred and promise APIs are to
     * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.
     *
     * <pre>
     *   // for the purpose of this example let's assume that variables `$q` and `scope` are
     *   // available in the current lexical scope (they could have been injected or passed in).
     *
     *   function asyncGreet(name) {
 *     var deferred = $q.defer();
 *
 *     setTimeout(function() {
 *       // since this fn executes async in a future turn of the event loop, we need to wrap
 *       // our code into an $apply call so that the model changes are properly observed.
 *       scope.$apply(function() {
 *         if (okToGreet(name)) {
 *           deferred.resolve('Hello, ' + name + '!');
 *         } else {
 *           deferred.reject('Greeting ' + name + ' is not allowed.');
 *         }
 *       });
 *     }, 1000);
 *
 *     return deferred.promise;
 *   }
     *
     *   var promise = asyncGreet('Robin Hood');
     *   promise.then(function(greeting) {
 *     alert('Success: ' + greeting);
 *   }, function(reason) {
 *     alert('Failed: ' + reason);
 *   });
     * </pre>
     *
     * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
     * comes in the way of
     * [guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).
     *
     * Additionally the promise api allows for composition that is very hard to do with the
     * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
     * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
     * section on serial or parallel joining of promises.
     *
     *
     * # The Deferred API
     *
     * A new instance of deferred is constructed by calling `$q.defer()`.
     *
     * The purpose of the deferred object is to expose the associated Promise instance as well as APIs
     * that can be used for signaling the successful or unsuccessful completion of the task.
     *
     * **Methods**
     *
     * - `resolve(value)` â€“ resolves the derived promise with the `value`. If the value is a rejection
     *   constructed via `$q.reject`, the promise will be rejected instead.
     * - `reject(reason)` â€“ rejects the derived promise with the `reason`. This is equivalent to
     *   resolving it with a rejection constructed via `$q.reject`.
     *
     * **Properties**
     *
     * - promise â€“ `{Promise}` â€“ promise object associated with this deferred.
     *
     *
     * # The Promise API
     *
     * A new promise instance is created when a deferred instance is created and can be retrieved by
     * calling `deferred.promise`.
     *
     * The purpose of the promise object is to allow for interested parties to get access to the result
     * of the deferred task when it completes.
     *
     * **Methods**
     *
     * - `then(successCallback, errorCallback)` â€“ regardless of when the promise was or will be resolved
     *   or rejected calls one of the success or error callbacks asynchronously as soon as the result
     *   is available. The callbacks are called with a single argument the result or rejection reason.
     *
     *   This method *returns a new promise* which is resolved or rejected via the return value of the
     *   `successCallback` or `errorCallback`.
     *
     * - `always(callback)` â€“ allows you to observe either the fulfillment or rejection of a promise,
     *   but to do so without modifying the final value. This is useful to release resources or do some
     *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
     *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
     *   more information.
     *
     * # Chaining promises
     *
     * Because calling `then` api of a promise returns a new derived promise, it is easily possible
     * to create a chain of promises:
     *
     * <pre>
     *   promiseB = promiseA.then(function(result) {
 *     return result + 1;
 *   });
     *
     *   // promiseB will be resolved immediately after promiseA is resolved and its value will be
     *   // the result of promiseA incremented by 1
     * </pre>
     *
     * It is possible to create chains of any length and since a promise can be resolved with another
     * promise (which will defer its resolution further), it is possible to pause/defer resolution of
     * the promises at any point in the chain. This makes it possible to implement powerful apis like
     * $http's response interceptors.
     *
     *
     * # Differences between Kris Kowal's Q and $q
     *
     *  There are three main differences:
     *
     * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
     *   mechanism in angular, which means faster propagation of resolution or rejection into your
     *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
     * - $q promises are recognized by the templating engine in angular, which means that in templates
     *   you can treat promises attached to a scope as if they were the resulting values.
     * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
     *   all the important functionality needed for common async tasks.
     *
     *  # Testing
     *
     *  <pre>
     *    it('should simulate promise', inject(function($q, $rootScope) {
 *      var deferred = $q.defer();
 *      var promise = deferred.promise;
 *      var resolvedValue;
 * 
 *      promise.then(function(value) { resolvedValue = value; });
 *      expect(resolvedValue).toBeUndefined();
 * 
 *      // Simulate resolving of promise
 *      deferred.resolve(123);
 *      // Note that the 'then' function does not get called synchronously.
 *      // This is because we want the promise API to always be async, whether or not
 *      // it got called synchronously or asynchronously.
 *      expect(resolvedValue).toBeUndefined();
 * 
 *      // Propagate promise resolution to 'then' functions using $apply().
 *      $rootScope.$apply();
 *      expect(resolvedValue).toEqual(123);
 *    });
     *  </pre>
     */
    function $QProvider() {

        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        }];
    }


    /**
     * Constructs a promise manager.
     *
     * @param {function(function)} nextTick Function for executing functions in the next turn.
     * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
     *     debugging purposes.
     * @returns {object} Promise manager.
     */
    function qFactory(nextTick, exceptionHandler) {

        /**
         * @ngdoc
         * @name ng.$q#defer
         * @methodOf ng.$q
         * @description
         * Creates a `Deferred` object which represents a task which will finish in the future.
         *
         * @returns {Deferred} Returns a new instance of deferred.
         */
        var defer = function() {
            var pending = [],
                value, deferred;

            deferred = {

                resolve: function(val) {
                    if (pending) {
                        var callbacks = pending;
                        pending = undefined;
                        value = ref(val);

                        if (callbacks.length) {
                            nextTick(function() {
                                var callback;
                                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                    callback = callbacks[i];
                                    value.then(callback[0], callback[1]);
                                }
                            });
                        }
                    }
                },


                reject: function(reason) {
                    deferred.resolve(reject(reason));
                },


                promise: {
                    then: function(callback, errback) {
                        var result = defer();

                        var wrappedCallback = function(value) {
                            try {
                                result.resolve((callback || defaultCallback)(value));
                            } catch(e) {
                                exceptionHandler(e);
                                result.reject(e);
                            }
                        };

                        var wrappedErrback = function(reason) {
                            try {
                                result.resolve((errback || defaultErrback)(reason));
                            } catch(e) {
                                exceptionHandler(e);
                                result.reject(e);
                            }
                        };

                        if (pending) {
                            pending.push([wrappedCallback, wrappedErrback]);
                        } else {
                            value.then(wrappedCallback, wrappedErrback);
                        }

                        return result.promise;
                    },
                    always: function(callback) {

                        function makePromise(value, resolved) {
                            var result = defer();
                            if (resolved) {
                                result.resolve(value);
                            } else {
                                result.reject(value);
                            }
                            return result.promise;
                        }

                        function handleCallback(value, isResolved) {
                            var callbackOutput = null;
                            try {
                                callbackOutput = (callback ||defaultCallback)();
                            } catch(e) {
                                return makePromise(e, false);
                            }
                            if (callbackOutput && callbackOutput.then) {
                                return callbackOutput.then(function() {
                                    return makePromise(value, isResolved);
                                }, function(error) {
                                    return makePromise(error, false);
                                });
                            } else {
                                return makePromise(value, isResolved);
                            }
                        }

                        return this.then(function(value) {
                            return handleCallback(value, true);
                        }, function(error) {
                            return handleCallback(error, false);
                        });
                    }
                }
            };

            return deferred;
        };


        var ref = function(value) {
            if (value && value.then) return value;
            return {
                then: function(callback) {
                    var result = defer();
                    nextTick(function() {
                        result.resolve(callback(value));
                    });
                    return result.promise;
                }
            };
        };


        /**
         * @ngdoc
         * @name ng.$q#reject
         * @methodOf ng.$q
         * @description
         * Creates a promise that is resolved as rejected with the specified `reason`. This api should be
         * used to forward rejection in a chain of promises. If you are dealing with the last promise in
         * a promise chain, you don't need to worry about it.
         *
         * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
         * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
         * a promise error callback and you want to forward the error to the promise derived from the
         * current promise, you have to "rethrow" the error by returning a rejection constructed via
         * `reject`.
         *
         * <pre>
         *   promiseB = promiseA.then(function(result) {
   *     // success: do something and resolve promiseB
   *     //          with the old or a new result
   *     return result;
   *   }, function(reason) {
   *     // error: handle the error if possible and
   *     //        resolve promiseB with newPromiseOrValue,
   *     //        otherwise forward the rejection to promiseB
   *     if (canHandle(reason)) {
   *      // handle the error and recover
   *      return newPromiseOrValue;
   *     }
   *     return $q.reject(reason);
   *   });
         * </pre>
         *
         * @param {*} reason Constant, message, exception or an object representing the rejection reason.
         * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
         */
        var reject = function(reason) {
            return {
                then: function(callback, errback) {
                    var result = defer();
                    nextTick(function() {
                        result.resolve((errback || defaultErrback)(reason));
                    });
                    return result.promise;
                }
            };
        };


        /**
         * @ngdoc
         * @name ng.$q#when
         * @methodOf ng.$q
         * @description
         * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
         * This is useful when you are dealing with an object that might or might not be a promise, or if
         * the promise comes from a source that can't be trusted.
         *
         * @param {*} value Value or a promise
         * @returns {Promise} Returns a promise of the passed value or promise
         */
        var when = function(value, callback, errback) {
            var result = defer(),
                done;

            var wrappedCallback = function(value) {
                try {
                    return (callback || defaultCallback)(value);
                } catch (e) {
                    exceptionHandler(e);
                    return reject(e);
                }
            };

            var wrappedErrback = function(reason) {
                try {
                    return (errback || defaultErrback)(reason);
                } catch (e) {
                    exceptionHandler(e);
                    return reject(e);
                }
            };

            nextTick(function() {
                ref(value).then(function(value) {
                    if (done) return;
                    done = true;
                    result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
                }, function(reason) {
                    if (done) return;
                    done = true;
                    result.resolve(wrappedErrback(reason));
                });
            });

            return result.promise;
        };


        function defaultCallback(value) {
            return value;
        }


        function defaultErrback(reason) {
            return reject(reason);
        }


        /**
         * @ngdoc
         * @name ng.$q#all
         * @methodOf ng.$q
         * @description
         * Combines multiple promises into a single promise that is resolved when all of the input
         * promises are resolved.
         *
         * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.
         * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,
         *   each value corresponding to the promise at the same index/key in the `promises` array/hash. If any of
         *   the promises is resolved with a rejection, this resulting promise will be resolved with the
         *   same rejection.
         */
        function all(promises) {
            var deferred = defer(),
                counter = 0,
                results = isArray(promises) ? [] : {};

            forEach(promises, function(promise, key) {
                counter++;
                ref(promise).then(function(value) {
                    if (results.hasOwnProperty(key)) return;
                    results[key] = value;
                    if (!(--counter)) deferred.resolve(results);
                }, function(reason) {
                    if (results.hasOwnProperty(key)) return;
                    deferred.reject(reason);
                });
            });

            if (counter === 0) {
                deferred.resolve(results);
            }

            return deferred.promise;
        }

        return {
            defer: defer,
            reject: reject,
            when: when,
            all: all
        };
    }

    /**
     * @ngdoc object
     * @name ng.$routeProvider
     * @function
     *
     * @description
     *
     * Used for configuring routes. See {@link ng.$route $route} for an example.
     */
    function $RouteProvider(){
        var routes = {};

        /**
         * @ngdoc method
         * @name ng.$routeProvider#when
         * @methodOf ng.$routeProvider
         *
         * @param {string} path Route path (matched against `$location.path`). If `$location.path`
         *    contains redundant trailing slash or is missing one, the route will still match and the
         *    `$location.path` will be updated to add or drop the trailing slash to exactly match the
         *    route definition.
         *
         *      * `path` can contain named groups starting with a colon (`:name`). All characters up
         *        to the next slash are matched and stored in `$routeParams` under the given `name`
         *        when the route matches.
         *      * `path` can contain named groups starting with a star (`*name`). All characters are
         *        eagerly stored in `$routeParams` under the given `name` when the route matches.
         *
         *    For example, routes like `/color/:color/largecode/*largecode/edit` will match
         *    `/color/brown/largecode/code/with/slashs/edit` and extract:
         *
         *      * `color: brown`
         *      * `largecode: code/with/slashs`.
         *
         *
         * @param {Object} route Mapping information to be assigned to `$route.current` on route
         *    match.
         *
         *    Object properties:
         *
         *    - `controller` â€“ `{(string|function()=}` â€“ Controller fn that should be associated with newly
         *      created scope or the name of a {@link angular.Module#controller registered controller}
         *      if passed as a string.
         *    - `controllerAs` â€“ `{string=}` â€“ A controller alias name. If present the controller will be
         *      published to scope under the `controllerAs` name.
         *    - `template` â€“ `{string=|function()=}` â€“ html template as a string or function that returns
         *      an html template as a string which should be used by {@link ng.directive:ngView ngView} or
         *      {@link ng.directive:ngInclude ngInclude} directives.
         *      This property takes precedence over `templateUrl`.
         *
         *      If `template` is a function, it will be called with the following parameters:
         *
         *      - `{Array.<Object>}` - route parameters extracted from the current
         *        `$location.path()` by applying the current route
         *
         *    - `templateUrl` â€“ `{string=|function()=}` â€“ path or function that returns a path to an html
         *      template that should be used by {@link ng.directive:ngView ngView}.
         *
         *      If `templateUrl` is a function, it will be called with the following parameters:
         *
         *      - `{Array.<Object>}` - route parameters extracted from the current
         *        `$location.path()` by applying the current route
         *
         *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should
         *      be injected into the controller. If any of these dependencies are promises, they will be
         *      resolved and converted to a value before the controller is instantiated and the
         *      `$routeChangeSuccess` event is fired. The map object is:
         *
         *      - `key` â€“ `{string}`: a name of a dependency to be injected into the controller.
         *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.
         *        Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}
         *        and the return value is treated as the dependency. If the result is a promise, it is resolved
         *        before its value is injected into the controller.
         *
         *    - `redirectTo` â€“ {(string|function())=} â€“ value to update
         *      {@link ng.$location $location} path with and trigger route redirection.
         *
         *      If `redirectTo` is a function, it will be called with the following parameters:
         *
         *      - `{Object.<string>}` - route parameters extracted from the current
         *        `$location.path()` by applying the current route templateUrl.
         *      - `{string}` - current `$location.path()`
         *      - `{Object}` - current `$location.search()`
         *
         *      The custom `redirectTo` function is expected to return a string which will be used
         *      to update `$location.path()` and `$location.search()`.
         *
         *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()
         *    changes.
         *
         *      If the option is set to `false` and url in the browser changes, then
         *      `$routeUpdate` event is broadcasted on the root scope.
         *
         *    - `[caseInsensitiveMatch=false]` - {boolean=} - match routes without being case sensitive
         *
         *      If the option is set to `true`, then the particular route can be matched without being
         *      case sensitive
         *
         * @returns {Object} self
         *
         * @description
         * Adds a new route definition to the `$route` service.
         */
        this.when = function(path, route) {
            routes[path] = extend({reloadOnSearch: true, caseInsensitiveMatch: false}, route);

            // create redirection for trailing slashes
            if (path) {
                var redirectPath = (path[path.length-1] == '/')
                    ? path.substr(0, path.length-1)
                    : path +'/';

                routes[redirectPath] = {redirectTo: path};
            }

            return this;
        };

        /**
         * @ngdoc method
         * @name ng.$routeProvider#otherwise
         * @methodOf ng.$routeProvider
         *
         * @description
         * Sets route definition that will be used on route change when no other route definition
         * is matched.
         *
         * @param {Object} params Mapping information to be assigned to `$route.current`.
         * @returns {Object} self
         */
        this.otherwise = function(params) {
            this.when(null, params);
            return this;
        };


        this.$get = ['$rootScope', '$location', '$routeParams', '$q', '$injector', '$http', '$templateCache',
            function( $rootScope,   $location,   $routeParams,   $q,   $injector,   $http,   $templateCache) {

                /**
                 * @ngdoc object
                 * @name ng.$route
                 * @requires $location
                 * @requires $routeParams
                 *
                 * @property {Object} current Reference to the current route definition.
                 * The route definition contains:
                 *
                 *   - `controller`: The controller constructor as define in route definition.
                 *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for
                 *     controller instantiation. The `locals` contain
                 *     the resolved values of the `resolve` map. Additionally the `locals` also contain:
                 *
                 *     - `$scope` - The current route scope.
                 *     - `$template` - The current route template HTML.
                 *
                 * @property {Array.<Object>} routes Array of all configured routes.
                 *
                 * @description
                 * Is used for deep-linking URLs to controllers and views (HTML partials).
                 * It watches `$location.url()` and tries to map the path to an existing route definition.
                 *
                 * You can define routes through {@link ng.$routeProvider $routeProvider}'s API.
                 *
                 * The `$route` service is typically used in conjunction with {@link ng.directive:ngView ngView}
                 * directive and the {@link ng.$routeParams $routeParams} service.
                 *
                 * @example
                 This example shows how changing the URL hash causes the `$route` to match a route against the
                 URL, and the `ngView` pulls in the partial.

                 Note that this example is using {@link ng.directive:script inlined templates}
                 to get it working on jsfiddle as well.

                 <example module="ngView">
                 <file name="index.html">
                 <div ng-controller="MainCntl">
                 Choose:
                 <a href="Book/Moby">Moby</a> |
                 <a href="Book/Moby/ch/1">Moby: Ch1</a> |
                 <a href="Book/Gatsby">Gatsby</a> |
                 <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
                 <a href="Book/Scarlet">Scarlet Letter</a><br/>

                 <div ng-view></div>
                 <hr />

                 <pre>$location.path() = {{$location.path()}}</pre>
                 <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>
                 <pre>$route.current.params = {{$route.current.params}}</pre>
                 <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>
                 <pre>$routeParams = {{$routeParams}}</pre>
                 </div>
                 </file>

                 <file name="book.html">
                 controller: {{name}}<br />
                 Book Id: {{params.bookId}}<br />
                 </file>

                 <file name="chapter.html">
                 controller: {{name}}<br />
                 Book Id: {{params.bookId}}<br />
                 Chapter Id: {{params.chapterId}}
                 </file>

                 <file name="script.js">
                 angular.module('ngView', [], function($routeProvider, $locationProvider) {
           $routeProvider.when('/Book/:bookId', {
             templateUrl: 'book.html',
             controller: BookCntl,
             resolve: {
               // I will cause a 1 second delay
               delay: function($q, $timeout) {
                 var delay = $q.defer();
                 $timeout(delay.resolve, 1000);
                 return delay.promise;
               }
             }
           });
           $routeProvider.when('/Book/:bookId/ch/:chapterId', {
             templateUrl: 'chapter.html',
             controller: ChapterCntl
           });

           // configure html5 to get links working on jsfiddle
           $locationProvider.html5Mode(true);
         });

                 function MainCntl($scope, $route, $routeParams, $location) {
           $scope.$route = $route;
           $scope.$location = $location;
           $scope.$routeParams = $routeParams;
         }

                 function BookCntl($scope, $routeParams) {
           $scope.name = "BookCntl";
           $scope.params = $routeParams;
         }

                 function ChapterCntl($scope, $routeParams) {
           $scope.name = "ChapterCntl";
           $scope.params = $routeParams;
         }
                 </file>

                 <file name="scenario.js">
                 it('should load and compile correct template', function() {
           element('a:contains("Moby: Ch1")').click();
           var content = element('.doc-example-live [ng-view]').text();
           expect(content).toMatch(/controller\: ChapterCntl/);
           expect(content).toMatch(/Book Id\: Moby/);
           expect(content).toMatch(/Chapter Id\: 1/);

           element('a:contains("Scarlet")').click();
           sleep(2); // promises are not part of scenario waiting
           content = element('.doc-example-live [ng-view]').text();
           expect(content).toMatch(/controller\: BookCntl/);
           expect(content).toMatch(/Book Id\: Scarlet/);
         });
                 </file>
                 </example>
                 */

                /**
                 * @ngdoc event
                 * @name ng.$route#$routeChangeStart
                 * @eventOf ng.$route
                 * @eventType broadcast on root scope
                 * @description
                 * Broadcasted before a route change. At this  point the route services starts
                 * resolving all of the dependencies needed for the route change to occurs.
                 * Typically this involves fetching the view template as well as any dependencies
                 * defined in `resolve` route property. Once  all of the dependencies are resolved
                 * `$routeChangeSuccess` is fired.
                 *
                 * @param {Route} next Future route information.
                 * @param {Route} current Current route information.
                 */

                /**
                 * @ngdoc event
                 * @name ng.$route#$routeChangeSuccess
                 * @eventOf ng.$route
                 * @eventType broadcast on root scope
                 * @description
                 * Broadcasted after a route dependencies are resolved.
                 * {@link ng.directive:ngView ngView} listens for the directive
                 * to instantiate the controller and render the view.
                 *
                 * @param {Object} angularEvent Synthetic event object.
                 * @param {Route} current Current route information.
                 * @param {Route|Undefined} previous Previous route information, or undefined if current is first route entered.
                 */

                /**
                 * @ngdoc event
                 * @name ng.$route#$routeChangeError
                 * @eventOf ng.$route
                 * @eventType broadcast on root scope
                 * @description
                 * Broadcasted if any of the resolve promises are rejected.
                 *
                 * @param {Route} current Current route information.
                 * @param {Route} previous Previous route information.
                 * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.
                 */

                /**
                 * @ngdoc event
                 * @name ng.$route#$routeUpdate
                 * @eventOf ng.$route
                 * @eventType broadcast on root scope
                 * @description
                 *
                 * The `reloadOnSearch` property has been set to false, and we are reusing the same
                 * instance of the Controller.
                 */

                var forceReload = false,
                    $route = {
                        routes: routes,

                        /**
                         * @ngdoc method
                         * @name ng.$route#reload
                         * @methodOf ng.$route
                         *
                         * @description
                         * Causes `$route` service to reload the current route even if
                         * {@link ng.$location $location} hasn't changed.
                         *
                         * As a result of that, {@link ng.directive:ngView ngView}
                         * creates new scope, reinstantiates the controller.
                         */
                        reload: function() {
                            forceReload = true;
                            $rootScope.$evalAsync(updateRoute);
                        }
                    };

                $rootScope.$on('$locationChangeSuccess', updateRoute);

                return $route;

                /////////////////////////////////////////////////////

                /**
                 * @param on {string} current url
                 * @param when {string} route when template to match the url against
                 * @param whenProperties {Object} properties to define when's matching behavior
                 * @return {?Object}
                 */
                function switchRouteMatcher(on, when, whenProperties) {
                    // TODO(i): this code is convoluted and inefficient, we should construct the route matching
                    //   regex only once and then reuse it

                    // Escape regexp special characters.
                    when = '^' + when.replace(/[-\/\\^$:*+?.()|[\]{}]/g, "\\$&") + '$';

                    var regex = '',
                        params = [],
                        dst = {};

                    var re = /\\([:*])(\w+)/g,
                        paramMatch,
                        lastMatchedIndex = 0;

                    while ((paramMatch = re.exec(when)) !== null) {
                        // Find each :param in `when` and replace it with a capturing group.
                        // Append all other sections of when unchanged.
                        regex += when.slice(lastMatchedIndex, paramMatch.index);
                        switch(paramMatch[1]) {
                            case ':':
                                regex += '([^\\/]*)';
                                break;
                            case '*':
                                regex += '(.*)';
                                break;
                        }
                        params.push(paramMatch[2]);
                        lastMatchedIndex = re.lastIndex;
                    }
                    // Append trailing path part.
                    regex += when.substr(lastMatchedIndex);

                    var match = on.match(new RegExp(regex, whenProperties.caseInsensitiveMatch ? 'i' : ''));
                    if (match) {
                        forEach(params, function(name, index) {
                            dst[name] = match[index + 1];
                        });
                    }
                    return match ? dst : null;
                }

                function updateRoute() {
                    var next = parseRoute(),
                        last = $route.current;

                    if (next && last && next.$$route === last.$$route
                        && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {
                        last.params = next.params;
                        copy(last.params, $routeParams);
                        $rootScope.$broadcast('$routeUpdate', last);
                    } else if (next || last) {
                        forceReload = false;
                        $rootScope.$broadcast('$routeChangeStart', next, last);
                        $route.current = next;
                        if (next) {
                            if (next.redirectTo) {
                                if (isString(next.redirectTo)) {
                                    $location.path(interpolate(next.redirectTo, next.params)).search(next.params)
                                        .replace();
                                } else {
                                    $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))
                                        .replace();
                                }
                            }
                        }

                        $q.when(next).
                            then(function() {
                                if (next) {
                                    var locals = extend({}, next.resolve),
                                        template;

                                    forEach(locals, function(value, key) {
                                        locals[key] = isString(value) ? $injector.get(value) : $injector.invoke(value);
                                    });

                                    if (isDefined(template = next.template)) {
                                        if (isFunction(template)) {
                                            template = template(next.params);
                                        }
                                    } else if (isDefined(template = next.templateUrl)) {
                                        if (isFunction(template)) {
                                            template = template(next.params);
                                        }
                                        if (isDefined(template)) {
                                            next.loadedTemplateUrl = template;
                                            template = $http.get(template, {cache: $templateCache}).
                                                then(function(response) { return response.data; });
                                        }
                                    }
                                    if (isDefined(template)) {
                                        locals['$template'] = template;
                                    }
                                    return $q.all(locals);
                                }
                            }).
                            // after route change
                            then(function(locals) {
                                if (next == $route.current) {
                                    if (next) {
                                        next.locals = locals;
                                        copy(next.params, $routeParams);
                                    }
                                    $rootScope.$broadcast('$routeChangeSuccess', next, last);
                                }
                            }, function(error) {
                                if (next == $route.current) {
                                    $rootScope.$broadcast('$routeChangeError', next, last, error);
                                }
                            });
                    }
                }


                /**
                 * @returns the current active route, by matching it against the URL
                 */
                function parseRoute() {
                    // Match a route
                    var params, match;
                    forEach(routes, function(route, path) {
                        if (!match && (params = switchRouteMatcher($location.path(), path, route))) {
                            match = inherit(route, {
                                params: extend({}, $location.search(), params),
                                pathParams: params});
                            match.$$route = route;
                        }
                    });
                    // No route matched; fallback to "otherwise" route
                    return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});
                }

                /**
                 * @returns interpolation of the redirect path with the parameters
                 */
                function interpolate(string, params) {
                    var result = [];
                    forEach((string||'').split(':'), function(segment, i) {
                        if (i == 0) {
                            result.push(segment);
                        } else {
                            var segmentMatch = segment.match(/(\w+)(.*)/);
                            var key = segmentMatch[1];
                            result.push(params[key]);
                            result.push(segmentMatch[2] || '');
                            delete params[key];
                        }
                    });
                    return result.join('');
                }
            }];
    }

    /**
     * @ngdoc object
     * @name ng.$routeParams
     * @requires $route
     *
     * @description
     * Current set of route parameters. The route parameters are a combination of the
     * {@link ng.$location $location} `search()`, and `path()`. The `path` parameters
     * are extracted when the {@link ng.$route $route} path is matched.
     *
     * In case of parameter name collision, `path` params take precedence over `search` params.
     *
     * The service guarantees that the identity of the `$routeParams` object will remain unchanged
     * (but its properties will likely change) even when a route change occurs.
     *
     * @example
     * <pre>
     *  // Given:
     *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby
     *  // Route: /Chapter/:chapterId/Section/:sectionId
     *  //
     *  // Then
     *  $routeParams ==> {chapterId:1, sectionId:2, search:'moby'}
     * </pre>
     */
    function $RouteParamsProvider() {
        this.$get = valueFn({});
    }

    /**
     * DESIGN NOTES
     *
     * The design decisions behind the scope are heavily favored for speed and memory consumption.
     *
     * The typical use of scope is to watch the expressions, which most of the time return the same
     * value as last time so we optimize the operation.
     *
     * Closures construction is expensive in terms of speed as well as memory:
     *   - No closures, instead use prototypical inheritance for API
     *   - Internal state needs to be stored on scope directly, which means that private state is
     *     exposed as $$____ properties
     *
     * Loop operations are optimized by using while(count--) { ... }
     *   - this means that in order to keep the same order of execution as addition we have to add
     *     items to the array at the beginning (shift) instead of at the end (push)
     *
     * Child scopes are created and removed often
     *   - Using an array would be slow since inserts in middle are expensive so we use linked list
     *
     * There are few watches then a lot of observers. This is why you don't want the observer to be
     * implemented in the same way as watch. Watch requires return of initialization function which
     * are expensive to construct.
     */


    /**
     * @ngdoc object
     * @name ng.$rootScopeProvider
     * @description
     *
     * Provider for the $rootScope service.
     */

    /**
     * @ngdoc function
     * @name ng.$rootScopeProvider#digestTtl
     * @methodOf ng.$rootScopeProvider
     * @description
     *
     * Sets the number of digest iterations the scope should attempt to execute before giving up and
     * assuming that the model is unstable.
     *
     * The current default is 10 iterations.
     *
     * @param {number} limit The number of digest iterations.
     */


    /**
     * @ngdoc object
     * @name ng.$rootScope
     * @description
     *
     * Every application has a single root {@link ng.$rootScope.Scope scope}.
     * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide
     * event processing life-cycle. See {@link guide/scope developer guide on scopes}.
     */
    function $RootScopeProvider(){
        var TTL = 10;

        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        };

        this.$get = ['$injector', '$exceptionHandler', '$parse',
            function( $injector,   $exceptionHandler,   $parse) {

                /**
                 * @ngdoc function
                 * @name ng.$rootScope.Scope
                 *
                 * @description
                 * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
                 * {@link AUTO.$injector $injector}. Child scopes are created using the
                 * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when
                 * compiled HTML template is executed.)
                 *
                 * Here is a simple scope snippet to show how you can interact with the scope.
                 * <pre>
                 * <file src="./test/ng/rootScopeSpec.js" tag="docs1" />
                 * </pre>
                 *
                 * # Inheritance
                 * A scope can inherit from a parent scope, as in this example:
                 * <pre>
                 var parent = $rootScope;
                 var child = parent.$new();

                 parent.salutation = "Hello";
                 child.name = "World";
                 expect(child.salutation).toEqual('Hello');

                 child.salutation = "Welcome";
                 expect(child.salutation).toEqual('Welcome');
                 expect(parent.salutation).toEqual('Hello');
                 * </pre>
                 *
                 *
                 * @param {Object.<string, function()>=} providers Map of service factory which need to be provided
                 *     for the current scope. Defaults to {@link ng}.
                 * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should
                 *     append/override services provided by `providers`. This is handy when unit-testing and having
                 *     the need to override a default service.
                 * @returns {Object} Newly created scope.
                 *
                 */
                function Scope() {
                    this.$id = nextUid();
                    this.$$phase = this.$parent = this.$$watchers =
                        this.$$nextSibling = this.$$prevSibling =
                            this.$$childHead = this.$$childTail = null;
                    this['this'] = this.$root =  this;
                    this.$$destroyed = false;
                    this.$$asyncQueue = [];
                    this.$$listeners = {};
                    this.$$isolateBindings = {};
                }

                /**
                 * @ngdoc property
                 * @name ng.$rootScope.Scope#$id
                 * @propertyOf ng.$rootScope.Scope
                 * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for
                 *   debugging.
                 */


                Scope.prototype = {
                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$new
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Creates a new child {@link ng.$rootScope.Scope scope}.
                     *
                     * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and
                     * {@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope
                     * hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.
                     *
                     * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for
                     * the scope and its child scopes to be permanently detached from the parent and thus stop
                     * participating in model change detection and listener notification by invoking.
                     *
                     * @param {boolean} isolate if true then the scope does not prototypically inherit from the
                     *         parent scope. The scope is isolated, as it can not see parent scope properties.
                     *         When creating widgets it is useful for the widget to not accidentally read parent
                     *         state.
                     *
                     * @returns {Object} The newly created child scope.
                     *
                     */
                    $new: function(isolate) {
                        var Child,
                            child;

                        if (isFunction(isolate)) {
                            // TODO: remove at some point
                            throw Error('API-CHANGE: Use $controller to instantiate controllers.');
                        }
                        if (isolate) {
                            child = new Scope();
                            child.$root = this.$root;
                        } else {
                            Child = function() {}; // should be anonymous; This is so that when the minifier munges
                            // the name it does not become random set of chars. These will then show up as class
                            // name in the debugger.
                            Child.prototype = this;
                            child = new Child();
                            child.$id = nextUid();
                        }
                        child['this'] = child;
                        child.$$listeners = {};
                        child.$parent = this;
                        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
                        child.$$prevSibling = this.$$childTail;
                        if (this.$$childHead) {
                            this.$$childTail.$$nextSibling = child;
                            this.$$childTail = child;
                        } else {
                            this.$$childHead = this.$$childTail = child;
                        }
                        return child;
                    },

                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$watch
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Registers a `listener` callback to be executed whenever the `watchExpression` changes.
                     *
                     * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest $digest()} and
                     *   should return the value which will be watched. (Since {@link ng.$rootScope.Scope#$digest $digest()}
                     *   reruns when it detects changes the `watchExpression` can execute multiple times per
                     *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)
                     * - The `listener` is called only when the value from the current `watchExpression` and the
                     *   previous call to `watchExpression` are not equal (with the exception of the initial run,
                     *   see below). The inequality is determined according to
                     *   {@link angular.equals} function. To save the value of the object for later comparison, the
                     *   {@link angular.copy} function is used. It also means that watching complex options will
                     *   have adverse memory and performance implications.
                     * - The watch `listener` may change the model, which may trigger other `listener`s to fire. This
                     *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration
                     *   limit is 10 to prevent an infinite loop deadlock.
                     *
                     *
                     * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,
                     * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`
                     * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a change is
                     * detected, be prepared for multiple calls to your listener.)
                     *
                     * After a watcher is registered with the scope, the `listener` fn is called asynchronously
                     * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
                     * watcher. In rare cases, this is undesirable because the listener is called when the result
                     * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you
                     * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the
                     * listener was called due to initialization.
                     *
                     *
                     * # Example
                     * <pre>
                     // let's assume that scope was dependency injected as the $rootScope
                     var scope = $rootScope;
                     scope.name = 'misko';
                     scope.counter = 0;

                     expect(scope.counter).toEqual(0);
                     scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; });
                     expect(scope.counter).toEqual(0);

                     scope.$digest();
                     // no variable change
                     expect(scope.counter).toEqual(0);

                     scope.name = 'adam';
                     scope.$digest();
                     expect(scope.counter).toEqual(1);
                     * </pre>
                     *
                     *
                     *
                     * @param {(function()|string)} watchExpression Expression that is evaluated on each
                     *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a
                     *    call to the `listener`.
                     *
                     *    - `string`: Evaluated as {@link guide/expression expression}
                     *    - `function(scope)`: called with current `scope` as a parameter.
                     * @param {(function()|string)=} listener Callback called whenever the return value of
                     *   the `watchExpression` changes.
                     *
                     *    - `string`: Evaluated as {@link guide/expression expression}
                     *    - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.
                     *
                     * @param {boolean=} objectEquality Compare object for equality rather than for reference.
                     * @returns {function()} Returns a deregistration function for this listener.
                     */
                    $watch: function(watchExp, listener, objectEquality) {
                        var scope = this,
                            get = compileToFn(watchExp, 'watch'),
                            array = scope.$$watchers,
                            watcher = {
                                fn: listener,
                                last: initWatchVal,
                                get: get,
                                exp: watchExp,
                                eq: !!objectEquality
                            };

                        // in the case user pass string, we need to compile it, do we really need this ?
                        if (!isFunction(listener)) {
                            var listenFn = compileToFn(listener || noop, 'listener');
                            watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};
                        }

                        if (typeof watchExp == 'string' && get.constant) {
                            var originalFn = watcher.fn;
                            watcher.fn = function(newVal, oldVal, scope) {
                                originalFn.call(this, newVal, oldVal, scope);
                                arrayRemove(array, watcher);
                            };
                        }

                        if (!array) {
                            array = scope.$$watchers = [];
                        }
                        // we use unshift since we use a while loop in $digest for speed.
                        // the while loop reads in reverse order.
                        array.unshift(watcher);

                        return function() {
                            arrayRemove(array, watcher);
                        };
                    },


                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$watchCollection
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Shallow watches the properties of an object and fires whenever any of the properties change
                     * (for arrays this implies watching the array items, for object maps this implies watching the properties).
                     * If a change is detected the `listener` callback is fired.
                     *
                     * - The `obj` collection is observed via standard $watch operation and is examined on every call to $digest() to
                     *   see if any items have been added, removed, or moved.
                     * - The `listener` is called whenever anything within the `obj` has changed. Examples include adding new items
                     *   into the object or array, removing and moving items around.
                     *
                     *
                     * # Example
                     * <pre>
                     $scope.names = ['igor', 'matias', 'misko', 'james'];
                     $scope.dataCount = 4;

                     $scope.$watchCollection('names', function(newNames, oldNames) {
            $scope.dataCount = newNames.length;
          });

                     expect($scope.dataCount).toEqual(4);
                     $scope.$digest();

                     //still at 4 ... no changes
                     expect($scope.dataCount).toEqual(4);

                     $scope.names.pop();
                     $scope.$digest();

                     //now there's been a change
                     expect($scope.dataCount).toEqual(3);
                     * </pre>
                     *
                     *
                     * @param {string|Function(scope)} obj Evaluated as {@link guide/expression expression}. The expression value
                     *    should evaluate to an object or an array which is observed on each
                     *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the collection will trigger
                     *    a call to the `listener`.
                     *
                     * @param {function(newCollection, oldCollection, scope)} listener a callback function that is fired with both
                     *    the `newCollection` and `oldCollection` as parameters.
                     *    The `newCollection` object is the newly modified data obtained from the `obj` expression and the
                     *    `oldCollection` object is a copy of the former collection data.
                     *    The `scope` refers to the current scope.
                     *
                     * @returns {function()} Returns a de-registration function for this listener. When the de-registration function is executed
                     * then the internal watch operation is terminated.
                     */
                    $watchCollection: function(obj, listener) {
                        var self = this;
                        var oldValue;
                        var newValue;
                        var changeDetected = 0;
                        var objGetter = $parse(obj);
                        var internalArray = [];
                        var internalObject = {};
                        var oldLength = 0;

                        function $watchCollectionWatch() {
                            newValue = objGetter(self);
                            var newLength, key;

                            if (!isObject(newValue)) {
                                if (oldValue !== newValue) {
                                    oldValue = newValue;
                                    changeDetected++;
                                }
                            } else if (isArrayLike(newValue)) {
                                if (oldValue !== internalArray) {
                                    // we are transitioning from something which was not an array into array.
                                    oldValue = internalArray;
                                    oldLength = oldValue.length = 0;
                                    changeDetected++;
                                }

                                newLength = newValue.length;

                                if (oldLength !== newLength) {
                                    // if lengths do not match we need to trigger change notification
                                    changeDetected++;
                                    oldValue.length = oldLength = newLength;
                                }
                                // copy the items to oldValue and look for changes.
                                for (var i = 0; i < newLength; i++) {
                                    if (oldValue[i] !== newValue[i]) {
                                        changeDetected++;
                                        oldValue[i] = newValue[i];
                                    }
                                }
                            } else {
                                if (oldValue !== internalObject) {
                                    // we are transitioning from something which was not an object into object.
                                    oldValue = internalObject = {};
                                    oldLength = 0;
                                    changeDetected++;
                                }
                                // copy the items to oldValue and look for changes.
                                newLength = 0;
                                for (key in newValue) {
                                    if (newValue.hasOwnProperty(key)) {
                                        newLength++;
                                        if (oldValue.hasOwnProperty(key)) {
                                            if (oldValue[key] !== newValue[key]) {
                                                changeDetected++;
                                                oldValue[key] = newValue[key];
                                            }
                                        } else {
                                            oldLength++;
                                            oldValue[key] = newValue[key];
                                            changeDetected++;
                                        }
                                    }
                                }
                                if (oldLength > newLength) {
                                    // we used to have more keys, need to find them and destroy them.
                                    changeDetected++;
                                    for(key in oldValue) {
                                        if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {
                                            oldLength--;
                                            delete oldValue[key];
                                        }
                                    }
                                }
                            }
                            return changeDetected;
                        }

                        function $watchCollectionAction() {
                            listener(newValue, oldValue, self);
                        }

                        return this.$watch($watchCollectionWatch, $watchCollectionAction);
                    },

                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$digest
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and its children.
                     * Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the
                     * `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} until no more listeners are
                     * firing. This means that it is possible to get into an infinite loop. This function will throw
                     * `'Maximum iteration limit exceeded.'` if the number of iterations exceeds 10.
                     *
                     * Usually you don't call `$digest()` directly in
                     * {@link ng.directive:ngController controllers} or in
                     * {@link ng.$compileProvider#directive directives}.
                     * Instead a call to {@link ng.$rootScope.Scope#$apply $apply()} (typically from within a
                     * {@link ng.$compileProvider#directive directives}) will force a `$digest()`.
                     *
                     * If you want to be notified whenever `$digest()` is called,
                     * you can register a `watchExpression` function  with {@link ng.$rootScope.Scope#$watch $watch()}
                     * with no `listener`.
                     *
                     * You may have a need to call `$digest()` from within unit-tests, to simulate the scope
                     * life-cycle.
                     *
                     * # Example
                     * <pre>
                     var scope = ...;
                     scope.name = 'misko';
                     scope.counter = 0;

                     expect(scope.counter).toEqual(0);
                     scope.$watch('name', function(newValue, oldValue) {
             scope.counter = scope.counter + 1;
           });
                     expect(scope.counter).toEqual(0);

                     scope.$digest();
                     // no variable change
                     expect(scope.counter).toEqual(0);

                     scope.name = 'adam';
                     scope.$digest();
                     expect(scope.counter).toEqual(1);
                     * </pre>
                     *
                     */
                    $digest: function() {
                        var watch, value, last,
                            watchers,
                            asyncQueue = this.$$asyncQueue,
                            length,
                            dirty, ttl = TTL,
                            next, current, target = this,
                            watchLog = [],
                            logIdx, logMsg;

                        beginPhase('$digest');

                        do { // "while dirty" loop
                            dirty = false;
                            current = target;

                            while(asyncQueue.length) {
                                try {
                                    current.$eval(asyncQueue.shift());
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }

                            do { // "traverse the scopes" loop
                                if ((watchers = current.$$watchers)) {
                                    // process our watches
                                    length = watchers.length;
                                    while (length--) {
                                        try {
                                            watch = watchers[length];
                                            // Most common watches are on primitives, in which case we can short
                                            // circuit it with === operator, only when === fails do we use .equals
                                            if ((value = watch.get(current)) !== (last = watch.last) &&
                                                !(watch.eq
                                                    ? equals(value, last)
                                                    : (typeof value == 'number' && typeof last == 'number'
                                                    && isNaN(value) && isNaN(last)))) {
                                                dirty = true;
                                                watch.last = watch.eq ? copy(value) : value;
                                                watch.fn(value, ((last === initWatchVal) ? value : last), current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    logMsg = (isFunction(watch.exp))
                                                        ? 'fn: ' + (watch.exp.name || watch.exp.toString())
                                                        : watch.exp;
                                                    logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                                                    watchLog[logIdx].push(logMsg);
                                                }
                                            }
                                        } catch (e) {
                                            $exceptionHandler(e);
                                        }
                                    }
                                }

                                // Insanity Warning: scope depth-first traversal
                                // yes, this code is a bit crazy, but it works and we have tests to prove it!
                                // this piece should be kept in sync with the traversal in $broadcast
                                if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
                                    while(current !== target && !(next = current.$$nextSibling)) {
                                        current = current.$parent;
                                    }
                                }
                            } while ((current = next));

                            if(dirty && !(ttl--)) {
                                clearPhase();
                                throw Error(TTL + ' $digest() iterations reached. Aborting!\n' +
                                    'Watchers fired in the last 5 iterations: ' + toJson(watchLog));
                            }
                        } while (dirty || asyncQueue.length);

                        clearPhase();
                    },


                    /**
                     * @ngdoc event
                     * @name ng.$rootScope.Scope#$destroy
                     * @eventOf ng.$rootScope.Scope
                     * @eventType broadcast on scope being destroyed
                     *
                     * @description
                     * Broadcasted when a scope and its children are being destroyed.
                     */

                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$destroy
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Removes the current scope (and all of its children) from the parent scope. Removal implies
                     * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer
                     * propagate to the current scope and its children. Removal also implies that the current
                     * scope is eligible for garbage collection.
                     *
                     * The `$destroy()` is usually used by directives such as
                     * {@link ng.directive:ngRepeat ngRepeat} for managing the
                     * unrolling of the loop.
                     *
                     * Just before a scope is destroyed a `$destroy` event is broadcasted on this scope.
                     * Application code can register a `$destroy` event handler that will give it chance to
                     * perform any necessary cleanup.
                     */
                    $destroy: function() {
                        // we can't destroy the root scope or a scope that has been already destroyed
                        if ($rootScope == this || this.$$destroyed) return;
                        var parent = this.$parent;

                        this.$broadcast('$destroy');
                        this.$$destroyed = true;

                        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
                        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
                        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

                        // This is bogus code that works around Chrome's GC leak
                        // see: https://github.com/angular/angular.js/issues/1313#issuecomment-10378451
                        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
                            this.$$childTail = null;
                    },

                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$eval
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Executes the `expression` on the current scope returning the result. Any exceptions in the
                     * expression are propagated (uncaught). This is useful when evaluating Angular expressions.
                     *
                     * # Example
                     * <pre>
                     var scope = ng.$rootScope.Scope();
                     scope.a = 1;
                     scope.b = 2;

                     expect(scope.$eval('a+b')).toEqual(3);
                     expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
                     * </pre>
                     *
                     * @param {(string|function())=} expression An angular expression to be executed.
                     *
                     *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
                     *    - `function(scope)`: execute the function with the current `scope` parameter.
                     *
                     * @returns {*} The result of evaluating the expression.
                     */
                    $eval: function(expr, locals) {
                        return $parse(expr)(this, locals);
                    },

                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$evalAsync
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Executes the expression on the current scope at a later point in time.
                     *
                     * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:
                     *
                     *   - it will execute in the current script execution context (before any DOM rendering).
                     *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after
                     *     `expression` execution.
                     *
                     * Any exceptions from the execution of the expression are forwarded to the
                     * {@link ng.$exceptionHandler $exceptionHandler} service.
                     *
                     * @param {(string|function())=} expression An angular expression to be executed.
                     *
                     *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
                     *    - `function(scope)`: execute the function with the current `scope` parameter.
                     *
                     */
                    $evalAsync: function(expr) {
                        this.$$asyncQueue.push(expr);
                    },

                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$apply
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * `$apply()` is used to execute an expression in angular from outside of the angular framework.
                     * (For example from browser DOM events, setTimeout, XHR or third party libraries).
                     * Because we are calling into the angular framework we need to perform proper scope life-cycle
                     * of {@link ng.$exceptionHandler exception handling},
                     * {@link ng.$rootScope.Scope#$digest executing watches}.
                     *
                     * ## Life cycle
                     *
                     * # Pseudo-Code of `$apply()`
                     * <pre>
                     function $apply(expr) {
             try {
               return $eval(expr);
             } catch (e) {
               $exceptionHandler(e);
             } finally {
               $root.$digest();
             }
           }
                     * </pre>
                     *
                     *
                     * Scope's `$apply()` method transitions through the following stages:
                     *
                     * 1. The {@link guide/expression expression} is executed using the
                     *    {@link ng.$rootScope.Scope#$eval $eval()} method.
                     * 2. Any exceptions from the execution of the expression are forwarded to the
                     *    {@link ng.$exceptionHandler $exceptionHandler} service.
                     * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression
                     *    was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.
                     *
                     *
                     * @param {(string|function())=} exp An angular expression to be executed.
                     *
                     *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
                     *    - `function(scope)`: execute the function with current `scope` parameter.
                     *
                     * @returns {*} The result of evaluating the expression.
                     */
                    $apply: function(expr) {
                        try {
                            beginPhase('$apply');
                            return this.$eval(expr);
                        } catch (e) {
                            $exceptionHandler(e);
                        } finally {
                            clearPhase();
                            try {
                                $rootScope.$digest();
                            } catch (e) {
                                $exceptionHandler(e);
                                throw e;
                            }
                        }
                    },

                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$on
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for discussion of
                     * event life cycle.
                     *
                     * The event listener function format is: `function(event, args...)`. The `event` object
                     * passed into the listener has the following attributes:
                     *
                     *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or `$broadcast`-ed.
                     *   - `currentScope` - `{Scope}`: the current scope which is handling the event.
                     *   - `name` - `{string}`: Name of the event.
                     *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel further event
                     *     propagation (available only for events that were `$emit`-ed).
                     *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag to true.
                     *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.
                     *
                     * @param {string} name Event name to listen on.
                     * @param {function(event, args...)} listener Function to call when the event is emitted.
                     * @returns {function()} Returns a deregistration function for this listener.
                     */
                    $on: function(name, listener) {
                        var namedListeners = this.$$listeners[name];
                        if (!namedListeners) {
                            this.$$listeners[name] = namedListeners = [];
                        }
                        namedListeners.push(listener);

                        return function() {
                            namedListeners[indexOf(namedListeners, listener)] = null;
                        };
                    },


                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$emit
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Dispatches an event `name` upwards through the scope hierarchy notifying the
                     * registered {@link ng.$rootScope.Scope#$on} listeners.
                     *
                     * The event life cycle starts at the scope on which `$emit` was called. All
                     * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.
                     * Afterwards, the event traverses upwards toward the root scope and calls all registered
                     * listeners along the way. The event will stop propagating if one of the listeners cancels it.
                     *
                     * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
                     * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
                     *
                     * @param {string} name Event name to emit.
                     * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
                     * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
                     */
                    $emit: function(name, args) {
                        var empty = [],
                            namedListeners,
                            scope = this,
                            stopPropagation = false,
                            event = {
                                name: name,
                                targetScope: scope,
                                stopPropagation: function() {stopPropagation = true;},
                                preventDefault: function() {
                                    event.defaultPrevented = true;
                                },
                                defaultPrevented: false
                            },
                            listenerArgs = concat([event], arguments, 1),
                            i, length;

                        do {
                            namedListeners = scope.$$listeners[name] || empty;
                            event.currentScope = scope;
                            for (i=0, length=namedListeners.length; i<length; i++) {

                                // if listeners were deregistered, defragment the array
                                if (!namedListeners[i]) {
                                    namedListeners.splice(i, 1);
                                    i--;
                                    length--;
                                    continue;
                                }
                                try {
                                    namedListeners[i].apply(null, listenerArgs);
                                    if (stopPropagation) return event;
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                            //traverse upwards
                            scope = scope.$parent;
                        } while (scope);

                        return event;
                    },


                    /**
                     * @ngdoc function
                     * @name ng.$rootScope.Scope#$broadcast
                     * @methodOf ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
                     * registered {@link ng.$rootScope.Scope#$on} listeners.
                     *
                     * The event life cycle starts at the scope on which `$broadcast` was called. All
                     * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.
                     * Afterwards, the event propagates to all direct and indirect scopes of the current scope and
                     * calls all registered listeners along the way. The event cannot be canceled.
                     *
                     * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
                     * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
                     *
                     * @param {string} name Event name to broadcast.
                     * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
                     * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
                     */
                    $broadcast: function(name, args) {
                        var target = this,
                            current = target,
                            next = target,
                            event = {
                                name: name,
                                targetScope: target,
                                preventDefault: function() {
                                    event.defaultPrevented = true;
                                },
                                defaultPrevented: false
                            },
                            listenerArgs = concat([event], arguments, 1),
                            listeners, i, length;

                        //down while you can, then up and next sibling or up and next sibling until back at root
                        do {
                            current = next;
                            event.currentScope = current;
                            listeners = current.$$listeners[name] || [];
                            for (i=0, length = listeners.length; i<length; i++) {
                                // if listeners were deregistered, defragment the array
                                if (!listeners[i]) {
                                    listeners.splice(i, 1);
                                    i--;
                                    length--;
                                    continue;
                                }

                                try {
                                    listeners[i].apply(null, listenerArgs);
                                } catch(e) {
                                    $exceptionHandler(e);
                                }
                            }

                            // Insanity Warning: scope depth-first traversal
                            // yes, this code is a bit crazy, but it works and we have tests to prove it!
                            // this piece should be kept in sync with the traversal in $digest
                            if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
                                while(current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while ((current = next));

                        return event;
                    }
                };

                var $rootScope = new Scope();

                return $rootScope;


                function beginPhase(phase) {
                    if ($rootScope.$$phase) {
                        throw Error($rootScope.$$phase + ' already in progress');
                    }

                    $rootScope.$$phase = phase;
                }

                function clearPhase() {
                    $rootScope.$$phase = null;
                }

                function compileToFn(exp, name) {
                    var fn = $parse(exp);
                    assertArgFn(fn, name);
                    return fn;
                }

                /**
                 * function used as an initial value for watchers.
                 * because it's unique we can easily tell it apart from other values
                 */
                function initWatchVal() {}
            }];
    }

    /**
     * !!! This is an undocumented "private" service !!!
     *
     * @name ng.$sniffer
     * @requires $window
     * @requires $document
     *
     * @property {boolean} history Does the browser support html5 history api ?
     * @property {boolean} hashchange Does the browser support hashchange event ?
     * @property {boolean} transitions Does the browser support CSS transition events ?
     * @property {boolean} animations Does the browser support CSS animation events ?
     *
     * @description
     * This is very simple implementation of testing browser's features.
     */
    function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
            var eventSupport = {},
                android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
                document = $document[0] || {},
                vendorPrefix,
                vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
                bodyStyle = document.body && document.body.style,
                transitions = false,
                animations = false,
                match;

            if (bodyStyle) {
                for(var prop in bodyStyle) {
                    if(match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0];
                        vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                        break;
                    }
                }
                transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
                animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            }


            return {
                // Android has history.pushState, but it does not update location correctly
                // so let's not use the history API at all.
                // http://code.google.com/p/android/issues/detail?id=17471
                // https://github.com/angular/angular.js/issues/904
                history: !!($window.history && $window.history.pushState && !(android < 4)),
                hashchange: 'onhashchange' in $window &&
                    // IE8 compatible mode lies
                    (!document.documentMode || document.documentMode > 7),
                hasEvent: function(event) {
                    // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
                    // it. In particular the event is not fired when backspace or delete key are pressed or
                    // when cut operation is performed.
                    if (event == 'input' && msie == 9) return false;

                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement('div');
                        eventSupport[event] = 'on' + event in divElm;
                    }

                    return eventSupport[event];
                },
                csp: document.securityPolicy ? document.securityPolicy.isActive : false,
                vendorPrefix: vendorPrefix,
                transitions : transitions,
                animations : animations
            };
        }];
    }

    /**
     * @ngdoc object
     * @name ng.$window
     *
     * @description
     * A reference to the browser's `window` object. While `window`
     * is globally available in JavaScript, it causes testability problems, because
     * it is a global variable. In angular we always refer to it through the
     * `$window` service, so it may be overridden, removed or mocked for testing.
     *
     * All expressions are evaluated with respect to current scope so they don't
     * suffer from window globality.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope, $window) {
           $scope.$window = $window;
           $scope.greeting = 'Hello, World!';
         }
     </script>
     <div ng-controller="Ctrl">
     <input type="text" ng-model="greeting" />
     <button ng-click="$window.alert(greeting)">ALERT</button>
     </div>
     </doc:source>
     <doc:scenario>
     it('should display the greeting in the input box', function() {
       input('greeting').enter('Hello, E2E Tests');
       // If we click the button it will block the test runner
       // element(':button').click();
      });
     </doc:scenario>
     </doc:example>
     */
    function $WindowProvider(){
        this.$get = valueFn(window);
    }

    /**
     * Parse headers into key value object
     *
     * @param {string} headers Raw headers as a string
     * @returns {Object} Parsed headers as key value object
     */
    function parseHeaders(headers) {
        var parsed = {}, key, val, i;

        if (!headers) return parsed;

        forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            key = lowercase(trim(line.substr(0, i)));
            val = trim(line.substr(i + 1));

            if (key) {
                if (parsed[key]) {
                    parsed[key] += ', ' + val;
                } else {
                    parsed[key] = val;
                }
            }
        });

        return parsed;
    }


    var IS_SAME_DOMAIN_URL_MATCH = /^(([^:]+):)?\/\/(\w+:{0,1}\w*@)?([\w\.-]*)?(:([0-9]+))?(.*)$/;


    /**
     * Parse a request and location URL and determine whether this is a same-domain request.
     *
     * @param {string} requestUrl The url of the request.
     * @param {string} locationUrl The current browser location url.
     * @returns {boolean} Whether the request is for the same domain.
     */
    function isSameDomain(requestUrl, locationUrl) {
        var match = IS_SAME_DOMAIN_URL_MATCH.exec(requestUrl);
        // if requestUrl is relative, the regex does not match.
        if (match == null) return true;

        var domain1 = {
            protocol: match[2],
            host: match[4],
            port: int(match[6]) || DEFAULT_PORTS[match[2]] || null,
            // IE8 sets unmatched groups to '' instead of undefined.
            relativeProtocol: match[2] === undefined || match[2] === ''
        };

        match = SERVER_MATCH.exec(locationUrl);
        var domain2 = {
            protocol: match[1],
            host: match[3],
            port: int(match[5]) || DEFAULT_PORTS[match[1]] || null
        };

        return (domain1.protocol == domain2.protocol || domain1.relativeProtocol) &&
            domain1.host == domain2.host &&
            (domain1.port == domain2.port || (domain1.relativeProtocol &&
                domain2.port == DEFAULT_PORTS[domain2.protocol]));
    }


    /**
     * Returns a function that provides access to parsed headers.
     *
     * Headers are lazy parsed when first requested.
     * @see parseHeaders
     *
     * @param {(string|Object)} headers Headers to provide access to.
     * @returns {function(string=)} Returns a getter function which if called with:
     *
     *   - if called with single an argument returns a single header value or null
     *   - if called with no arguments returns an object containing all headers.
     */
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;

        return function(name) {
            if (!headersObj) headersObj =  parseHeaders(headers);

            if (name) {
                return headersObj[lowercase(name)] || null;
            }

            return headersObj;
        };
    }


    /**
     * Chain all given functions
     *
     * This function is used for both request and response transforming
     *
     * @param {*} data Data to transform.
     * @param {function(string=)} headers Http headers getter fn.
     * @param {(function|Array.<function>)} fns Function or an array of functions.
     * @returns {*} Transformed data.
     */
    function transformData(data, headers, fns) {
        if (isFunction(fns))
            return fns(data, headers);

        forEach(fns, function(fn) {
            data = fn(data, headers);
        });

        return data;
    }


    function isSuccess(status) {
        return 200 <= status && status < 300;
    }


    function $HttpProvider() {
        var JSON_START = /^\s*(\[|\{[^\{])/,
            JSON_END = /[\}\]]\s*$/,
            PROTECTION_PREFIX = /^\)\]\}',?\n/,
            CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': 'application/json;charset=utf-8'};

        var defaults = this.defaults = {
            // transform incoming response data
            transformResponse: [function(data) {
                if (isString(data)) {
                    // strip json vulnerability protection prefix
                    data = data.replace(PROTECTION_PREFIX, '');
                    if (JSON_START.test(data) && JSON_END.test(data))
                        data = fromJson(data, true);
                }
                return data;
            }],

            // transform outgoing request data
            transformRequest: [function(d) {
                return isObject(d) && !isFile(d) ? toJson(d) : d;
            }],

            // default headers
            headers: {
                common: {
                    'Accept': 'application/json, text/plain, */*'
                },
                post:   CONTENT_TYPE_APPLICATION_JSON,
                put:    CONTENT_TYPE_APPLICATION_JSON,
                patch:  CONTENT_TYPE_APPLICATION_JSON
            },

            xsrfCookieName: 'XSRF-TOKEN',
            xsrfHeaderName: 'X-XSRF-TOKEN'
        };

        /**
         * Are order by request. I.E. they are applied in the same order as
         * array on request, but revers order on response.
         */
        var interceptorFactories = this.interceptors = [];
        /**
         * For historical reasons, response interceptors ordered by the order in which
         * they are applied to response. (This is in revers to interceptorFactories)
         */
        var responseInterceptorFactories = this.responseInterceptors = [];

        this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',
            function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {

                var defaultCache = $cacheFactory('$http');

                /**
                 * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
                 * The reversal is needed so that we can build up the interception chain around the
                 * server request.
                 */
                var reversedInterceptors = [];

                forEach(interceptorFactories, function(interceptorFactory) {
                    reversedInterceptors.unshift(isString(interceptorFactory)
                        ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
                });

                forEach(responseInterceptorFactories, function(interceptorFactory, index) {
                    var responseFn = isString(interceptorFactory)
                        ? $injector.get(interceptorFactory)
                        : $injector.invoke(interceptorFactory);

                    /**
                     * Response interceptors go before "around" interceptors (no real reason, just
                     * had to pick one.) But they are already revesed, so we can't use unshift, hence
                     * the splice.
                     */
                    reversedInterceptors.splice(index, 0, {
                        response: function(response) {
                            return responseFn($q.when(response));
                        },
                        responseError: function(response) {
                            return responseFn($q.reject(response));
                        }
                    });
                });


                /**
                 * @ngdoc function
                 * @name ng.$http
                 * @requires $httpBackend
                 * @requires $browser
                 * @requires $cacheFactory
                 * @requires $rootScope
                 * @requires $q
                 * @requires $injector
                 *
                 * @description
                 * The `$http` service is a core Angular service that facilitates communication with the remote
                 * HTTP servers via the browser's {@link https://developer.mozilla.org/en/xmlhttprequest
                 * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.
                 *
                 * For unit testing applications that use `$http` service, see
                 * {@link ngMock.$httpBackend $httpBackend mock}.
                 *
                 * For a higher level of abstraction, please check out the {@link ngResource.$resource
                 * $resource} service.
                 *
                 * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by
                 * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage
                 * it is important to familiarize yourself with these APIs and the guarantees they provide.
                 *
                 *
                 * # General usage
                 * The `$http` service is a function which takes a single argument â€” a configuration object â€”
                 * that is used to generate an HTTP request and returns  a {@link ng.$q promise}
                 * with two $http specific methods: `success` and `error`.
                 *
                 * <pre>
                 *   $http({method: 'GET', url: '/someUrl'}).
                 *     success(function(data, status, headers, config) {
     *       // this callback will be called asynchronously
     *       // when the response is available
     *     }).
                 *     error(function(data, status, headers, config) {
     *       // called asynchronously if an error occurs
     *       // or server returns response with an error status.
     *     });
                 * </pre>
                 *
                 * Since the returned value of calling the $http function is a `promise`, you can also use
                 * the `then` method to register callbacks, and these callbacks will receive a single argument â€“
                 * an object representing the response. See the API signature and type info below for more
                 * details.
                 *
                 * A response status code between 200 and 299 is considered a success status and
                 * will result in the success callback being called. Note that if the response is a redirect,
                 * XMLHttpRequest will transparently follow it, meaning that the error callback will not be
                 * called for such responses.
                 *
                 * # Shortcut methods
                 *
                 * Since all invocations of the $http service require passing in an HTTP method and URL, and
                 * POST/PUT requests require request data to be provided as well, shortcut methods
                 * were created:
                 *
                 * <pre>
                 *   $http.get('/someUrl').success(successCallback);
                 *   $http.post('/someUrl', data).success(successCallback);
                 * </pre>
                 *
                 * Complete list of shortcut methods:
                 *
                 * - {@link ng.$http#get $http.get}
                 * - {@link ng.$http#head $http.head}
                 * - {@link ng.$http#post $http.post}
                 * - {@link ng.$http#put $http.put}
                 * - {@link ng.$http#delete $http.delete}
                 * - {@link ng.$http#jsonp $http.jsonp}
                 *
                 *
                 * # Setting HTTP Headers
                 *
                 * The $http service will automatically add certain HTTP headers to all requests. These defaults
                 * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
                 * object, which currently contains this default configuration:
                 *
                 * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):
                 *   - `Accept: application/json, text/plain, * / *`
                 * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)
                 *   - `Content-Type: application/json`
                 * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)
                 *   - `Content-Type: application/json`
                 *
                 * To add or overwrite these defaults, simply add or remove a property from these configuration
                 * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
                 * with the lowercased HTTP method name as the key, e.g.
                 * `$httpProvider.defaults.headers.get['My-Header']='value'`.
                 *
                 * Additionally, the defaults can be set at runtime via the `$http.defaults` object in the same
                 * fashion.
                 *
                 *
                 * # Transforming Requests and Responses
                 *
                 * Both requests and responses can be transformed using transform functions. By default, Angular
                 * applies these transformations:
                 *
                 * Request transformations:
                 *
                 * - If the `data` property of the request configuration object contains an object, serialize it into
                 *   JSON format.
                 *
                 * Response transformations:
                 *
                 *  - If XSRF prefix is detected, strip it (see Security Considerations section below).
                 *  - If JSON response is detected, deserialize it using a JSON parser.
                 *
                 * To globally augment or override the default transforms, modify the `$httpProvider.defaults.transformRequest` and
                 * `$httpProvider.defaults.transformResponse` properties. These properties are by default an
                 * array of transform functions, which allows you to `push` or `unshift` a new transformation function into the
                 * transformation chain. You can also decide to completely override any default transformations by assigning your
                 * transformation functions to these properties directly without the array wrapper.
                 *
                 * Similarly, to locally override the request/response transforms, augment the `transformRequest` and/or
                 * `transformResponse` properties of the configuration object passed into `$http`.
                 *
                 *
                 * # Caching
                 *
                 * To enable caching, set the configuration property `cache` to `true`. When the cache is
                 * enabled, `$http` stores the response from the server in local cache. Next time the
                 * response is served from the cache without sending a request to the server.
                 *
                 * Note that even if the response is served from cache, delivery of the data is asynchronous in
                 * the same way that real requests are.
                 *
                 * If there are multiple GET requests for the same URL that should be cached using the same
                 * cache, but the cache is not populated yet, only one request to the server will be made and
                 * the remaining requests will be fulfilled using the response from the first request.
                 *
                 * A custom default cache built with $cacheFactory can be provided in $http.defaults.cache.
                 * To skip it, set configuration property `cache` to `false`.
                 *
                 *
                 * # Interceptors
                 *
                 * Before you start creating interceptors, be sure to understand the
                 * {@link ng.$q $q and deferred/promise APIs}.
                 *
                 * For purposes of global error handling, authentication, or any kind of synchronous or
                 * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
                 * able to intercept requests before they are handed to the server and
                 * responses before they are handed over to the application code that
                 * initiated these requests. The interceptors leverage the {@link ng.$q
                 * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.
                 *
                 * The interceptors are service factories that are registered with the `$httpProvider` by
                 * adding them to the `$httpProvider.interceptors` array. The factory is called and
                 * injected with dependencies (if specified) and returns the interceptor.
                 *
                 * There are two kinds of interceptors (and two kinds of rejection interceptors):
                 *
                 *   * `request`: interceptors get called with http `config` object. The function is free to modify
                 *     the `config` or create a new one. The function needs to return the `config` directly or as a
                 *     promise.
                 *   * `requestError`: interceptor gets called when a previous interceptor threw an error or resolved
                 *      with a rejection.
                 *   * `response`: interceptors get called with http `response` object. The function is free to modify
                 *     the `response` or create a new one. The function needs to return the `response` directly or as a
                 *     promise.
                 *   * `responseError`: interceptor gets called when a previous interceptor threw an error or resolved
                 *      with a rejection.
                 *
                 *
                 * <pre>
                 *   // register the interceptor as a service
                 *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
     *     return {
     *       // optional method
     *       'request': function(config) {
     *         // do something on success
     *         return config || $q.when(config);
     *       },
     *
     *       // optional method
     *      'requestError': function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       },
     *
     *
     *
     *       // optional method
     *       'response': function(response) {
     *         // do something on success
     *         return response || $q.when(response);
     *       },
     *
     *       // optional method
     *      'responseError': function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       };
     *     }
     *   });
                 *
                 *   $httpProvider.interceptors.push('myHttpInterceptor');
                 *
                 *
                 *   // register the interceptor via an anonymous factory
                 *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
     *     return {
     *      'request': function(config) {
     *          // same as above
     *       },
     *       'response': function(response) {
     *          // same as above
     *       }
     *   });
     * </pre>
     *
     * # Response interceptors (DEPRECATED)
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
                 *
                 * For purposes of global error handling, authentication or any kind of synchronous or
                 * asynchronous preprocessing of received responses, it is desirable to be able to intercept
                 * responses for http requests before they are handed over to the application code that
                 * initiated these requests. The response interceptors leverage the {@link ng.$q
                 * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.
                 *
                 * The interceptors are service factories that are registered with the $httpProvider by
                 * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and
                 * injected with dependencies (if specified) and returns the interceptor  â€” a function that
                 * takes a {@link ng.$q promise} and returns the original or a new promise.
                 *
                 * <pre>
                 *   // register the interceptor as a service
                 *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       return promise.then(function(response) {
     *         // do something on success
     *       }, function(response) {
     *         // do something on error
     *         if (canRecover(response)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(response);
     *       });
     *     }
     *   });
                 *
                 *   $httpProvider.responseInterceptors.push('myHttpInterceptor');
                 *
                 *
                 *   // register the interceptor via an anonymous factory
                 *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       // same as above
     *     }
     *   });
                 * </pre>
                 *
                 *
                 * # Security Considerations
                 *
                 * When designing web applications, consider security threats from:
                 *
                 * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
                 *   JSON vulnerability}
                 * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}
                 *
                 * Both server and the client must cooperate in order to eliminate these threats. Angular comes
                 * pre-configured with strategies that address these issues, but for this to work backend server
                 * cooperation is required.
                 *
                 * ## JSON Vulnerability Protection
                 *
                 * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
                 * JSON vulnerability} allows third party website to turn your JSON resource URL into
                 * {@link http://en.wikipedia.org/wiki/JSONP JSONP} request under some conditions. To
                 * counter this your server can prefix all JSON requests with following string `")]}',\n"`.
                 * Angular will automatically strip the prefix before processing it as JSON.
                 *
                 * For example if your server needs to return:
                 * <pre>
                 * ['one','two']
                 * </pre>
                 *
                 * which is vulnerable to attack, your server can return:
                 * <pre>
                 * )]}',
                 * ['one','two']
                 * </pre>
                 *
                 * Angular will strip the prefix, before processing the JSON.
                 *
                 *
                 * ## Cross Site Request Forgery (XSRF) Protection
                 *
                 * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which
                 * an unauthorized site can gain your user's private data. Angular provides a mechanism
                 * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
                 * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only
                 * JavaScript that runs on your domain could read the cookie, your server can be assured that
                 * the XHR came from JavaScript running on your domain. The header will not be set for
                 * cross-domain requests.
                 *
                 * To take advantage of this, your server needs to set a token in a JavaScript readable session
                 * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the
                 * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
                 * that only JavaScript running on your domain could have sent the request. The token must be
                 * unique for each user and must be verifiable by the server (to prevent the JavaScript from making
                 * up its own tokens). We recommend that the token is a digest of your site's authentication
                 * cookie with a {@link https://en.wikipedia.org/wiki/Salt_(cryptography) salt} for added security.
                 *
                 * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
                 * properties of either $httpProvider.defaults, or the per-request config object.
                 *
                 *
                 * @param {object} config Object describing the request to be made and how it should be
                 *    processed. The object has following properties:
                 *
                 *    - **method** â€“ `{string}` â€“ HTTP method (e.g. 'GET', 'POST', etc)
                 *    - **url** â€“ `{string}` â€“ Absolute or relative URL of the resource that is being requested.
                 *    - **params** â€“ `{Object.<string|Object>}` â€“ Map of strings or objects which will be turned to
                 *      `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified.
                 *    - **data** â€“ `{string|Object}` â€“ Data to be sent as the request message data.
                 *    - **headers** â€“ `{Object}` â€“ Map of strings representing HTTP headers to send to the server.
                 *    - **xsrfHeaderName** â€“ `{string}` â€“ Name of HTTP header to populate with the XSRF token.
                 *    - **xsrfCookieName** â€“ `{string}` â€“ Name of cookie containing the XSRF token.
                 *    - **transformRequest** â€“ `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` â€“
                 *      transform function or an array of such functions. The transform function takes the http
                 *      request body and headers and returns its transformed (typically serialized) version.
                 *    - **transformResponse** â€“ `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` â€“
                 *      transform function or an array of such functions. The transform function takes the http
                 *      response body and headers and returns its transformed (typically deserialized) version.
                 *    - **cache** â€“ `{boolean|Cache}` â€“ If true, a default $http cache will be used to cache the
                 *      GET request, otherwise if a cache instance built with
                 *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
                 *      caching.
                 *    - **timeout** â€“ `{number|Promise}` â€“ timeout in milliseconds, or {@link ng.$q promise}
                 *      that should abort the request when resolved.
                 *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the
                 *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5
                 *      requests with credentials} for more information.
                 *    - **responseType** - `{string}` - see {@link
                 *      https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.
                 *
                 * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the
                 *   standard `then` method and two http specific methods: `success` and `error`. The `then`
                 *   method takes two arguments a success and an error callback which will be called with a
                 *   response object. The `success` and `error` methods take a single argument - a function that
                 *   will be called when the request succeeds or fails respectively. The arguments passed into
                 *   these functions are destructured representation of the response object passed into the
                 *   `then` method. The response object has these properties:
                 *
                 *   - **data** â€“ `{string|Object}` â€“ The response body transformed with the transform functions.
                 *   - **status** â€“ `{number}` â€“ HTTP status code of the response.
                 *   - **headers** â€“ `{function([headerName])}` â€“ Header getter function.
                 *   - **config** â€“ `{Object}` â€“ The configuration object that was used to generate the request.
                 *
                 * @property {Array.<Object>} pendingRequests Array of config objects for currently pending
                 *   requests. This is primarily meant to be used for debugging purposes.
                 *
                 *
                 * @example
                 <example>
                 <file name="index.html">
                 <div ng-controller="FetchCtrl">
                 <select ng-model="method">
                 <option>GET</option>
                 <option>JSONP</option>
                 </select>
                 <input type="text" ng-model="url" size="80"/>
                 <button ng-click="fetch()">fetch</button><br>
                 <button ng-click="updateModel('GET', 'http-hello.html')">Sample GET</button>
                 <button ng-click="updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">Sample JSONP</button>
                 <button ng-click="updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')">Invalid JSONP</button>
                 <pre>http status code: {{status}}</pre>
                 <pre>http response data: {{data}}</pre>
                 </div>
                 </file>
                 <file name="script.js">
                 function FetchCtrl($scope, $http, $templateCache) {
            $scope.method = 'GET';
            $scope.url = 'http-hello.html';

            $scope.fetch = function() {
              $scope.code = null;
              $scope.response = null;

              $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
                success(function(data, status) {
                  $scope.status = status;
                  $scope.data = data;
                }).
                error(function(data, status) {
                  $scope.data = data || "Request failed";
                  $scope.status = status;
              });
            };

            $scope.updateModel = function(method, url) {
              $scope.method = method;
              $scope.url = url;
            };
          }
                 </file>
                 <file name="http-hello.html">
                 Hello, $http!
                 </file>
                 <file name="scenario.js">
                 it('should make an xhr GET request', function() {
            element(':button:contains("Sample GET")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('200');
            expect(binding('data')).toMatch(/Hello, \$http!/);
          });

                 it('should make a JSONP request to angularjs.org', function() {
            element(':button:contains("Sample JSONP")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('200');
            expect(binding('data')).toMatch(/Super Hero!/);
          });

                 it('should make JSONP request to invalid URL and invoke the error handler',
                 function() {
            element(':button:contains("Invalid JSONP")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('0');
            expect(binding('data')).toBe('Request failed');
          });
                 </file>
                 </example>
                 */
                function $http(requestConfig) {
                    var config = {
                        transformRequest: defaults.transformRequest,
                        transformResponse: defaults.transformResponse
                    };
                    var headers = {};

                    extend(config, requestConfig);
                    config.headers = headers;
                    config.method = uppercase(config.method);

                    extend(headers,
                        defaults.headers.common,
                        defaults.headers[lowercase(config.method)],
                        requestConfig.headers);

                    var xsrfValue = isSameDomain(config.url, $browser.url())
                        ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
                        : undefined;
                    if (xsrfValue) {
                        headers[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
                    }


                    var serverRequest = function(config) {
                        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);

                        // strip content-type if data is undefined
                        if (isUndefined(config.data)) {
                            delete headers['Content-Type'];
                        }

                        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                            config.withCredentials = defaults.withCredentials;
                        }

                        // send request
                        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
                    };

                    var chain = [serverRequest, undefined];
                    var promise = $q.when(config);

                    // apply interceptors
                    forEach(reversedInterceptors, function(interceptor) {
                        if (interceptor.request || interceptor.requestError) {
                            chain.unshift(interceptor.request, interceptor.requestError);
                        }
                        if (interceptor.response || interceptor.responseError) {
                            chain.push(interceptor.response, interceptor.responseError);
                        }
                    });

                    while(chain.length) {
                        var thenFn = chain.shift();
                        var rejectFn = chain.shift();

                        promise = promise.then(thenFn, rejectFn);
                    }

                    promise.success = function(fn) {
                        promise.then(function(response) {
                            fn(response.data, response.status, response.headers, config);
                        });
                        return promise;
                    };

                    promise.error = function(fn) {
                        promise.then(null, function(response) {
                            fn(response.data, response.status, response.headers, config);
                        });
                        return promise;
                    };

                    return promise;

                    function transformResponse(response) {
                        // make a copy since the response must be cacheable
                        var resp = extend({}, response, {
                            data: transformData(response.data, response.headers, config.transformResponse)
                        });
                        return (isSuccess(response.status))
                            ? resp
                            : $q.reject(resp);
                    }
                }

                $http.pendingRequests = [];

                /**
                 * @ngdoc method
                 * @name ng.$http#get
                 * @methodOf ng.$http
                 *
                 * @description
                 * Shortcut method to perform `GET` request.
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */

                /**
                 * @ngdoc method
                 * @name ng.$http#delete
                 * @methodOf ng.$http
                 *
                 * @description
                 * Shortcut method to perform `DELETE` request.
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */

                /**
                 * @ngdoc method
                 * @name ng.$http#head
                 * @methodOf ng.$http
                 *
                 * @description
                 * Shortcut method to perform `HEAD` request.
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */

                /**
                 * @ngdoc method
                 * @name ng.$http#jsonp
                 * @methodOf ng.$http
                 *
                 * @description
                 * Shortcut method to perform `JSONP` request.
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request.
                 *                     Should contain `JSON_CALLBACK` string.
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */
                createShortMethods('get', 'delete', 'head', 'jsonp');

                /**
                 * @ngdoc method
                 * @name ng.$http#post
                 * @methodOf ng.$http
                 *
                 * @description
                 * Shortcut method to perform `POST` request.
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {*} data Request content
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */

                /**
                 * @ngdoc method
                 * @name ng.$http#put
                 * @methodOf ng.$http
                 *
                 * @description
                 * Shortcut method to perform `PUT` request.
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {*} data Request content
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */
                createShortMethodsWithData('post', 'put');

                /**
                 * @ngdoc property
                 * @name ng.$http#defaults
                 * @propertyOf ng.$http
                 *
                 * @description
                 * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
                 * default headers, withCredentials as well as request and response transformations.
                 *
                 * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
                 */
                $http.defaults = defaults;


                return $http;


                function createShortMethods(names) {
                    forEach(arguments, function(name) {
                        $http[name] = function(url, config) {
                            return $http(extend(config || {}, {
                                method: name,
                                url: url
                            }));
                        };
                    });
                }


                function createShortMethodsWithData(name) {
                    forEach(arguments, function(name) {
                        $http[name] = function(url, data, config) {
                            return $http(extend(config || {}, {
                                method: name,
                                url: url,
                                data: data
                            }));
                        };
                    });
                }


                /**
                 * Makes the request.
                 *
                 * !!! ACCESSES CLOSURE VARS:
                 * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
                 */
                function sendReq(config, reqData, reqHeaders) {
                    var deferred = $q.defer(),
                        promise = deferred.promise,
                        cache,
                        cachedResp,
                        url = buildUrl(config.url, config.params);

                    $http.pendingRequests.push(config);
                    promise.then(removePendingReq, removePendingReq);


                    if ((config.cache || defaults.cache) && config.cache !== false && config.method == 'GET') {
                        cache = isObject(config.cache) ? config.cache
                            : isObject(defaults.cache) ? defaults.cache
                            : defaultCache;
                    }

                    if (cache) {
                        cachedResp = cache.get(url);
                        if (cachedResp) {
                            if (cachedResp.then) {
                                // cached request has already been sent, but there is no response yet
                                cachedResp.then(removePendingReq, removePendingReq);
                                return cachedResp;
                            } else {
                                // serving from cache
                                if (isArray(cachedResp)) {
                                    resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
                                } else {
                                    resolvePromise(cachedResp, 200, {});
                                }
                            }
                        } else {
                            // put the promise for the non-transformed response into cache as a placeholder
                            cache.put(url, promise);
                        }
                    }

                    // if we won't have the response in cache, send the request to the backend
                    if (!cachedResp) {
                        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
                            config.withCredentials, config.responseType);
                    }

                    return promise;


                    /**
                     * Callback registered to $httpBackend():
                     *  - caches the response if desired
                     *  - resolves the raw $http promise
                     *  - calls $apply
                     */
                    function done(status, response, headersString) {
                        if (cache) {
                            if (isSuccess(status)) {
                                cache.put(url, [status, response, parseHeaders(headersString)]);
                            } else {
                                // remove promise from the cache
                                cache.remove(url);
                            }
                        }

                        resolvePromise(response, status, headersString);
                        if (!$rootScope.$$phase) $rootScope.$apply();
                    }


                    /**
                     * Resolves the raw $http promise.
                     */
                    function resolvePromise(response, status, headers) {
                        // normalize internal statuses to 0
                        status = Math.max(status, 0);

                        (isSuccess(status) ? deferred.resolve : deferred.reject)({
                            data: response,
                            status: status,
                            headers: headersGetter(headers),
                            config: config
                        });
                    }


                    function removePendingReq() {
                        var idx = indexOf($http.pendingRequests, config);
                        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                    }
                }


                function buildUrl(url, params) {
                    if (!params) return url;
                    var parts = [];
                    forEachSorted(params, function(value, key) {
                        if (value == null || value == undefined) return;
                        if (!isArray(value)) value = [value];

                        forEach(value, function(v) {
                            if (isObject(v)) {
                                v = toJson(v);
                            }
                            parts.push(encodeUriQuery(key) + '=' +
                                encodeUriQuery(v));
                        });
                    });
                    return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');
                }


            }];
    }

    var XHR = window.XMLHttpRequest || function() {
        try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); } catch (e1) {}
        try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); } catch (e2) {}
        try { return new ActiveXObject("Msxml2.XMLHTTP"); } catch (e3) {}
        throw new Error("This browser does not support XMLHttpRequest.");
    };


    /**
     * @ngdoc object
     * @name ng.$httpBackend
     * @requires $browser
     * @requires $window
     * @requires $document
     *
     * @description
     * HTTP backend used by the {@link ng.$http service} that delegates to
     * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
     *
     * You should never need to use this service directly, instead use the higher-level abstractions:
     * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
     *
     * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
     * $httpBackend} which can be trained with responses.
     */
    function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
            return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,
                $document[0], $window.location.protocol.replace(':', ''));
        }];
    }

    function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
        // TODO(vojta): fix the signature
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            var status;
            $browser.$$incOutstandingRequestCount();
            url = url || $browser.url();

            if (lowercase(method) == 'jsonp') {
                var callbackId = '_' + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data;
                };

                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                    function() {
                        if (callbacks[callbackId].data) {
                            completeRequest(callback, 200, callbacks[callbackId].data);
                        } else {
                            completeRequest(callback, status || -2);
                        }
                        delete callbacks[callbackId];
                    });
            } else {
                var xhr = new XHR();
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (value) xhr.setRequestHeader(key, value);
                });

                // In IE6 and 7, this might be called synchronously when xhr.send below is called and the
                // response is in the cache. the promise api will ensure that to the app code the api is
                // always async
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == 4) {
                        var responseHeaders = xhr.getAllResponseHeaders();

                        // TODO(vojta): remove once Firefox 21 gets released.
                        // begin: workaround to overcome Firefox CORS http response headers bug
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=608735
                        // Firefox already patched in nightly. Should land in Firefox 21.

                        // CORS "simple response headers" http://www.w3.org/TR/cors/
                        var value,
                            simpleHeaders = ["Cache-Control", "Content-Language", "Content-Type",
                                "Expires", "Last-Modified", "Pragma"];
                        if (!responseHeaders) {
                            responseHeaders = "";
                            forEach(simpleHeaders, function (header) {
                                var value = xhr.getResponseHeader(header);
                                if (value) {
                                    responseHeaders += header + ": " + value + "\n";
                                }
                            });
                        }
                        // end of the workaround.

                        // responseText is the old-school way of retrieving response (supported by IE8 & 9)
                        // response and responseType properties were introduced in XHR Level2 spec (supported by IE10)
                        completeRequest(callback,
                            status || xhr.status,
                            (xhr.responseType ? xhr.response : xhr.responseText),
                            responseHeaders);
                    }
                };

                if (withCredentials) {
                    xhr.withCredentials = true;
                }

                if (responseType) {
                    xhr.responseType = responseType;
                }

                xhr.send(post || '');
            }

            if (timeout > 0) {
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            } else if (timeout && timeout.then) {
                timeout.then(timeoutRequest);
            }


            function timeoutRequest() {
                status = -1;
                jsonpDone && jsonpDone();
                xhr && xhr.abort();
            }

            function completeRequest(callback, status, response, headersString) {
                // URL_MATCH is defined in src/service/location.js
                var protocol = (url.match(SERVER_MATCH) || ['', locationProtocol])[1];

                // cancel timeout and subsequent timeout promise resolution
                timeoutId && $browserDefer.cancel(timeoutId);
                jsonpDone = xhr = null;

                // fix status code for file protocol (it's always 0)
                status = (protocol == 'file') ? (response ? 200 : 404) : status;

                // normalize IE bug (http://bugs.jquery.com/ticket/1450)
                status = status == 1223 ? 204 : status;

                callback(status, response, headersString);
                $browser.$$completeOutstandingRequest(noop);
            }
        };

        function jsonpReq(url, done) {
            // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:
            // - fetches local scripts via XHR and evals them
            // - adds and immediately removes script elements from the document
            var script = rawDocument.createElement('script'),
                doneWrapper = function() {
                    rawDocument.body.removeChild(script);
                    if (done) done();
                };

            script.type = 'text/javascript';
            script.src = url;

            if (msie) {
                script.onreadystatechange = function() {
                    if (/loaded|complete/.test(script.readyState)) doneWrapper();
                };
            } else {
                script.onload = script.onerror = doneWrapper;
            }

            rawDocument.body.appendChild(script);
            return doneWrapper;
        }
    }

    /**
     * @ngdoc object
     * @name ng.$locale
     *
     * @description
     * $locale service provides localization rules for various Angular components. As of right now the
     * only public api is:
     *
     * * `id` â€“ `{string}` â€“ locale id formatted as `languageId-countryId` (e.g. `en-us`)
     */
    function $LocaleProvider(){
        this.$get = function() {
            return {
                id: 'en-us',

                NUMBER_FORMATS: {
                    DECIMAL_SEP: '.',
                    GROUP_SEP: ',',
                    PATTERNS: [
                        { // Decimal Pattern
                            minInt: 1,
                            minFrac: 0,
                            maxFrac: 3,
                            posPre: '',
                            posSuf: '',
                            negPre: '-',
                            negSuf: '',
                            gSize: 3,
                            lgSize: 3
                        },{ //Currency Pattern
                            minInt: 1,
                            minFrac: 2,
                            maxFrac: 2,
                            posPre: '\u00A4',
                            posSuf: '',
                            negPre: '(\u00A4',
                            negSuf: ')',
                            gSize: 3,
                            lgSize: 3
                        }
                    ],
                    CURRENCY_SYM: '$'
                },

                DATETIME_FORMATS: {
                    MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'
                        .split(','),
                    SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
                    DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
                    SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
                    AMPMS: ['AM','PM'],
                    medium: 'MMM d, y h:mm:ss a',
                    short: 'M/d/yy h:mm a',
                    fullDate: 'EEEE, MMMM d, y',
                    longDate: 'MMMM d, y',
                    mediumDate: 'MMM d, y',
                    shortDate: 'M/d/yy',
                    mediumTime: 'h:mm:ss a',
                    shortTime: 'h:mm a'
                },

                pluralCat: function(num) {
                    if (num === 1) {
                        return 'one';
                    }
                    return 'other';
                }
            };
        };
    }

    function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$exceptionHandler',
            function($rootScope,   $browser,   $q,   $exceptionHandler) {
                var deferreds = {};


                /**
                 * @ngdoc function
                 * @name ng.$timeout
                 * @requires $browser
                 *
                 * @description
                 * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
                 * block and delegates any exceptions to
                 * {@link ng.$exceptionHandler $exceptionHandler} service.
                 *
                 * The return value of registering a timeout function is a promise, which will be resolved when
                 * the timeout is reached and the timeout function is executed.
                 *
                 * To cancel a timeout request, call `$timeout.cancel(promise)`.
                 *
                 * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to
                 * synchronously flush the queue of deferred functions.
                 *
                 * @param {function()} fn A function, whose execution should be delayed.
                 * @param {number=} [delay=0] Delay in milliseconds.
                 * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
                 *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
                 * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this
                 *   promise will be resolved with is the return value of the `fn` function.
                 */
                function timeout(fn, delay, invokeApply) {
                    var deferred = $q.defer(),
                        promise = deferred.promise,
                        skipApply = (isDefined(invokeApply) && !invokeApply),
                        timeoutId, cleanup;

                    timeoutId = $browser.defer(function() {
                        try {
                            deferred.resolve(fn());
                        } catch(e) {
                            deferred.reject(e);
                            $exceptionHandler(e);
                        }

                        if (!skipApply) $rootScope.$apply();
                    }, delay);

                    cleanup = function() {
                        delete deferreds[promise.$$timeoutId];
                    };

                    promise.$$timeoutId = timeoutId;
                    deferreds[timeoutId] = deferred;
                    promise.then(cleanup, cleanup);

                    return promise;
                }


                /**
                 * @ngdoc function
                 * @name ng.$timeout#cancel
                 * @methodOf ng.$timeout
                 *
                 * @description
                 * Cancels a task associated with the `promise`. As a result of this, the promise will be
                 * resolved with a rejection.
                 *
                 * @param {Promise=} promise Promise returned by the `$timeout` function.
                 * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
                 *   canceled.
                 */
                timeout.cancel = function(promise) {
                    if (promise && promise.$$timeoutId in deferreds) {
                        deferreds[promise.$$timeoutId].reject('canceled');
                        return $browser.defer.cancel(promise.$$timeoutId);
                    }
                    return false;
                };

                return timeout;
            }];
    }

    /**
     * @ngdoc object
     * @name ng.$filterProvider
     * @description
     *
     * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To
     * achieve this a filter definition consists of a factory function which is annotated with dependencies and is
     * responsible for creating a filter function.
     *
     * <pre>
     *   // Filter registration
     *   function MyModule($provide, $filterProvider) {
 *     // create a service to demonstrate injection (not always needed)
 *     $provide.value('greet', function(name){
 *       return 'Hello ' + name + '!';
 *     });
 *
 *     // register a filter factory which uses the
 *     // greet service to demonstrate DI.
 *     $filterProvider.register('greet', function(greet){
 *       // return the filter function which uses the greet service
 *       // to generate salutation
 *       return function(text) {
 *         // filters need to be forgiving so check input validity
 *         return text && greet(text) || text;
 *       };
 *     });
 *   }
     * </pre>
     *
     * The filter function is registered with the `$injector` under the filter name suffixe with `Filter`.
     * <pre>
     *   it('should be the same instance', inject(
     *     function($filterProvider) {
 *       $filterProvider.register('reverse', function(){
 *         return ...;
 *       });
 *     },
     *     function($filter, reverseFilter) {
 *       expect($filter('reverse')).toBe(reverseFilter);
 *     });
     * </pre>
     *
     *
     * For more information about how angular filters work, and how to create your own filters, see
     * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer
     * Guide.
     */
    /**
     * @ngdoc method
     * @name ng.$filterProvider#register
     * @methodOf ng.$filterProvider
     * @description
     * Register filter factory function.
     *
     * @param {String} name Name of the filter.
     * @param {function} fn The filter factory function which is injectable.
     */


    /**
     * @ngdoc function
     * @name ng.$filter
     * @function
     * @description
     * Filters are used for formatting data displayed to the user.
     *
     * The general syntax in templates is as follows:
     *
     *         {{ expression [| filter_name[:parameter_value] ... ] }}
     *
     * @param {String} name Name of the filter function to retrieve
     * @return {Function} the filter function
     */
    $FilterProvider.$inject = ['$provide'];
    function $FilterProvider($provide) {
        var suffix = 'Filter';

        function register(name, factory) {
            return $provide.factory(name + suffix, factory);
        }
        this.register = register;

        this.$get = ['$injector', function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            }
        }];

        ////////////////////////////////////////

        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
    }

    /**
     * @ngdoc filter
     * @name ng.filter:filter
     * @function
     *
     * @description
     * Selects a subset of items from `array` and returns it as a new array.
     *
     * Note: This function is used to augment the `Array` type in Angular expressions. See
     * {@link ng.$filter} for more information about Angular arrays.
     *
     * @param {Array} array The source array.
     * @param {string|Object|function()} expression The predicate to be used for selecting items from
     *   `array`.
     *
     *   Can be one of:
     *
     *   - `string`: Predicate that results in a substring match using the value of `expression`
     *     string. All strings or objects with string properties in `array` that contain this string
     *     will be returned. The predicate can be negated by prefixing the string with `!`.
     *
     *   - `Object`: A pattern object can be used to filter specific properties on objects contained
     *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
     *     which have property `name` containing "M" and property `phone` containing "1". A special
     *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
     *     property of the object. That's equivalent to the simple substring match with a `string`
     *     as described above.
     *
     *   - `function`: A predicate function can be used to write arbitrary filters. The function is
     *     called for each element of `array`. The final result is an array of those elements that
     *     the predicate returned true for.
     *
     * @param {function(expected, actual)|true|undefined} comparator Comparator which is used in
     *     determining if the expected value (from the filter expression) and actual value (from
     *     the object in the array) should be considered a match.
     *
     *   Can be one of:
     *
     *     - `function(expected, actual)`:
     *       The function will be given the object value and the predicate value to compare and
     *       should return true if the item should be included in filtered result.
     *
     *     - `true`: A shorthand for `function(expected, actual) { return angular.equals(expected, actual)}`.
     *       this is essentially strict comparison of expected and actual.
     *
     *     - `false|undefined`: A short hand for a function which will look for a substring match in case
     *       insensitive way.
     *
     * @example
     <doc:example>
     <doc:source>
     <div ng-init="friends = [{name:'John', phone:'555-1276'},
     {name:'Mary', phone:'800-BIG-MARY'},
     {name:'Mike', phone:'555-4321'},
     {name:'Adam', phone:'555-5678'},
     {name:'Julie', phone:'555-8765'},
     {name:'Juliette', phone:'555-5678'}]"></div>

     Search: <input ng-model="searchText">
     <table id="searchTextResults">
     <tr><th>Name</th><th>Phone</th></tr>
     <tr ng-repeat="friend in friends | filter:searchText">
     <td>{{friend.name}}</td>
     <td>{{friend.phone}}</td>
     </tr>
     </table>
     <hr>
     Any: <input ng-model="search.$"> <br>
     Name only <input ng-model="search.name"><br>
     Phone only <input ng-model="search.phone"><br>
     Equality <input type="checkbox" ng-model="strict"><br>
     <table id="searchObjResults">
     <tr><th>Name</th><th>Phone</th></tr>
     <tr ng-repeat="friend in friends | filter:search:strict">
     <td>{{friend.name}}</td>
     <td>{{friend.phone}}</td>
     </tr>
     </table>
     </doc:source>
     <doc:scenario>
     it('should search across all fields when filtering with a string', function() {
         input('searchText').enter('m');
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Mike', 'Adam']);

         input('searchText').enter('76');
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
           toEqual(['John', 'Julie']);
       });

     it('should search in specific fields when filtering with a predicate object', function() {
         input('search.$').enter('i');
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Mike', 'Julie', 'Juliette']);
       });
     it('should use a equal comparison when comparator is true', function() {
         input('search.name').enter('Julie');
         input('strict').check();
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Julie']);
       });
     </doc:scenario>
     </doc:example>
     */
    function filterFilter() {
        return function(array, expression, comperator) {
            if (!isArray(array)) return array;
            var predicates = [];
            predicates.check = function(value) {
                for (var j = 0; j < predicates.length; j++) {
                    if(!predicates[j](value)) {
                        return false;
                    }
                }
                return true;
            };
            switch(typeof comperator) {
                case "function":
                    break;
                case "boolean":
                    if(comperator == true) {
                        comperator = function(obj, text) {
                            return angular.equals(obj, text);
                        }
                        break;
                    }
                default:
                    comperator = function(obj, text) {
                        text = (''+text).toLowerCase();
                        return (''+obj).toLowerCase().indexOf(text) > -1
                    };
            }
            var search = function(obj, text){
                if (typeof text == 'string' && text.charAt(0) === '!') {
                    return !search(obj, text.substr(1));
                }
                switch (typeof obj) {
                    case "boolean":
                    case "number":
                    case "string":
                        return comperator(obj, text);
                    case "object":
                        switch (typeof text) {
                            case "object":
                                return comperator(obj, text);
                                break;
                            default:
                                for ( var objKey in obj) {
                                    if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
                                        return true;
                                    }
                                }
                                break;
                        }
                        return false;
                    case "array":
                        for ( var i = 0; i < obj.length; i++) {
                            if (search(obj[i], text)) {
                                return true;
                            }
                        }
                        return false;
                    default:
                        return false;
                }
            };
            switch (typeof expression) {
                case "boolean":
                case "number":
                case "string":
                    expression = {$:expression};
                case "object":
                    for (var key in expression) {
                        if (key == '$') {
                            (function() {
                                if (!expression[key]) return;
                                var path = key
                                predicates.push(function(value) {
                                    return search(value, expression[path]);
                                });
                            })();
                        } else {
                            (function() {
                                if (!expression[key]) return;
                                var path = key;
                                predicates.push(function(value) {
                                    return search(getter(value,path), expression[path]);
                                });
                            })();
                        }
                    }
                    break;
                case 'function':
                    predicates.push(expression);
                    break;
                default:
                    return array;
            }
            var filtered = [];
            for ( var j = 0; j < array.length; j++) {
                var value = array[j];
                if (predicates.check(value)) {
                    filtered.push(value);
                }
            }
            return filtered;
        }
    }

    /**
     * @ngdoc filter
     * @name ng.filter:currency
     * @function
     *
     * @description
     * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
     * symbol for current locale is used.
     *
     * @param {number} amount Input to filter.
     * @param {string=} symbol Currency symbol or identifier to be displayed.
     * @returns {string} Formatted number.
     *
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.amount = 1234.56;
         }
     </script>
     <div ng-controller="Ctrl">
     <input type="number" ng-model="amount"> <br>
     default currency symbol ($): {{amount | currency}}<br>
     custom currency identifier (USD$): {{amount | currency:"USD$"}}
     </div>
     </doc:source>
     <doc:scenario>
     it('should init with 1234.56', function() {
         expect(binding('amount | currency')).toBe('$1,234.56');
         expect(binding('amount | currency:"USD$"')).toBe('USD$1,234.56');
       });
     it('should update', function() {
         input('amount').enter('-1234');
         expect(binding('amount | currency')).toBe('($1,234.00)');
         expect(binding('amount | currency:"USD$"')).toBe('(USD$1,234.00)');
       });
     </doc:scenario>
     </doc:example>
     */
    currencyFilter.$inject = ['$locale'];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol){
            if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
            return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).
                replace(/\u00A4/g, currencySymbol);
        };
    }

    /**
     * @ngdoc filter
     * @name ng.filter:number
     * @function
     *
     * @description
     * Formats a number as text.
     *
     * If the input is not a number an empty string is returned.
     *
     * @param {number|string} number Number to format.
     * @param {(number|string)=} [fractionSize=2] Number of decimal places to round the number to.
     * @returns {string} Number rounded to decimalPlaces and places a â€œ,â€ after each third digit.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.val = 1234.56789;
         }
     </script>
     <div ng-controller="Ctrl">
     Enter number: <input ng-model='val'><br>
     Default formatting: {{val | number}}<br>
     No fractions: {{val | number:0}}<br>
     Negative number: {{-val | number:4}}
     </div>
     </doc:source>
     <doc:scenario>
     it('should format numbers', function() {
         expect(binding('val | number')).toBe('1,234.568');
         expect(binding('val | number:0')).toBe('1,235');
         expect(binding('-val | number:4')).toBe('-1,234.5679');
       });

     it('should update', function() {
         input('val').enter('3374.333');
         expect(binding('val | number')).toBe('3,374.333');
         expect(binding('val | number:0')).toBe('3,374');
         expect(binding('-val | number:4')).toBe('-3,374.3330');
       });
     </doc:scenario>
     </doc:example>
     */


    numberFilter.$inject = ['$locale'];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
                fractionSize);
        };
    }

    var DECIMAL_SEP = '.';
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isNaN(number) || !isFinite(number)) return '';

        var isNegative = number < 0;
        number = Math.abs(number);
        var numStr = number + '',
            formatedText = '',
            parts = [];

        var hasExponent = false;
        if (numStr.indexOf('e') !== -1) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            if (match && match[2] == '-' && match[3] > fractionSize + 1) {
                numStr = '0';
            } else {
                formatedText = numStr;
                hasExponent = true;
            }
        }

        if (!hasExponent) {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;

            // determine fractionSize if it is not specified
            if (isUndefined(fractionSize)) {
                fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
            }

            var pow = Math.pow(10, fractionSize);
            number = Math.round(number * pow) / pow;
            var fraction = ('' + number).split(DECIMAL_SEP);
            var whole = fraction[0];
            fraction = fraction[1] || '';

            var pos = 0,
                lgroup = pattern.lgSize,
                group = pattern.gSize;

            if (whole.length >= (lgroup + group)) {
                pos = whole.length - lgroup;
                for (var i = 0; i < pos; i++) {
                    if ((pos - i)%group === 0 && i !== 0) {
                        formatedText += groupSep;
                    }
                    formatedText += whole.charAt(i);
                }
            }

            for (i = pos; i < whole.length; i++) {
                if ((whole.length - i)%lgroup === 0 && i !== 0) {
                    formatedText += groupSep;
                }
                formatedText += whole.charAt(i);
            }

            // format fraction part.
            while(fraction.length < fractionSize) {
                fraction += '0';
            }

            if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
        }

        parts.push(isNegative ? pattern.negPre : pattern.posPre);
        parts.push(formatedText);
        parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
    }

    function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
            neg =  '-';
            num = -num;
        }
        num = '' + num;
        while(num.length < digits) num = '0' + num;
        if (trim)
            num = num.substr(num.length - digits);
        return neg + num;
    }


    function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
            var value = date['get' + name]();
            if (offset > 0 || value > -offset)
                value += offset;
            if (value === 0 && offset == -12 ) value = 12;
            return padNumber(value, size, trim);
        };
    }

    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date['get' + name]();
            var get = uppercase(shortForm ? ('SHORT' + name) : name);

            return formats[get][value];
        };
    }

    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset();
        var paddedZone = (zone >= 0) ? "+" : "";

        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +
            padNumber(Math.abs(zone % 60), 2);

        return paddedZone;
    }

    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }

    var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        // while ISO 8601 requires fractions to be prefixed with `.` or `,` 
        // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter
    };

    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
        NUMBER_STRING = /^\d+$/;

    /**
     * @ngdoc filter
     * @name ng.filter:date
     * @function
     *
     * @description
     *   Formats `date` to a string based on the requested `format`.
     *
     *   `format` string can be composed of the following elements:
     *
     *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
     *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
     *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
     *   * `'MMMM'`: Month in year (January-December)
     *   * `'MMM'`: Month in year (Jan-Dec)
     *   * `'MM'`: Month in year, padded (01-12)
     *   * `'M'`: Month in year (1-12)
     *   * `'dd'`: Day in month, padded (01-31)
     *   * `'d'`: Day in month (1-31)
     *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
     *   * `'EEE'`: Day in Week, (Sun-Sat)
     *   * `'HH'`: Hour in day, padded (00-23)
     *   * `'H'`: Hour in day (0-23)
     *   * `'hh'`: Hour in am/pm, padded (01-12)
     *   * `'h'`: Hour in am/pm, (1-12)
     *   * `'mm'`: Minute in hour, padded (00-59)
     *   * `'m'`: Minute in hour (0-59)
     *   * `'ss'`: Second in minute, padded (00-59)
     *   * `'s'`: Second in minute (0-59)
     *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)
     *   * `'a'`: am/pm marker
     *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
     *
     *   `format` string can also be one of the following predefined
     *   {@link guide/i18n localizable formats}:
     *
     *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
     *     (e.g. Sep 3, 2010 12:05:08 pm)
     *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)
     *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale
     *     (e.g. Friday, September 3, 2010)
     *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010
     *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
     *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
     *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)
     *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)
     *
     *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.
     *   `"h 'in the morning'"`). In order to output single quote, use two single quotes in a sequence
     *   (e.g. `"h o''clock"`).
     *
     * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
     *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its
     *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
     *    specified in the string input, the time is considered to be in the local timezone.
     * @param {string=} format Formatting rules (see Description). If not specified,
     *    `mediumDate` is used.
     * @returns {string} Formatted string or the input if input is not recognized as date/millis.
     *
     * @example
     <doc:example>
     <doc:source>
     <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
     {{1288323623006 | date:'medium'}}<br>
     <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
     {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>
     <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
     {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>
     </doc:source>
     <doc:scenario>
     it('should format date', function() {
         expect(binding("1288323623006 | date:'medium'")).
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
         expect(binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).
            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);
         expect(binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).
     toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
     });
     </doc:scenario>
     </doc:example>
     */
    dateFilter.$inject = ['$locale'];
    function dateFilter($locale) {


        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        // 1        2       3         4          5          6          7          8  9     10      11
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0),
                    tzHour = 0,
                    tzMin  = 0,
                    dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                    timeSetter = match[8] ? date.setUTCHours : date.setHours;

                if (match[9]) {
                    tzHour = int(match[9] + match[10]);
                    tzMin = int(match[9] + match[11]);
                }
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4]||0) - tzHour;
                var m = int(match[5]||0) - tzMin
                var s = int(match[6]||0);
                var ms = Math.round(parseFloat('0.' + (match[7]||0)) * 1000);
                timeSetter.call(date, h, m, s, ms);
                return date;
            }
            return string;
        }


        return function(date, format) {
            var text = '',
                parts = [],
                fn, match;

            format = format || 'mediumDate';
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                if (NUMBER_STRING.test(date)) {
                    date = int(date);
                } else {
                    date = jsonStringToDate(date);
                }
            }

            if (isNumber(date)) {
                date = new Date(date);
            }

            if (!isDate(date)) {
                return date;
            }

            while(format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }

            forEach(parts, function(value){
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS)
                    : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
            });

            return text;
        };
    }


    /**
     * @ngdoc filter
     * @name ng.filter:json
     * @function
     *
     * @description
     *   Allows you to convert a JavaScript object into JSON string.
     *
     *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
     *   the binding is automatically converted to JSON.
     *
     * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
     * @returns {string} JSON string.
     *
     *
     * @example:
     <doc:example>
     <doc:source>
     <pre>{{ {'name':'value'} | json }}</pre>
     </doc:source>
     <doc:scenario>
     it('should jsonify filtered objects', function() {
         expect(binding("{'name':'value'}")).toMatch(/\{\n  "name": ?"value"\n}/);
       });
     </doc:scenario>
     </doc:example>
     *
     */
    function jsonFilter() {
        return function(object) {
            return toJson(object, true);
        };
    }


    /**
     * @ngdoc filter
     * @name ng.filter:lowercase
     * @function
     * @description
     * Converts string to lowercase.
     * @see angular.lowercase
     */
    var lowercaseFilter = valueFn(lowercase);


    /**
     * @ngdoc filter
     * @name ng.filter:uppercase
     * @function
     * @description
     * Converts string to uppercase.
     * @see angular.uppercase
     */
    var uppercaseFilter = valueFn(uppercase);

    /**
     * @ngdoc function
     * @name ng.filter:limitTo
     * @function
     *
     * @description
     * Creates a new array or string containing only a specified number of elements. The elements
     * are taken from either the beginning or the end of the source array or string, as specified by
     * the value and sign (positive or negative) of `limit`.
     *
     * Note: This function is used to augment the `Array` type in Angular expressions. See
     * {@link ng.$filter} for more information about Angular arrays.
     *
     * @param {Array|string} input Source array or string to be limited.
     * @param {string|number} limit The length of the returned array or string. If the `limit` number
     *     is positive, `limit` number of items from the beginning of the source array/string are copied.
     *     If the number is negative, `limit` number  of items from the end of the source array/string
     *     are copied. The `limit` will be trimmed if it exceeds `array.length`
     * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array
     *     had less than `limit` elements.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.numbers = [1,2,3,4,5,6,7,8,9];
           $scope.letters = "abcdefghi";
           $scope.numLimit = 3;
           $scope.letterLimit = 3;
         }
     </script>
     <div ng-controller="Ctrl">
     Limit {{numbers}} to: <input type="integer" ng-model="numLimit">
     <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>
     Limit {{letters}} to: <input type="integer" ng-model="letterLimit">
     <p>Output letters: {{ letters | limitTo:letterLimit }}</p>
     </div>
     </doc:source>
     <doc:scenario>
     it('should limit the number array to first three items', function() {
         expect(element('.doc-example-live input[ng-model=numLimit]').val()).toBe('3');
         expect(element('.doc-example-live input[ng-model=letterLimit]').val()).toBe('3');
         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('abc');
       });

     it('should update the output when -3 is entered', function() {
         input('numLimit').enter(-3);
         input('letterLimit').enter(-3);
         expect(binding('numbers | limitTo:numLimit')).toEqual('[7,8,9]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('ghi');
       });

     it('should not exceed the maximum size of input array', function() {
         input('numLimit').enter(100);
         input('letterLimit').enter(100);
         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3,4,5,6,7,8,9]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('abcdefghi');
       });
     </doc:scenario>
     </doc:example>
     */
    function limitToFilter(){
        return function(input, limit) {
            if (!isArray(input) && !isString(input)) return input;

            limit = int(limit);

            if (isString(input)) {
                //NaN check on limit
                if (limit) {
                    return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
                } else {
                    return "";
                }
            }

            var out = [],
                i, n;

            // if abs(limit) exceeds maximum length, trim it
            if (limit > input.length)
                limit = input.length;
            else if (limit < -input.length)
                limit = -input.length;

            if (limit > 0) {
                i = 0;
                n = limit;
            } else {
                i = input.length + limit;
                n = input.length;
            }

            for (; i<n; i++) {
                out.push(input[i]);
            }

            return out;
        }
    }

    /**
     * @ngdoc function
     * @name ng.filter:orderBy
     * @function
     *
     * @description
     * Orders a specified `array` by the `expression` predicate.
     *
     * Note: this function is used to augment the `Array` type in Angular expressions. See
     * {@link ng.$filter} for more information about Angular arrays.
     *
     * @param {Array} array The array to sort.
     * @param {function(*)|string|Array.<(function(*)|string)>} expression A predicate to be
     *    used by the comparator to determine the order of elements.
     *
     *    Can be one of:
     *
     *    - `function`: Getter function. The result of this function will be sorted using the
     *      `<`, `=`, `>` operator.
     *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'
     *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control
     *      ascending or descending sort order (for example, +name or -name).
     *    - `Array`: An array of function or string predicates. The first predicate in the array
     *      is used for sorting, but when two items are equivalent, the next predicate is used.
     *
     * @param {boolean=} reverse Reverse the order the array.
     * @returns {Array} Sorted copy of the source array.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.friends =
               [{name:'John', phone:'555-1212', age:10},
                {name:'Mary', phone:'555-9876', age:19},
                {name:'Mike', phone:'555-4321', age:21},
                {name:'Adam', phone:'555-5678', age:35},
                {name:'Julie', phone:'555-8765', age:29}]
           $scope.predicate = '-age';
         }
     </script>
     <div ng-controller="Ctrl">
     <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
     <hr/>
     [ <a href="" ng-click="predicate=''">unsorted</a> ]
     <table class="friend">
     <tr>
     <th><a href="" ng-click="predicate = 'name'; reverse=false">Name</a>
     (<a href ng-click="predicate = '-name'; reverse=false">^</a>)</th>
     <th><a href="" ng-click="predicate = 'phone'; reverse=!reverse">Phone Number</a></th>
     <th><a href="" ng-click="predicate = 'age'; reverse=!reverse">Age</a></th>
     </tr>
     <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
     <td>{{friend.name}}</td>
     <td>{{friend.phone}}</td>
     <td>{{friend.age}}</td>
     </tr>
     </table>
     </div>
     </doc:source>
     <doc:scenario>
     it('should be reverse ordered by aged', function() {
         expect(binding('predicate')).toBe('-age');
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).
           toEqual(['35', '29', '21', '19', '10']);
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);
       });

     it('should reorder the table when user selects different predicate', function() {
         element('.doc-example-live a:contains("Name")').click();
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).
           toEqual(['35', '10', '29', '19', '21']);

         element('.doc-example-live a:contains("Phone")').click();
         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).
           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);
       });
     </doc:scenario>
     </doc:example>
     */
    orderByFilter.$inject = ['$parse'];
    function orderByFilter($parse){
        return function(array, sortPredicate, reverseOrder) {
            if (!isArray(array)) return array;
            if (!sortPredicate) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];
            sortPredicate = map(sortPredicate, function(predicate){
                var descending = false, get = predicate || identity;
                if (isString(predicate)) {
                    if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                        descending = predicate.charAt(0) == '-';
                        predicate = predicate.substring(1);
                    }
                    get = $parse(predicate);
                }
                return reverseComparator(function(a,b){
                    return compare(get(a),get(b));
                }, descending);
            });
            var arrayCopy = [];
            for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }
            return arrayCopy.sort(reverseComparator(comparator, reverseOrder));

            function comparator(o1, o2){
                for ( var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (comp !== 0) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return toBoolean(descending)
                    ? function(a,b){return comp(b,a);}
                    : comp;
            }
            function compare(v1, v2){
                var t1 = typeof v1;
                var t2 = typeof v2;
                if (t1 == t2) {
                    if (t1 == "string") v1 = v1.toLowerCase();
                    if (t1 == "string") v2 = v2.toLowerCase();
                    if (v1 === v2) return 0;
                    return v1 < v2 ? -1 : 1;
                } else {
                    return t1 < t2 ? -1 : 1;
                }
            }
        }
    }

    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            }
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
    }

    /**
     * @ngdoc directive
     * @name ng.directive:a
     * @restrict E
     *
     * @description
     * Modifies the default behavior of html A tag, so that the default action is prevented when href
     * attribute is empty.
     *
     * The reasoning for this change is to allow easy creation of action links with `ngClick` directive
     * without changing the location or causing page reloads, e.g.:
     * `<a href="" ng-click="model.$save()">Save</a>`
     */
    var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {

            if (msie <= 8) {

                // turn <a href ng-click="..">link</a> into a stylable link in IE
                // but only if it doesn't have name attribute, in which case it's an anchor
                if (!attr.href && !attr.name) {
                    attr.$set('href', '');
                }

                // add a comment node to anchors to workaround IE bug that causes element content to be reset
                // to new attribute content if attribute is updated with value containing @ and element also
                // contains value with @
                // see issue #1949
                element.append(document.createComment('IE fix'));
            }

            return function(scope, element) {
                element.bind('click', function(event){
                    // if we have no href url, then don't navigate anywhere.
                    if (!element.attr('href')) {
                        event.preventDefault();
                    }
                });
            }
        }
    });

    /**
     * @ngdoc directive
     * @name ng.directive:ngHref
     * @restrict A
     *
     * @description
     * Using Angular markup like {{hash}} in an href attribute makes
     * the page open to a wrong URL, if the user clicks that link before
     * angular has a chance to replace the {{hash}} with actual URL, the
     * link will be broken and will most likely return a 404 error.
     * The `ngHref` directive solves this problem.
     *
     * The buggy way to write it:
     * <pre>
     * <a href="http://www.gravatar.com/avatar/{{hash}}"/>
     * </pre>
     *
     * The correct way to write it:
     * <pre>
     * <a ng-href="http://www.gravatar.com/avatar/{{hash}}"/>
     * </pre>
     *
     * @element A
     * @param {template} ngHref any string which can contain `{{}}` markup.
     *
     * @example
     * This example uses `link` variable inside `href` attribute:
     <doc:example>
     <doc:source>
     <input ng-model="value" /><br />
     <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
     <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
     <a id="link-3" ng-href="/{{'123'}}">link 3</a> (link, reload!)<br />
     <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
     <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
     <a id="link-6" ng-href="{{value}}">link</a> (link, change location)
     </doc:source>
     <doc:scenario>
     it('should execute ng-click but not reload when href without value', function() {
          element('#link-1').click();
          expect(input('value').val()).toEqual('1');
          expect(element('#link-1').attr('href')).toBe("");
        });

     it('should execute ng-click but not reload when href empty string', function() {
          element('#link-2').click();
          expect(input('value').val()).toEqual('2');
          expect(element('#link-2').attr('href')).toBe("");
        });

     it('should execute ng-click and change url when ng-href specified', function() {
          expect(element('#link-3').attr('href')).toBe("/123");

          element('#link-3').click();
          expect(browser().window().path()).toEqual('/123');
        });

     it('should execute ng-click but not reload when href empty string and name specified', function() {
          element('#link-4').click();
          expect(input('value').val()).toEqual('4');
          expect(element('#link-4').attr('href')).toBe('');
        });

     it('should execute ng-click but not reload when no href but name specified', function() {
          element('#link-5').click();
          expect(input('value').val()).toEqual('5');
          expect(element('#link-5').attr('href')).toBe(undefined);
        });

     it('should only change url when only ng-href', function() {
          input('value').enter('6');
          expect(element('#link-6').attr('href')).toBe('6');

          element('#link-6').click();
          expect(browser().location().url()).toEqual('/6');
        });
     </doc:scenario>
     </doc:example>
     */

    /**
     * @ngdoc directive
     * @name ng.directive:ngSrc
     * @restrict A
     *
     * @description
     * Using Angular markup like `{{hash}}` in a `src` attribute doesn't
     * work right: The browser will fetch from the URL with the literal
     * text `{{hash}}` until Angular replaces the expression inside
     * `{{hash}}`. The `ngSrc` directive solves this problem.
     *
     * The buggy way to write it:
     * <pre>
     * <img src="http://www.gravatar.com/avatar/{{hash}}"/>
     * </pre>
     *
     * The correct way to write it:
     * <pre>
     * <img ng-src="http://www.gravatar.com/avatar/{{hash}}"/>
     * </pre>
     *
     * @element IMG
     * @param {template} ngSrc any string which can contain `{{}}` markup.
     */

    /**
     * @ngdoc directive
     * @name ng.directive:ngSrcset
     * @restrict A
     *
     * @description
     * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't
     * work right: The browser will fetch from the URL with the literal
     * text `{{hash}}` until Angular replaces the expression inside
     * `{{hash}}`. The `ngSrcset` directive solves this problem.
     *
     * The buggy way to write it:
     * <pre>
     * <img srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
     * </pre>
     *
     * The correct way to write it:
     * <pre>
     * <img ng-srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
     * </pre>
     *
     * @element IMG
     * @param {template} ngSrcset any string which can contain `{{}}` markup.
     */

    /**
     * @ngdoc directive
     * @name ng.directive:ngDisabled
     * @restrict A
     *
     * @description
     *
     * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
     * <pre>
     * <div ng-init="scope = { isDisabled: false }">
     *  <button disabled="{{scope.isDisabled}}">Disabled</button>
     * </div>
     * </pre>
     *
     * The HTML specs do not require browsers to preserve the special attributes such as disabled.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce the `ngDisabled` directive.
     *
     * @example
     <doc:example>
     <doc:source>
     Click me to toggle: <input type="checkbox" ng-model="checked"><br/>
     <button ng-model="button" ng-disabled="checked">Button</button>
     </doc:source>
     <doc:scenario>
     it('should toggle button', function() {
          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();
          input('checked').check();
          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();
        });
     </doc:scenario>
     </doc:example>
     *
     * @element INPUT
     * @param {expression} ngDisabled Angular expression that will be evaluated.
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngChecked
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as checked.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce the `ngChecked` directive.
     * @example
     <doc:example>
     <doc:source>
     Check me to check both: <input type="checkbox" ng-model="master"><br/>
     <input id="checkSlave" type="checkbox" ng-checked="master">
     </doc:source>
     <doc:scenario>
     it('should check both checkBoxes', function() {
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();
          input('master').check();
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();
        });
     </doc:scenario>
     </doc:example>
     *
     * @element INPUT
     * @param {expression} ngChecked Angular expression that will be evaluated.
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngMultiple
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as multiple.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce the `ngMultiple` directive.
     *
     * @example
     <doc:example>
     <doc:source>
     Check me check multiple: <input type="checkbox" ng-model="checked"><br/>
     <select id="select" ng-multiple="checked">
     <option>Misko</option>
     <option>Igor</option>
     <option>Vojta</option>
     <option>Di</option>
     </select>
     </doc:source>
     <doc:scenario>
     it('should toggle multiple', function() {
           expect(element('.doc-example-live #select').prop('multiple')).toBeFalsy();
           input('checked').check();
           expect(element('.doc-example-live #select').prop('multiple')).toBeTruthy();
         });
     </doc:scenario>
     </doc:example>
     *
     * @element SELECT
     * @param {expression} ngMultiple Angular expression that will be evaluated.
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngReadonly
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as readonly.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce the `ngReadonly` directive.
     * @example
     <doc:example>
     <doc:source>
     Check me to make text readonly: <input type="checkbox" ng-model="checked"><br/>
     <input type="text" ng-readonly="checked" value="I'm Angular"/>
     </doc:source>
     <doc:scenario>
     it('should toggle readonly attr', function() {
          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();
          input('checked').check();
          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();
        });
     </doc:scenario>
     </doc:example>
     *
     * @element INPUT
     * @param {string} expression Angular expression that will be evaluated.
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngSelected
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as selected.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduced the `ngSelected` directive.
     * @example
     <doc:example>
     <doc:source>
     Check me to select: <input type="checkbox" ng-model="selected"><br/>
     <select>
     <option>Hello!</option>
     <option id="greet" ng-selected="selected">Greetings!</option>
     </select>
     </doc:source>
     <doc:scenario>
     it('should select Greetings!', function() {
          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();
          input('selected').check();
          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();
        });
     </doc:scenario>
     </doc:example>
     *
     * @element OPTION
     * @param {string} expression Angular expression that will be evaluated.
     */

    /**
     * @ngdoc directive
     * @name ng.directive:ngOpen
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as open.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce the `ngOpen` directive.
     *
     * @example
     <doc:example>
     <doc:source>
     Check me check multiple: <input type="checkbox" ng-model="open"><br/>
     <details id="details" ng-open="open">
     <summary>Show/Hide me</summary>
     </details>
     </doc:source>
     <doc:scenario>
     it('should toggle open', function() {
           expect(element('#details').prop('open')).toBeFalsy();
           input('open').check();
           expect(element('#details').prop('open')).toBeTruthy();
         });
     </doc:scenario>
     </doc:example>
     *
     * @element DETAILS
     * @param {string} expression Angular expression that will be evaluated.
     */

    var ngAttributeAliasDirectives = {};


// boolean attrs are evaluated
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 100,
                compile: function() {
                    return function(scope, element, attr) {
                        scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                            attr.$set(attrName, !!value);
                        });
                    };
                }
            };
        };
    });


// ng-src, ng-srcset, ng-href are interpolated
    forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99, // it needs to run after the attributes are interpolated
                link: function(scope, element, attr) {
                    attr.$observe(normalized, function(value) {
                        if (!value)
                            return;

                        attr.$set(attrName, value);

                        // on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist
                        // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need
                        // to set the property as well to achieve the desired effect.
                        // we use attr[attrName] value since $set can sanitize the url.
                        if (msie) element.prop(attrName, attr[attrName]);
                    });
                }
            };
        };
    });

    var nullFormCtrl = {
        $addControl: noop,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop
    };

    /**
     * @ngdoc object
     * @name ng.directive:form.FormController
     *
     * @property {boolean} $pristine True if user has not interacted with the form yet.
     * @property {boolean} $dirty True if user has already interacted with the form.
     * @property {boolean} $valid True if all of the containing forms and controls are valid.
     * @property {boolean} $invalid True if at least one containing control or form is invalid.
     *
     * @property {Object} $error Is an object hash, containing references to all invalid controls or
     *  forms, where:
     *
     *  - keys are validation tokens (error names) â€” such as `required`, `url` or `email`),
     *  - values are arrays of controls or forms that are invalid with given error.
     *
     * @description
     * `FormController` keeps track of all its controls and nested forms as well as state of them,
     * such as being valid/invalid or dirty/pristine.
     *
     * Each {@link ng.directive:form form} directive creates an instance
     * of `FormController`.
     *
     */
//asks for $scope to fool the BC controller module
    FormController.$inject = ['$element', '$attrs', '$scope'];
    function FormController(element, attrs) {
        var form = this,
            parentForm = element.parent().controller('form') || nullFormCtrl,
            invalidCount = 0, // used to easily determine if we are valid
            errors = form.$error = {},
            controls = [];

        // init state
        form.$name = attrs.name;
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;

        parentForm.$addControl(form);

        // Setup initial state of the control
        element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);

        // convenience method for easy toggling of classes
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
            element.
                removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
                addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }

        form.$addControl = function(control) {
            controls.push(control);

            if (control.$name && !form.hasOwnProperty(control.$name)) {
                form[control.$name] = control;
            }
        };

        form.$removeControl = function(control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name];
            }
            forEach(errors, function(queue, validationToken) {
                form.$setValidity(validationToken, true, control);
            });

            arrayRemove(controls, control);
        };

        form.$setValidity = function(validationToken, isValid, control) {
            var queue = errors[validationToken];

            if (isValid) {
                if (queue) {
                    arrayRemove(queue, control);
                    if (!queue.length) {
                        invalidCount--;
                        if (!invalidCount) {
                            toggleValidCss(isValid);
                            form.$valid = true;
                            form.$invalid = false;
                        }
                        errors[validationToken] = false;
                        toggleValidCss(true, validationToken);
                        parentForm.$setValidity(validationToken, true, form);
                    }
                }

            } else {
                if (!invalidCount) {
                    toggleValidCss(isValid);
                }
                if (queue) {
                    if (includes(queue, control)) return;
                } else {
                    errors[validationToken] = queue = [];
                    invalidCount++;
                    toggleValidCss(false, validationToken);
                    parentForm.$setValidity(validationToken, false, form);
                }
                queue.push(control);

                form.$valid = false;
                form.$invalid = true;
            }
        };

        form.$setDirty = function() {
            element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
            form.$dirty = true;
            form.$pristine = false;
            parentForm.$setDirty();
        };

        /**
         * @ngdoc function
         * @name ng.directive:form.FormController#$setPristine
         * @methodOf ng.directive:form.FormController
         *
         * @description
         * Sets the form to its pristine state.
         *
         * This method can be called to remove the 'ng-dirty' class and set the form to its pristine
         * state (ng-pristine class). This method will also propagate to all the controls contained
         * in this form.
         *
         * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
         * saving or resetting it.
         */
        form.$setPristine = function () {
            element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
            form.$dirty = false;
            form.$pristine = true;
            forEach(controls, function(control) {
                control.$setPristine();
            });
        };
    }


    /**
     * @ngdoc directive
     * @name ng.directive:ngForm
     * @restrict EAC
     *
     * @description
     * Nestable alias of {@link ng.directive:form `form`} directive. HTML
     * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
     * sub-group of controls needs to be determined.
     *
     * @param {string=} name|ngForm Name of the form. If specified, the form controller will be published into
     *                       related scope, under this name.
     *
     */

    /**
     * @ngdoc directive
     * @name ng.directive:form
     * @restrict E
     *
     * @description
     * Directive that instantiates
     * {@link ng.directive:form.FormController FormController}.
     *
     * If `name` attribute is specified, the form controller is published onto the current scope under
     * this name.
     *
     * # Alias: {@link ng.directive:ngForm `ngForm`}
     *
     * In angular forms can be nested. This means that the outer form is valid when all of the child
     * forms are valid as well. However browsers do not allow nesting of `<form>` elements, for this
     * reason angular provides {@link ng.directive:ngForm `ngForm`} alias
     * which behaves identical to `<form>` but allows form nesting.
     *
     *
     * # CSS classes
     *  - `ng-valid` Is set if the form is valid.
     *  - `ng-invalid` Is set if the form is invalid.
     *  - `ng-pristine` Is set if the form is pristine.
     *  - `ng-dirty` Is set if the form is dirty.
     *
     *
     * # Submitting a form and preventing default action
     *
     * Since the role of forms in client-side Angular applications is different than in classical
     * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
     * page reload that sends the data to the server. Instead some javascript logic should be triggered
     * to handle the form submission in application specific way.
     *
     * For this reason, Angular prevents the default action (form submission to the server) unless the
     * `<form>` element has an `action` attribute specified.
     *
     * You can use one of the following two ways to specify what javascript method should be called when
     * a form is submitted:
     *
     * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
     * - {@link ng.directive:ngClick ngClick} directive on the first
     *  button or input field of type submit (input[type=submit])
     *
     * To prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This
     * is because of the following form submission rules coming from the html spec:
     *
     * - If a form has only one input field then hitting enter in this field triggers form submit
     * (`ngSubmit`)
     * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter
     * doesn't trigger submit
     * - if a form has one or more input fields and one or more buttons or input[type=submit] then
     * hitting enter in any of the input fields will trigger the click handler on the *first* button or
     * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
     *
     * @param {string=} name Name of the form. If specified, the form controller will be published into
     *                       related scope, under this name.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.userType = 'guest';
         }
     </script>
     <form name="myForm" ng-controller="Ctrl">
     userType: <input name="input" ng-model="userType" required>
     <span class="error" ng-show="myForm.input.$error.required">Required!</span><br>
     <tt>userType = {{userType}}</tt><br>
     <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>
     <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>
     <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
     <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
     </form>
     </doc:source>
     <doc:scenario>
     it('should initialize to model', function() {
         expect(binding('userType')).toEqual('guest');
         expect(binding('myForm.input.$valid')).toEqual('true');
        });

     it('should be invalid if empty', function() {
         input('userType').enter('');
         expect(binding('userType')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
        });
     </doc:scenario>
     </doc:example>
     */
    var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', function($timeout) {
            var formDirective = {
                name: 'form',
                restrict: 'E',
                controller: FormController,
                compile: function() {
                    return {
                        pre: function(scope, formElement, attr, controller) {
                            if (!attr.action) {
                                // we can't use jq events because if a form is destroyed during submission the default
                                // action is not prevented. see #1238
                                //
                                // IE 9 is not affected because it doesn't fire a submit event and try to do a full
                                // page reload if the form was destroyed by submission of the form via a click handler
                                // on a button in the form. Looks like an IE9 specific bug.
                                var preventDefaultListener = function(event) {
                                    event.preventDefault
                                        ? event.preventDefault()
                                        : event.returnValue = false; // IE
                                };

                                addEventListenerFn(formElement[0], 'submit', preventDefaultListener);

                                // unregister the preventDefault listener so that we don't not leak memory but in a
                                // way that will achieve the prevention of the default action.
                                formElement.bind('$destroy', function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                                    }, 0, false);
                                });
                            }

                            var parentFormCtrl = formElement.parent().controller('form'),
                                alias = attr.name || attr.ngForm;

                            if (alias) {
                                scope[alias] = controller;
                            }
                            if (parentFormCtrl) {
                                formElement.bind('$destroy', function() {
                                    parentFormCtrl.$removeControl(controller);
                                    if (alias) {
                                        scope[alias] = undefined;
                                    }
                                    extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
                                });
                            }
                        }
                    };
                }
            };

            return isNgForm ? extend(copy(formDirective), {restrict: 'EAC'}) : formDirective;
        }];
    };

    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);

    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

    var inputType = {

        /**
         * @ngdoc inputType
         * @name ng.directive:input.text
         *
         * @description
         * Standard HTML text input with angular data binding.
         *
         * @param {string} ngModel Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} required Adds `required` validation error key if the value is not entered.
         * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
         *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
         *    `required` when you want to data-bind to the `required` attribute.
         * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
         *    minlength.
         * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
         *    maxlength.
         * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
         *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
         *    patterns defined as scope expressions.
         * @param {string=} ngChange Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trimming the
         *    input.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
             $scope.text = 'guest';
             $scope.word = /^\s*\w*\s*$/;
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         Single word: <input type="text" name="input" ng-model="text"
         ng-pattern="word" required ng-trim="false">
         <span class="error" ng-show="myForm.input.$error.required">
         Required!</span>
         <span class="error" ng-show="myForm.input.$error.pattern">
         Single word only!</span>

         <tt>text = {{text}}</tt><br/>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should initialize to model', function() {
            expect(binding('text')).toEqual('guest');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

         it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

         it('should be invalid if multi word', function() {
            input('text').enter('hello world');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

         it('should not be trimmed', function() {
            input('text').enter('untrimmed ');
            expect(binding('text')).toEqual('untrimmed ');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });
         </doc:scenario>
         </doc:example>
         */
        'text': textInputType,


        /**
         * @ngdoc inputType
         * @name ng.directive:input.number
         *
         * @description
         * Text input with number validation and transformation. Sets the `number` validation
         * error if not a valid number.
         *
         * @param {string} ngModel Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
         * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
         * @param {string=} required Sets `required` validation error key if the value is not entered.
         * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
         *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
         *    `required` when you want to data-bind to the `required` attribute.
         * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
         *    minlength.
         * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
         *    maxlength.
         * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
         *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
         *    patterns defined as scope expressions.
         * @param {string=} ngChange Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
             $scope.value = 12;
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         Number: <input type="number" name="input" ng-model="value"
         min="0" max="99" required>
         <span class="error" ng-show="myForm.list.$error.required">
         Required!</span>
         <span class="error" ng-show="myForm.list.$error.number">
         Not valid number!</span>
         <tt>value = {{value}}</tt><br/>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should initialize to model', function() {
           expect(binding('value')).toEqual('12');
           expect(binding('myForm.input.$valid')).toEqual('true');
          });

         it('should be invalid if empty', function() {
           input('value').enter('');
           expect(binding('value')).toEqual('');
           expect(binding('myForm.input.$valid')).toEqual('false');
          });

         it('should be invalid if over max', function() {
           input('value').enter('123');
           expect(binding('value')).toEqual('');
           expect(binding('myForm.input.$valid')).toEqual('false');
          });
         </doc:scenario>
         </doc:example>
         */
        'number': numberInputType,


        /**
         * @ngdoc inputType
         * @name ng.directive:input.url
         *
         * @description
         * Text input with URL validation. Sets the `url` validation error key if the content is not a
         * valid URL.
         *
         * @param {string} ngModel Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} required Sets `required` validation error key if the value is not entered.
         * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
         *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
         *    `required` when you want to data-bind to the `required` attribute.
         * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
         *    minlength.
         * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
         *    maxlength.
         * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
         *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
         *    patterns defined as scope expressions.
         * @param {string=} ngChange Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
             $scope.text = 'http://google.com';
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         URL: <input type="url" name="input" ng-model="text" required>
         <span class="error" ng-show="myForm.input.$error.required">
         Required!</span>
         <span class="error" ng-show="myForm.input.$error.url">
         Not valid url!</span>
         <tt>text = {{text}}</tt><br/>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
         <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should initialize to model', function() {
            expect(binding('text')).toEqual('http://google.com');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

         it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

         it('should be invalid if not url', function() {
            input('text').enter('xxx');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });
         </doc:scenario>
         </doc:example>
         */
        'url': urlInputType,


        /**
         * @ngdoc inputType
         * @name ng.directive:input.email
         *
         * @description
         * Text input with email validation. Sets the `email` validation error key if not a valid email
         * address.
         *
         * @param {string} ngModel Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} required Sets `required` validation error key if the value is not entered.
         * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
         *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
         *    `required` when you want to data-bind to the `required` attribute.
         * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
         *    minlength.
         * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
         *    maxlength.
         * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
         *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
         *    patterns defined as scope expressions.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
             $scope.text = 'me@example.com';
         }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         Email: <input type="email" name="input" ng-model="text" required>
         <span class="error" ng-show="myForm.input.$error.required">
         Required!</span>
         <span class="error" ng-show="myForm.input.$error.email">
         Not valid email!</span>
         <tt>text = {{text}}</tt><br/>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
         <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should initialize to model', function() {
            expect(binding('text')).toEqual('me@example.com');
         expect(binding('myForm.input.$valid')).toEqual('true');
         });

         it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

         it('should be invalid if not email', function() {
            input('text').enter('xxx');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });
         </doc:scenario>
         </doc:example>
         */
        'email': emailInputType,


        /**
         * @ngdoc inputType
         * @name ng.directive:input.radio
         *
         * @description
         * HTML radio button.
         *
         * @param {string} ngModel Assignable angular expression to data-bind to.
         * @param {string} value The value to which the expression should be set when selected.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} ngChange Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
             $scope.color = 'blue';
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         <input type="radio" ng-model="color" value="red">  Red <br/>
         <input type="radio" ng-model="color" value="green"> Green <br/>
         <input type="radio" ng-model="color" value="blue"> Blue <br/>
         <tt>color = {{color}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should change state', function() {
            expect(binding('color')).toEqual('blue');

            input('color').select('red');
            expect(binding('color')).toEqual('red');
          });
         </doc:scenario>
         </doc:example>
         */
        'radio': radioInputType,


        /**
         * @ngdoc inputType
         * @name ng.directive:input.checkbox
         *
         * @description
         * HTML checkbox.
         *
         * @param {string} ngModel Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} ngTrueValue The value to which the expression should be set when selected.
         * @param {string=} ngFalseValue The value to which the expression should be set when not selected.
         * @param {string=} ngChange Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
             $scope.value1 = true;
             $scope.value2 = 'YES'
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         Value1: <input type="checkbox" ng-model="value1"> <br/>
         Value2: <input type="checkbox" ng-model="value2"
         ng-true-value="YES" ng-false-value="NO"> <br/>
         <tt>value1 = {{value1}}</tt><br/>
         <tt>value2 = {{value2}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should change state', function() {
            expect(binding('value1')).toEqual('true');
            expect(binding('value2')).toEqual('YES');

            input('value1').check();
            input('value2').check();
            expect(binding('value1')).toEqual('false');
            expect(binding('value2')).toEqual('NO');
          });
         </doc:scenario>
         </doc:example>
         */
        'checkbox': checkboxInputType,

        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop
    };


    function isEmpty(value) {
        return isUndefined(value) || value === '' || value === null || value !== value;
    }


    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {

        var listener = function() {
            var value = element.val();

            // By default we will trim the value
            // If the attribute ng-trim exists we will avoid trimming
            // e.g. <input ng-model="foo" ng-trim="false">
            if (toBoolean(attr.ngTrim || 'T')) {
                value = trim(value);
            }

            if (ctrl.$viewValue !== value) {
                scope.$apply(function() {
                    ctrl.$setViewValue(value);
                });
            }
        };

        // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
        // input event on backspace, delete or cut
        if ($sniffer.hasEvent('input')) {
            element.bind('input', listener);
        } else {
            var timeout;

            var deferListener = function() {
                if (!timeout) {
                    timeout = $browser.defer(function() {
                        listener();
                        timeout = null;
                    });
                }
            };

            element.bind('keydown', function(event) {
                var key = event.keyCode;

                // ignore
                //    command            modifiers                   arrows
                if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;

                deferListener();
            });

            // if user paste into input using mouse, we need "change" event to catch it
            element.bind('change', listener);

            // if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
            if ($sniffer.hasEvent('paste')) {
                element.bind('paste cut', deferListener);
            }
        }


        ctrl.$render = function() {
            element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
        };

        // pattern validator
        var pattern = attr.ngPattern,
            patternValidator,
            match;

        var validate = function(regexp, value) {
            if (isEmpty(value) || regexp.test(value)) {
                ctrl.$setValidity('pattern', true);
                return value;
            } else {
                ctrl.$setValidity('pattern', false);
                return undefined;
            }
        };

        if (pattern) {
            match = pattern.match(/^\/(.*)\/([gim]*)$/);
            if (match) {
                pattern = new RegExp(match[1], match[2]);
                patternValidator = function(value) {
                    return validate(pattern, value)
                };
            } else {
                patternValidator = function(value) {
                    var patternObj = scope.$eval(pattern);

                    if (!patternObj || !patternObj.test) {
                        throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);
                    }
                    return validate(patternObj, value);
                };
            }

            ctrl.$formatters.push(patternValidator);
            ctrl.$parsers.push(patternValidator);
        }

        // min length validator
        if (attr.ngMinlength) {
            var minlength = int(attr.ngMinlength);
            var minLengthValidator = function(value) {
                if (!isEmpty(value) && value.length < minlength) {
                    ctrl.$setValidity('minlength', false);
                    return undefined;
                } else {
                    ctrl.$setValidity('minlength', true);
                    return value;
                }
            };

            ctrl.$parsers.push(minLengthValidator);
            ctrl.$formatters.push(minLengthValidator);
        }

        // max length validator
        if (attr.ngMaxlength) {
            var maxlength = int(attr.ngMaxlength);
            var maxLengthValidator = function(value) {
                if (!isEmpty(value) && value.length > maxlength) {
                    ctrl.$setValidity('maxlength', false);
                    return undefined;
                } else {
                    ctrl.$setValidity('maxlength', true);
                    return value;
                }
            };

            ctrl.$parsers.push(maxLengthValidator);
            ctrl.$formatters.push(maxLengthValidator);
        }
    }

    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);

        ctrl.$parsers.push(function(value) {
            var empty = isEmpty(value);
            if (empty || NUMBER_REGEXP.test(value)) {
                ctrl.$setValidity('number', true);
                return value === '' ? null : (empty ? value : parseFloat(value));
            } else {
                ctrl.$setValidity('number', false);
                return undefined;
            }
        });

        ctrl.$formatters.push(function(value) {
            return isEmpty(value) ? '' : '' + value;
        });

        if (attr.min) {
            var min = parseFloat(attr.min);
            var minValidator = function(value) {
                if (!isEmpty(value) && value < min) {
                    ctrl.$setValidity('min', false);
                    return undefined;
                } else {
                    ctrl.$setValidity('min', true);
                    return value;
                }
            };

            ctrl.$parsers.push(minValidator);
            ctrl.$formatters.push(minValidator);
        }

        if (attr.max) {
            var max = parseFloat(attr.max);
            var maxValidator = function(value) {
                if (!isEmpty(value) && value > max) {
                    ctrl.$setValidity('max', false);
                    return undefined;
                } else {
                    ctrl.$setValidity('max', true);
                    return value;
                }
            };

            ctrl.$parsers.push(maxValidator);
            ctrl.$formatters.push(maxValidator);
        }

        ctrl.$formatters.push(function(value) {

            if (isEmpty(value) || isNumber(value)) {
                ctrl.$setValidity('number', true);
                return value;
            } else {
                ctrl.$setValidity('number', false);
                return undefined;
            }
        });
    }

    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);

        var urlValidator = function(value) {
            if (isEmpty(value) || URL_REGEXP.test(value)) {
                ctrl.$setValidity('url', true);
                return value;
            } else {
                ctrl.$setValidity('url', false);
                return undefined;
            }
        };

        ctrl.$formatters.push(urlValidator);
        ctrl.$parsers.push(urlValidator);
    }

    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);

        var emailValidator = function(value) {
            if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
                ctrl.$setValidity('email', true);
                return value;
            } else {
                ctrl.$setValidity('email', false);
                return undefined;
            }
        };

        ctrl.$formatters.push(emailValidator);
        ctrl.$parsers.push(emailValidator);
    }

    function radioInputType(scope, element, attr, ctrl) {
        // make the name unique, if not defined
        if (isUndefined(attr.name)) {
            element.attr('name', nextUid());
        }

        element.bind('click', function() {
            if (element[0].checked) {
                scope.$apply(function() {
                    ctrl.$setViewValue(attr.value);
                });
            }
        });

        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = (value == ctrl.$viewValue);
        };

        attr.$observe('value', ctrl.$render);
    }

    function checkboxInputType(scope, element, attr, ctrl) {
        var trueValue = attr.ngTrueValue,
            falseValue = attr.ngFalseValue;

        if (!isString(trueValue)) trueValue = true;
        if (!isString(falseValue)) falseValue = false;

        element.bind('click', function() {
            scope.$apply(function() {
                ctrl.$setViewValue(element[0].checked);
            });
        });

        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };

        ctrl.$formatters.push(function(value) {
            return value === trueValue;
        });

        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }


    /**
     * @ngdoc directive
     * @name ng.directive:textarea
     * @restrict E
     *
     * @description
     * HTML textarea element control with angular data-binding. The data-binding and validation
     * properties of this element are exactly the same as those of the
     * {@link ng.directive:input input element}.
     *
     * @param {string} ngModel Assignable angular expression to data-bind to.
     * @param {string=} name Property name of the form under which the control is published.
     * @param {string=} required Sets `required` validation error key if the value is not entered.
     * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
     *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
     *    `required` when you want to data-bind to the `required` attribute.
     * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
     *    minlength.
     * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
     *    maxlength.
     * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
     *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
     *    patterns defined as scope expressions.
     * @param {string=} ngChange Angular expression to be executed when input changes due to user
     *    interaction with the input element.
     */


    /**
     * @ngdoc directive
     * @name ng.directive:input
     * @restrict E
     *
     * @description
     * HTML input element control with angular data-binding. Input control follows HTML5 input types
     * and polyfills the HTML5 validation behavior for older browsers.
     *
     * @param {string} ngModel Assignable angular expression to data-bind to.
     * @param {string=} name Property name of the form under which the control is published.
     * @param {string=} required Sets `required` validation error key if the value is not entered.
     * @param {boolean=} ngRequired Sets `required` attribute if set to true
     * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
     *    minlength.
     * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
     *    maxlength.
     * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
     *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
     *    patterns defined as scope expressions.
     * @param {string=} ngChange Angular expression to be executed when input changes due to user
     *    interaction with the input element.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.user = {name: 'guest', last: 'visitor'};
         }
     </script>
     <div ng-controller="Ctrl">
     <form name="myForm">
     User name: <input type="text" name="userName" ng-model="user.name" required>
     <span class="error" ng-show="myForm.userName.$error.required">
     Required!</span><br>
     Last name: <input type="text" name="lastName" ng-model="user.last"
     ng-minlength="3" ng-maxlength="10">
     <span class="error" ng-show="myForm.lastName.$error.minlength">
     Too short!</span>
     <span class="error" ng-show="myForm.lastName.$error.maxlength">
     Too long!</span><br>
     </form>
     <hr>
     <tt>user = {{user}}</tt><br/>
     <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>
     <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>
     <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>
     <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>
     <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
     <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
     <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>
     <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>
     </div>
     </doc:source>
     <doc:scenario>
     it('should initialize to model', function() {
          expect(binding('user')).toEqual('{"name":"guest","last":"visitor"}');
          expect(binding('myForm.userName.$valid')).toEqual('true');
          expect(binding('myForm.$valid')).toEqual('true');
        });

     it('should be invalid if empty when required', function() {
          input('user.name').enter('');
          expect(binding('user')).toEqual('{"last":"visitor"}');
          expect(binding('myForm.userName.$valid')).toEqual('false');
          expect(binding('myForm.$valid')).toEqual('false');
        });

     it('should be valid if empty when min length is set', function() {
          input('user.last').enter('');
          expect(binding('user')).toEqual('{"name":"guest","last":""}');
          expect(binding('myForm.lastName.$valid')).toEqual('true');
          expect(binding('myForm.$valid')).toEqual('true');
        });

     it('should be invalid if less than required min length', function() {
          input('user.last').enter('xx');
          expect(binding('user')).toEqual('{"name":"guest"}');
          expect(binding('myForm.lastName.$valid')).toEqual('false');
          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);
          expect(binding('myForm.$valid')).toEqual('false');
        });

     it('should be invalid if longer than max length', function() {
          input('user.last').enter('some ridiculously long name');
          expect(binding('user'))
            .toEqual('{"name":"guest"}');
          expect(binding('myForm.lastName.$valid')).toEqual('false');
          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);
          expect(binding('myForm.$valid')).toEqual('false');
        });
     </doc:scenario>
     </doc:example>
     */
    var inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {
        return {
            restrict: 'E',
            require: '?ngModel',
            link: function(scope, element, attr, ctrl) {
                if (ctrl) {
                    (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,
                        $browser);
                }
            }
        };
    }];

    var VALID_CLASS = 'ng-valid',
        INVALID_CLASS = 'ng-invalid',
        PRISTINE_CLASS = 'ng-pristine',
        DIRTY_CLASS = 'ng-dirty';

    /**
     * @ngdoc object
     * @name ng.directive:ngModel.NgModelController
     *
     * @property {string} $viewValue Actual string value in the view.
     * @property {*} $modelValue The value in the model, that the control is bound to.
     * @property {Array.<Function>} $parsers Whenever the control reads value from the DOM, it executes
     *     all of these functions to sanitize / convert the value as well as validate.
     *
     * @property {Array.<Function>} $formatters Whenever the model value changes, it executes all of
     *     these functions to convert the value as well as validate.
     *
     * @property {Object} $error An object hash with all errors as keys.
     *
     * @property {boolean} $pristine True if user has not interacted with the control yet.
     * @property {boolean} $dirty True if user has already interacted with the control.
     * @property {boolean} $valid True if there is no error.
     * @property {boolean} $invalid True if at least one error on the control.
     *
     * @description
     *
     * `NgModelController` provides API for the `ng-model` directive. The controller contains
     * services for data-binding, validation, CSS update, value formatting and parsing. It
     * specifically does not contain any logic which deals with DOM rendering or listening to
     * DOM events. The `NgModelController` is meant to be extended by other directives where, the
     * directive provides DOM manipulation and the `NgModelController` provides the data-binding.
     *
     * This example shows how to use `NgModelController` with a custom control to achieve
     * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)
     * collaborate together to achieve the desired result.
     *
     * <example module="customControl">
     <file name="style.css">
     [contenteditable] {
        border: 1px solid black;
        background-color: white;
        min-height: 20px;
      }

     .ng-invalid {
        border: 1px solid red;
      }

     </file>
     <file name="script.js">
     angular.module('customControl', []).
     directive('contenteditable', function() {
          return {
            restrict: 'A', // only activate on element attribute
            require: '?ngModel', // get a hold of NgModelController
            link: function(scope, element, attrs, ngModel) {
              if(!ngModel) return; // do nothing if no ng-model

              // Specify how UI should be updated
              ngModel.$render = function() {
                element.html(ngModel.$viewValue || '');
              };

              // Listen for change events to enable binding
              element.bind('blur keyup change', function() {
                scope.$apply(read);
              });
              read(); // initialize

              // Write data to the model
              function read() {
                ngModel.$setViewValue(element.html());
              }
            }
          };
        });
     </file>
     <file name="index.html">
     <form name="myForm">
     <div contenteditable
     name="myWidget" ng-model="userContent"
     required>Change me!</div>
     <span ng-show="myForm.myWidget.$error.required">Required!</span>
     <hr>
     <textarea ng-model="userContent"></textarea>
     </form>
     </file>
     <file name="scenario.js">
     it('should data-bind and become invalid', function() {
        var contentEditable = element('[contenteditable]');

        expect(contentEditable.text()).toEqual('Change me!');
        input('userContent').enter('');
        expect(contentEditable.text()).toEqual('');
        expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);
      });
     </file>
     * </example>
     *
     */
    var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',
        function($scope, $exceptionHandler, $attr, $element, $parse) {
            this.$viewValue = Number.NaN;
            this.$modelValue = Number.NaN;
            this.$parsers = [];
            this.$formatters = [];
            this.$viewChangeListeners = [];
            this.$pristine = true;
            this.$dirty = false;
            this.$valid = true;
            this.$invalid = false;
            this.$name = $attr.name;

            var ngModelGet = $parse($attr.ngModel),
                ngModelSet = ngModelGet.assign;

            if (!ngModelSet) {
                throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel +
                    ' (' + startingTag($element) + ')');
            }

            /**
             * @ngdoc function
             * @name ng.directive:ngModel.NgModelController#$render
             * @methodOf ng.directive:ngModel.NgModelController
             *
             * @description
             * Called when the view needs to be updated. It is expected that the user of the ng-model
             * directive will implement this method.
             */
            this.$render = noop;

            var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
                invalidCount = 0, // used to easily determine if we are valid
                $error = this.$error = {}; // keep invalid keys here


            // Setup initial state of the control
            $element.addClass(PRISTINE_CLASS);
            toggleValidCss(true);

            // convenience method for easy toggling of classes
            function toggleValidCss(isValid, validationErrorKey) {
                validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
                $element.
                    removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
                    addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
            }

            /**
             * @ngdoc function
             * @name ng.directive:ngModel.NgModelController#$setValidity
             * @methodOf ng.directive:ngModel.NgModelController
             *
             * @description
             * Change the validity state, and notifies the form when the control changes validity. (i.e. it
             * does not notify form if given validator is already marked as invalid).
             *
             * This method should be called by validators - i.e. the parser or formatter functions.
             *
             * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign
             *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.
             *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
             *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
             *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
             * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).
             */
            this.$setValidity = function(validationErrorKey, isValid) {
                if ($error[validationErrorKey] === !isValid) return;

                if (isValid) {
                    if ($error[validationErrorKey]) invalidCount--;
                    if (!invalidCount) {
                        toggleValidCss(true);
                        this.$valid = true;
                        this.$invalid = false;
                    }
                } else {
                    toggleValidCss(false);
                    this.$invalid = true;
                    this.$valid = false;
                    invalidCount++;
                }

                $error[validationErrorKey] = !isValid;
                toggleValidCss(isValid, validationErrorKey);

                parentForm.$setValidity(validationErrorKey, isValid, this);
            };

            /**
             * @ngdoc function
             * @name ng.directive:ngModel.NgModelController#$setPristine
             * @methodOf ng.directive:ngModel.NgModelController
             *
             * @description
             * Sets the control to its pristine state.
             *
             * This method can be called to remove the 'ng-dirty' class and set the control to its pristine
             * state (ng-pristine class).
             */
            this.$setPristine = function () {
                this.$dirty = false;
                this.$pristine = true;
                $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
            };

            /**
             * @ngdoc function
             * @name ng.directive:ngModel.NgModelController#$setViewValue
             * @methodOf ng.directive:ngModel.NgModelController
             *
             * @description
             * Read a value from view.
             *
             * This method should be called from within a DOM event handler.
             * For example {@link ng.directive:input input} or
             * {@link ng.directive:select select} directives call it.
             *
             * It internally calls all `parsers` and if resulted value is valid, updates the model and
             * calls all registered change listeners.
             *
             * @param {string} value Value from the view.
             */
            this.$setViewValue = function(value) {
                this.$viewValue = value;

                // change to dirty
                if (this.$pristine) {
                    this.$dirty = true;
                    this.$pristine = false;
                    $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
                    parentForm.$setDirty();
                }

                forEach(this.$parsers, function(fn) {
                    value = fn(value);
                });

                if (this.$modelValue !== value) {
                    this.$modelValue = value;
                    ngModelSet($scope, value);
                    forEach(this.$viewChangeListeners, function(listener) {
                        try {
                            listener();
                        } catch(e) {
                            $exceptionHandler(e);
                        }
                    })
                }
            };

            // model -> value
            var ctrl = this;

            $scope.$watch(function ngModelWatch() {
                var value = ngModelGet($scope);

                // if scope model value and ngModel value are out of sync
                if (ctrl.$modelValue !== value) {

                    var formatters = ctrl.$formatters,
                        idx = formatters.length;

                    ctrl.$modelValue = value;
                    while(idx--) {
                        value = formatters[idx](value);
                    }

                    if (ctrl.$viewValue !== value) {
                        ctrl.$viewValue = value;
                        ctrl.$render();
                    }
                }
            });
        }];


    /**
     * @ngdoc directive
     * @name ng.directive:ngModel
     *
     * @element input
     *
     * @description
     * Is directive that tells Angular to do two-way data binding. It works together with `input`,
     * `select`, `textarea`. You can easily write your own directives to use `ngModel` as well.
     *
     * `ngModel` is responsible for:
     *
     * - binding the view into the model, which other directives such as `input`, `textarea` or `select`
     *   require,
     * - providing validation behavior (i.e. required, number, email, url),
     * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),
     * - setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),
     * - register the control with parent {@link ng.directive:form form}.
     *
     * For basic examples, how to use `ngModel`, see:
     *
     *  - {@link ng.directive:input input}
     *    - {@link ng.directive:input.text text}
     *    - {@link ng.directive:input.checkbox checkbox}
     *    - {@link ng.directive:input.radio radio}
     *    - {@link ng.directive:input.number number}
     *    - {@link ng.directive:input.email email}
     *    - {@link ng.directive:input.url url}
     *  - {@link ng.directive:select select}
     *  - {@link ng.directive:textarea textarea}
     *
     */
    var ngModelDirective = function() {
        return {
            require: ['ngModel', '^?form'],
            controller: NgModelController,
            link: function(scope, element, attr, ctrls) {
                // notify others, especially parent forms

                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || nullFormCtrl;

                formCtrl.$addControl(modelCtrl);

                element.bind('$destroy', function() {
                    formCtrl.$removeControl(modelCtrl);
                });
            }
        };
    };


    /**
     * @ngdoc directive
     * @name ng.directive:ngChange
     * @restrict E
     *
     * @description
     * Evaluate given expression when user changes the input.
     * The expression is not evaluated when the value change is coming from the model.
     *
     * Note, this directive requires `ngModel` to be present.
     *
     * @element input
     *
     * @example
     * <doc:example>
     *   <doc:source>
     *     <script>
     *       function Controller($scope) {
 *         $scope.counter = 0;
 *         $scope.change = function() {
 *           $scope.counter++;
 *         };
 *       }
     *     </script>
     *     <div ng-controller="Controller">
     *       <input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
     *       <input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
     *       <label for="ng-change-example2">Confirmed</label><br />
     *       debug = {{confirmed}}<br />
     *       counter = {{counter}}
     *     </div>
     *   </doc:source>
     *   <doc:scenario>
     *     it('should evaluate the expression if changing from view', function() {
 *       expect(binding('counter')).toEqual('0');
 *       element('#ng-change-example1').click();
 *       expect(binding('counter')).toEqual('1');
 *       expect(binding('confirmed')).toEqual('true');
 *     });
     *
     *     it('should not evaluate the expression if changing from model', function() {
 *       element('#ng-change-example2').click();
 *       expect(binding('counter')).toEqual('0');
 *       expect(binding('confirmed')).toEqual('true');
 *     });
     *   </doc:scenario>
     * </doc:example>
     */
    var ngChangeDirective = valueFn({
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });


    var requiredDirective = function() {
        return {
            require: '?ngModel',
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                attr.required = true; // force truthy in case we are on non input element

                var validator = function(value) {
                    if (attr.required && (isEmpty(value) || value === false)) {
                        ctrl.$setValidity('required', false);
                        return;
                    } else {
                        ctrl.$setValidity('required', true);
                        return value;
                    }
                };

                ctrl.$formatters.push(validator);
                ctrl.$parsers.unshift(validator);

                attr.$observe('required', function() {
                    validator(ctrl.$viewValue);
                });
            }
        };
    };


    /**
     * @ngdoc directive
     * @name ng.directive:ngList
     *
     * @description
     * Text input that converts between comma-separated string into an array of strings.
     *
     * @element input
     * @param {string=} ngList optional delimiter that should be used to split the value. If
     *   specified in form `/something/` then the value will be converted into a regular expression.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.names = ['igor', 'misko', 'vojta'];
         }
     </script>
     <form name="myForm" ng-controller="Ctrl">
     List: <input name="namesInput" ng-model="names" ng-list required>
     <span class="error" ng-show="myForm.list.$error.required">
     Required!</span>
     <tt>names = {{names}}</tt><br/>
     <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
     <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
     <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
     <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
     </form>
     </doc:source>
     <doc:scenario>
     it('should initialize to model', function() {
          expect(binding('names')).toEqual('["igor","misko","vojta"]');
          expect(binding('myForm.namesInput.$valid')).toEqual('true');
        });

     it('should be invalid if empty', function() {
          input('names').enter('');
          expect(binding('names')).toEqual('[]');
          expect(binding('myForm.namesInput.$valid')).toEqual('false');
        });
     </doc:scenario>
     </doc:example>
     */
    var ngListDirective = function() {
        return {
            require: 'ngModel',
            link: function(scope, element, attr, ctrl) {
                var match = /\/(.*)\//.exec(attr.ngList),
                    separator = match && new RegExp(match[1]) || attr.ngList || ',';

                var parse = function(viewValue) {
                    var list = [];

                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trim(value));
                        });
                    }

                    return list;
                };

                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value)) {
                        return value.join(', ');
                    }

                    return undefined;
                });
            }
        };
    };


    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;

    var ngValueDirective = function() {
        return {
            priority: 100,
            compile: function(tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function(scope, elm, attr) {
                        attr.$set('value', scope.$eval(attr.ngValue));
                    };
                } else {
                    return function(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            attr.$set('value', value, false);
                        });
                    };
                }
            }
        };
    };

    /**
     * @ngdoc directive
     * @name ng.directive:ngBind
     *
     * @description
     * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
     * with the value of a given expression, and to update the text content when the value of that
     * expression changes.
     *
     * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like
     * `{{ expression }}` which is similar but less verbose.
     *
     * One scenario in which the use of `ngBind` is preferred over `{{ expression }}` binding is when
     * it's desirable to put bindings into template that is momentarily displayed by the browser in its
     * raw state before Angular compiles it. Since `ngBind` is an element attribute, it makes the
     * bindings invisible to the user while the page is loading.
     *
     * An alternative solution to this problem would be using the
     * {@link ng.directive:ngCloak ngCloak} directive.
     *
     *
     * @element ANY
     * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
     *
     * @example
     * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.name = 'Whirled';
         }
     </script>
     <div ng-controller="Ctrl">
     Enter name: <input type="text" ng-model="name"><br>
     Hello <span ng-bind="name"></span>!
     </div>
     </doc:source>
     <doc:scenario>
     it('should check ng-bind', function() {
         expect(using('.doc-example-live').binding('name')).toBe('Whirled');
         using('.doc-example-live').input('name').enter('world');
         expect(using('.doc-example-live').binding('name')).toBe('world');
       });
     </doc:scenario>
     </doc:example>
     */
    var ngBindDirective = ngDirective(function(scope, element, attr) {
        element.addClass('ng-binding').data('$binding', attr.ngBind);
        scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
            element.text(value == undefined ? '' : value);
        });
    });


    /**
     * @ngdoc directive
     * @name ng.directive:ngBindTemplate
     *
     * @description
     * The `ngBindTemplate` directive specifies that the element
     * text should be replaced with the template in ngBindTemplate.
     * Unlike ngBind the ngBindTemplate can contain multiple `{{` `}}`
     * expressions. (This is required since some HTML elements
     * can not have SPAN elements such as TITLE, or OPTION to name a few.)
     *
     * @element ANY
     * @param {string} ngBindTemplate template of form
     *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
     *
     * @example
     * Try it here: enter text in text box and watch the greeting change.
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.salutation = 'Hello';
           $scope.name = 'World';
         }
     </script>
     <div ng-controller="Ctrl">
     Salutation: <input type="text" ng-model="salutation"><br>
     Name: <input type="text" ng-model="name"><br>
     <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
     </div>
     </doc:source>
     <doc:scenario>
     it('should check ng-bind', function() {
         expect(using('.doc-example-live').binding('salutation')).
           toBe('Hello');
         expect(using('.doc-example-live').binding('name')).
           toBe('World');
         using('.doc-example-live').input('salutation').enter('Greetings');
         using('.doc-example-live').input('name').enter('user');
         expect(using('.doc-example-live').binding('salutation')).
           toBe('Greetings');
         expect(using('.doc-example-live').binding('name')).
           toBe('user');
       });
     </doc:scenario>
     </doc:example>
     */
    var ngBindTemplateDirective = ['$interpolate', function($interpolate) {
        return function(scope, element, attr) {
            // TODO: move this to scenario runner
            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
            element.addClass('ng-binding').data('$binding', interpolateFn);
            attr.$observe('ngBindTemplate', function(value) {
                element.text(value);
            });
        }
    }];


    /**
     * @ngdoc directive
     * @name ng.directive:ngBindHtmlUnsafe
     *
     * @description
     * Creates a binding that will innerHTML the result of evaluating the `expression` into the current
     * element. *The innerHTML-ed content will not be sanitized!* You should use this directive only if
     * {@link ngSanitize.directive:ngBindHtml ngBindHtml} directive is too
     * restrictive and when you absolutely trust the source of the content you are binding to.
     *
     * See {@link ngSanitize.$sanitize $sanitize} docs for examples.
     *
     * @element ANY
     * @param {expression} ngBindHtmlUnsafe {@link guide/expression Expression} to evaluate.
     */
    var ngBindHtmlUnsafeDirective = [function() {
        return function(scope, element, attr) {
            element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);
            scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {
                element.html(value || '');
            });
        };
    }];

    function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ngDirective(function(scope, element, attr) {
            var oldVal = undefined;

            scope.$watch(attr[name], ngClassWatchAction, true);

            attr.$observe('class', function(value) {
                var ngClass = scope.$eval(attr[name]);
                ngClassWatchAction(ngClass, ngClass);
            });


            if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                    var mod = $index & 1;
                    if (mod !== old$index & 1) {
                        if (mod === selector) {
                            addClass(scope.$eval(attr[name]));
                        } else {
                            removeClass(scope.$eval(attr[name]));
                        }
                    }
                });
            }


            function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                    if (oldVal && !equals(newVal,oldVal)) {
                        removeClass(oldVal);
                    }
                    addClass(newVal);
                }
                oldVal = copy(newVal);
            }


            function removeClass(classVal) {
                if (isObject(classVal) && !isArray(classVal)) {
                    classVal = map(classVal, function(v, k) { if (v) return k });
                }
                element.removeClass(isArray(classVal) ? classVal.join(' ') : classVal);
            }


            function addClass(classVal) {
                if (isObject(classVal) && !isArray(classVal)) {
                    classVal = map(classVal, function(v, k) { if (v) return k });
                }
                if (classVal) {
                    element.addClass(isArray(classVal) ? classVal.join(' ') : classVal);
                }
            }
        });
    }

    /**
     * @ngdoc directive
     * @name ng.directive:ngClass
     *
     * @description
     * The `ngClass` allows you to set CSS class on HTML element dynamically by databinding an
     * expression that represents all classes to be added.
     *
     * The directive won't add duplicate classes if a particular class was already set.
     *
     * When the expression changes, the previously added classes are removed and only then the
     * new classes are added.
     *
     * @element ANY
     * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
     *   of the evaluation can be a string representing space delimited class
     *   names, an array, or a map of class names to boolean values.
     *
     * @example
     <example>
     <file name="index.html">
     <input type="button" value="set" ng-click="myVar='my-class'">
     <input type="button" value="clear" ng-click="myVar=''">
     <br>
     <span ng-class="myVar">Sample Text</span>
     </file>
     <file name="style.css">
     .my-class {
         color: red;
       }
     </file>
     <file name="scenario.js">
     it('should check ng-class', function() {
         expect(element('.doc-example-live span').prop('className')).not().
           toMatch(/my-class/);

         using('.doc-example-live').element(':button:first').click();

         expect(element('.doc-example-live span').prop('className')).
           toMatch(/my-class/);

         using('.doc-example-live').element(':button:last').click();

         expect(element('.doc-example-live span').prop('className')).not().
           toMatch(/my-class/);
       });
     </file>
     </example>
     */
    var ngClassDirective = classDirective('', true);

    /**
     * @ngdoc directive
     * @name ng.directive:ngClassOdd
     *
     * @description
     * The `ngClassOdd` and `ngClassEven` directives work exactly as
     * {@link ng.directive:ngClass ngClass}, except it works in
     * conjunction with `ngRepeat` and takes affect only on odd (even) rows.
     *
     * This directive can be applied only within a scope of an
     * {@link ng.directive:ngRepeat ngRepeat}.
     *
     * @element ANY
     * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
     *   of the evaluation can be a string representing space delimited class names or an array.
     *
     * @example
     <example>
     <file name="index.html">
     <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
     <li ng-repeat="name in names">
     <span ng-class-odd="'odd'" ng-class-even="'even'">
     {{name}}
     </span>
     </li>
     </ol>
     </file>
     <file name="style.css">
     .odd {
         color: red;
       }
     .even {
         color: blue;
       }
     </file>
     <file name="scenario.js">
     it('should check ng-class-odd and ng-class-even', function() {
         expect(element('.doc-example-live li:first span').prop('className')).
           toMatch(/odd/);
         expect(element('.doc-example-live li:last span').prop('className')).
           toMatch(/even/);
       });
     </file>
     </example>
     */
    var ngClassOddDirective = classDirective('Odd', 0);

    /**
     * @ngdoc directive
     * @name ng.directive:ngClassEven
     *
     * @description
     * The `ngClassOdd` and `ngClassEven` directives work exactly as
     * {@link ng.directive:ngClass ngClass}, except it works in
     * conjunction with `ngRepeat` and takes affect only on odd (even) rows.
     *
     * This directive can be applied only within a scope of an
     * {@link ng.directive:ngRepeat ngRepeat}.
     *
     * @element ANY
     * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
     *   result of the evaluation can be a string representing space delimited class names or an array.
     *
     * @example
     <example>
     <file name="index.html">
     <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
     <li ng-repeat="name in names">
     <span ng-class-odd="'odd'" ng-class-even="'even'">
     {{name}} &nbsp; &nbsp; &nbsp;
     </span>
     </li>
     </ol>
     </file>
     <file name="style.css">
     .odd {
         color: red;
       }
     .even {
         color: blue;
       }
     </file>
     <file name="scenario.js">
     it('should check ng-class-odd and ng-class-even', function() {
         expect(element('.doc-example-live li:first span').prop('className')).
           toMatch(/odd/);
         expect(element('.doc-example-live li:last span').prop('className')).
           toMatch(/even/);
       });
     </file>
     </example>
     */
    var ngClassEvenDirective = classDirective('Even', 1);

    /**
     * @ngdoc directive
     * @name ng.directive:ngCloak
     *
     * @description
     * The `ngCloak` directive is used to prevent the Angular html template from being briefly
     * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
     * directive to avoid the undesirable flicker effect caused by the html template display.
     *
     * The directive can be applied to the `<body>` element, but typically a fine-grained application is
     * preferred in order to benefit from progressive rendering of the browser view.
     *
     * `ngCloak` works in cooperation with a css rule that is embedded within `angular.js` and
     *  `angular.min.js` files. Following is the css rule:
     *
     * <pre>
     * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
 *   display: none;
 * }
     * </pre>
     *
     * When this css rule is loaded by the browser, all html elements (including their children) that
     * are tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive
     * during the compilation of the template it deletes the `ngCloak` element attribute, which
     * makes the compiled element visible.
     *
     * For the best result, `angular.js` script must be loaded in the head section of the html file;
     * alternatively, the css rule (above) must be included in the external stylesheet of the
     * application.
     *
     * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
     * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css
     * class `ngCloak` in addition to `ngCloak` directive as shown in the example below.
     *
     * @element ANY
     *
     * @example
     <doc:example>
     <doc:source>
     <div id="template1" ng-cloak>{{ 'hello' }}</div>
     <div id="template2" ng-cloak class="ng-cloak">{{ 'hello IE7' }}</div>
     </doc:source>
     <doc:scenario>
     it('should remove the template directive and css class', function() {
         expect(element('.doc-example-live #template1').attr('ng-cloak')).
           not().toBeDefined();
         expect(element('.doc-example-live #template2').attr('ng-cloak')).
           not().toBeDefined();
       });
     </doc:scenario>
     </doc:example>
     *
     */
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set('ngCloak', undefined);
            element.removeClass('ng-cloak');
        }
    });

    /**
     * @ngdoc directive
     * @name ng.directive:ngController
     *
     * @description
     * The `ngController` directive assigns behavior to a scope. This is a key aspect of how angular
     * supports the principles behind the Model-View-Controller design pattern.
     *
     * MVC components in angular:
     *
     * * Model â€” The Model is data in scope properties; scopes are attached to the DOM.
     * * View â€” The template (HTML with data bindings) is rendered into the View.
     * * Controller â€” The `ngController` directive specifies a Controller class; the class has
     *   methods that typically express the business logic behind the application.
     *
     * Note that an alternative way to define controllers is via the {@link ng.$route $route} service.
     *
     * @element ANY
     * @scope
     * @param {expression} ngController Name of a globally accessible constructor function or an
     *     {@link guide/expression expression} that on the current scope evaluates to a
     *     constructor function. The controller instance can further be published into the scope
     *     by adding `as localName` the controller name attribute.
     *
     * @example
     * Here is a simple form for editing user contact information. Adding, removing, clearing, and
     * greeting are methods declared on the controller (see source tab). These methods can
     * easily be called from the angular markup. Notice that the scope becomes the `this` for the
     * controller's instance. This allows for easy access to the view data from the controller. Also
     * notice that any changes to the data are automatically reflected in the View without the need
     * for a manual update. The example is included in two different declaration styles based on
     * your style preferences.
     <doc:example>
     <doc:source>
     <script>
     function SettingsController() {
          this.name = "John Smith";
          this.contacts = [
            {type: 'phone', value: '408 555 1212'},
            {type: 'email', value: 'john.smith@example.org'} ];
     };

     SettingsController.prototype.greet = function() {
          alert(this.name);
        };

     SettingsController.prototype.addContact = function() {
          this.contacts.push({type: 'email', value: 'yourname@example.org'});
     };

     SettingsController.prototype.removeContact = function(contactToRemove) {
         var index = this.contacts.indexOf(contactToRemove);
          this.contacts.splice(index, 1);
        };

     SettingsController.prototype.clearContact = function(contact) {
          contact.type = 'phone';
          contact.value = '';
        };
     </script>
     <div ng-controller="SettingsController as settings">
     Name: <input type="text" ng-model="settings.name"/>
     [ <a href="" ng-click="settings.greet()">greet</a> ]<br/>
     Contact:
     <ul>
     <li ng-repeat="contact in settings.contacts">
     <select ng-model="contact.type">
     <option>phone</option>
     <option>email</option>
     </select>
     <input type="text" ng-model="contact.value"/>
     [ <a href="" ng-click="settings.clearContact(contact)">clear</a>
     | <a href="" ng-click="settings.removeContact(contact)">X</a> ]
     </li>
     <li>[ <a href="" ng-click="settings.addContact()">add</a> ]</li>
     </ul>
     </div>
     </doc:source>
     <doc:scenario>
     it('should check controller', function() {
         expect(element('.doc-example-live div>:input').val()).toBe('John Smith');
         expect(element('.doc-example-live li:nth-child(1) input').val())
           .toBe('408 555 1212');
         expect(element('.doc-example-live li:nth-child(2) input').val())
           .toBe('john.smith@example.org');

     element('.doc-example-live li:first a:contains("clear")').click();
     expect(element('.doc-example-live li:first input').val()).toBe('');

     element('.doc-example-live li:last a:contains("add")').click();
     expect(element('.doc-example-live li:nth-child(3) input').val())
     .toBe('yourname@example.org');
     });
     </doc:scenario>
     </doc:example>



     <doc:example>
     <doc:source>
     <script>
     function SettingsController($scope) {
          $scope.name = "John Smith";
          $scope.contacts = [
            {type:'phone', value:'408 555 1212'},
            {type:'email', value:'john.smith@example.org'} ];

     $scope.greet = function() {
           alert(this.name);
          };

     $scope.addContact = function() {
           this.contacts.push({type:'email', value:'yourname@example.org'});
     };

     $scope.removeContact = function(contactToRemove) {
           var index = this.contacts.indexOf(contactToRemove);
           this.contacts.splice(index, 1);
          };

     $scope.clearContact = function(contact) {
           contact.type = 'phone';
           contact.value = '';
          };
     }
     </script>
     <div ng-controller="SettingsController">
     Name: <input type="text" ng-model="name"/>
     [ <a href="" ng-click="greet()">greet</a> ]<br/>
     Contact:
     <ul>
     <li ng-repeat="contact in contacts">
     <select ng-model="contact.type">
     <option>phone</option>
     <option>email</option>
     </select>
     <input type="text" ng-model="contact.value"/>
     [ <a href="" ng-click="clearContact(contact)">clear</a>
     | <a href="" ng-click="removeContact(contact)">X</a> ]
     </li>
     <li>[ <a href="" ng-click="addContact()">add</a> ]</li>
     </ul>
     </div>
     </doc:source>
     <doc:scenario>
     it('should check controller', function() {
         expect(element('.doc-example-live div>:input').val()).toBe('John Smith');
         expect(element('.doc-example-live li:nth-child(1) input').val())
           .toBe('408 555 1212');
         expect(element('.doc-example-live li:nth-child(2) input').val())
           .toBe('john.smith@example.org');

     element('.doc-example-live li:first a:contains("clear")').click();
     expect(element('.doc-example-live li:first input').val()).toBe('');

     element('.doc-example-live li:last a:contains("add")').click();
     expect(element('.doc-example-live li:nth-child(3) input').val())
     .toBe('yourname@example.org');
     });
     </doc:scenario>
     </doc:example>

     */
    var ngControllerDirective = [function() {
        return {
            scope: true,
            controller: '@'
        };
    }];

    /**
     * @ngdoc directive
     * @name ng.directive:ngCsp
     * @priority 1000
     *
     * @element html
     * @description
     * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.
     *
     * This is necessary when developing things like Google Chrome Extensions.
     *
     * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).
     * For us to be compatible, we just need to implement the "getterFn" in $parse without violating
     * any of these restrictions.
     *
     * AngularJS uses `Function(string)` generated functions as a speed optimization. By applying `ngCsp`
     * it is be possible to opt into the CSP compatible mode. When this mode is on AngularJS will
     * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will
     * be raised.
     *
     * In order to use this feature put `ngCsp` directive on the root element of the application.
     *
     * @example
     * This example shows how to apply the `ngCsp` directive to the `html` tag.
     <pre>
     <!doctype html>
     <html ng-app ng-csp>
     ...
     ...
     </html>
     </pre>
     */

    var ngCspDirective = ['$sniffer', function($sniffer) {
        return {
            priority: 1000,
            compile: function() {
                $sniffer.csp = true;
            }
        };
    }];

    /**
     * @ngdoc directive
     * @name ng.directive:ngClick
     *
     * @description
     * The ngClick allows you to specify custom behavior when
     * element is clicked.
     *
     * @element ANY
     * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
     * click. (Event object is available as `$event`)
     *
     * @example
     <doc:example>
     <doc:source>
     <button ng-click="count = count + 1" ng-init="count=0">
     Increment
     </button>
     count: {{count}}
     </doc:source>
     <doc:scenario>
     it('should check ng-click', function() {
         expect(binding('count')).toBe('0');
         element('.doc-example-live :button').click();
         expect(binding('count')).toBe('1');
       });
     </doc:scenario>
     </doc:example>
     */
    /*
     * A directive that allows creation of custom onclick handlers that are defined as angular
     * expressions and are compiled and executed within the current scope.
     *
     * Events that are handled via these handler are always configured not to propagate further.
     */
    var ngEventDirectives = {};
    forEach(
        'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress'.split(' '),
        function(name) {
            var directiveName = directiveNormalize('ng-' + name);
            ngEventDirectives[directiveName] = ['$parse', function($parse) {
                return function(scope, element, attr) {
                    var fn = $parse(attr[directiveName]);
                    element.bind(lowercase(name), function(event) {
                        scope.$apply(function() {
                            fn(scope, {$event:event});
                        });
                    });
                };
            }];
        }
    );

    /**
     * @ngdoc directive
     * @name ng.directive:ngDblclick
     *
     * @description
     * The `ngDblclick` directive allows you to specify custom behavior on dblclick event.
     *
     * @element ANY
     * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
     * dblclick. (Event object is available as `$event`)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngMousedown
     *
     * @description
     * The ngMousedown directive allows you to specify custom behavior on mousedown event.
     *
     * @element ANY
     * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
     * mousedown. (Event object is available as `$event`)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngMouseup
     *
     * @description
     * Specify custom behavior on mouseup event.
     *
     * @element ANY
     * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
     * mouseup. (Event object is available as `$event`)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */

    /**
     * @ngdoc directive
     * @name ng.directive:ngMouseover
     *
     * @description
     * Specify custom behavior on mouseover event.
     *
     * @element ANY
     * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
     * mouseover. (Event object is available as `$event`)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngMouseenter
     *
     * @description
     * Specify custom behavior on mouseenter event.
     *
     * @element ANY
     * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
     * mouseenter. (Event object is available as `$event`)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngMouseleave
     *
     * @description
     * Specify custom behavior on mouseleave event.
     *
     * @element ANY
     * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
     * mouseleave. (Event object is available as `$event`)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngMousemove
     *
     * @description
     * Specify custom behavior on mousemove event.
     *
     * @element ANY
     * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
     * mousemove. (Event object is available as `$event`)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngKeydown
     *
     * @description
     * Specify custom behavior on keydown event.
     *
     * @element ANY
     * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
     * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngKeyup
     *
     * @description
     * Specify custom behavior on keyup event.
     *
     * @element ANY
     * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
     * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngKeypress
     *
     * @description
     * Specify custom behavior on keypress event.
     *
     * @element ANY
     * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
     * keypress. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
     *
     * @example
     * See {@link ng.directive:ngClick ngClick}
     */


    /**
     * @ngdoc directive
     * @name ng.directive:ngSubmit
     *
     * @description
     * Enables binding angular expressions to onsubmit events.
     *
     * Additionally it prevents the default action (which for form means sending the request to the
     * server and reloading the current page).
     *
     * @element form
     * @param {expression} ngSubmit {@link guide/expression Expression} to eval.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
          $scope.list = [];
          $scope.text = 'hello';
          $scope.submit = function() {
            if (this.text) {
              this.list.push(this.text);
              this.text = '';
            }
          };
        }
     </script>
     <form ng-submit="submit()" ng-controller="Ctrl">
     Enter text and hit enter:
     <input type="text" ng-model="text" name="text" />
     <input type="submit" id="submit" value="Submit" />
     <pre>list={{list}}</pre>
     </form>
     </doc:source>
     <doc:scenario>
     it('should check ng-submit', function() {
         expect(binding('list')).toBe('[]');
         element('.doc-example-live #submit').click();
         expect(binding('list')).toBe('["hello"]');
         expect(input('text').val()).toBe('');
       });
     it('should ignore empty strings', function() {
         expect(binding('list')).toBe('[]');
         element('.doc-example-live #submit').click();
         element('.doc-example-live #submit').click();
         expect(binding('list')).toBe('["hello"]');
       });
     </doc:scenario>
     </doc:example>
     */
    var ngSubmitDirective = ngDirective(function(scope, element, attrs) {
        element.bind('submit', function() {
            scope.$apply(attrs.ngSubmit);
        });
    });

    /**
     * @ngdoc directive
     * @name ng.directive:ngIf
     * @restrict A
     *
     * @description
     * The `ngIf` directive removes and recreates a portion of the DOM tree (HTML)
     * conditionally based on **"falsy"** and **"truthy"** values, respectively, evaluated within
     * an {expression}. In other words, if the expression assigned to **ngIf evaluates to a false
     * value** then **the element is removed from the DOM** and **if true** then **a clone of the
     * element is reinserted into the DOM**.
     *
     * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
     * element in the DOM rather than changing its visibility via the `display` css property.  A common
     * case when this difference is significant is when using css selectors that rely on an element's
     * position within the DOM (HTML), such as the `:first-child` or `:last-child` pseudo-classes.
     *
     * Note that **when an element is removed using ngIf its scope is destroyed** and **a new scope
     * is created when the element is restored**.  The scope created within `ngIf` inherits from
     * its parent scope using
     * {@link https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance prototypal inheritance}.
     * An important implication of this is if `ngModel` is used within `ngIf` to bind to
     * a javascript primitive defined in the parent scope. In this case any modifications made to the
     * variable within the child scope will override (hide) the value in the parent scope.
     *
     * Also, `ngIf` recreates elements using their compiled state. An example scenario of this behavior
     * is if an element's class attribute is directly modified after it's compiled, using something like
     * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
     * the added class will be lost because the original compiled state is used to regenerate the element.
     *
     * Additionally, you can provide animations via the ngAnimate attribute to animate the **enter**
     * and **leave** effects.
     *
     * @animations
     * enter - happens just after the ngIf contents change and a new DOM element is created and injected into the ngIf container
     * leave - happens just before the ngIf contents are removed from the DOM
     *
     * @element ANY
     * @scope
     * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
     *     the element is removed from the DOM tree (HTML).
     *
     * @example
     <example animations="true">
     <file name="index.html">
     Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /><br/>
     Show when checked:
     <span ng-if="checked" ng-animate="'example'">
     I'm removed when the checkbox is unchecked.
     </span>
     </file>
     <file name="animations.css">
     .example-leave, .example-enter {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      }

     .example-enter {
        opacity:0;
      }
     .example-enter.example-enter-active {
        opacity:1;
      }

     .example-leave {
        opacity:1;
      }
     .example-leave.example-leave-active {
        opacity:0;
      }
     </file>
     </example>
     */
    var ngIfDirective = ['$animator', function($animator) {
        return {
            transclude: 'element',
            priority: 1000,
            terminal: true,
            restrict: 'A',
            compile: function (element, attr, transclude) {
                return function ($scope, $element, $attr) {
                    var animate = $animator($scope, $attr);
                    var childElement, childScope;
                    $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                        if (childElement) {
                            animate.leave(childElement);
                            childElement = undefined;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = undefined;
                        }
                        if (toBoolean(value)) {
                            childScope = $scope.$new();
                            transclude(childScope, function (clone) {
                                childElement = clone;
                                animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    });
                }
            }
        }
    }];

    /**
     * @ngdoc directive
     * @name ng.directive:ngInclude
     * @restrict ECA
     *
     * @description
     * Fetches, compiles and includes an external HTML fragment.
     *
     * Keep in mind that Same Origin Policy applies to included resources
     * (e.g. ngInclude won't work for cross-domain requests on all browsers and for
     *  file:// access on some browsers).
     *
     * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**
     * and **leave** effects.
     *
     * @animations
     * enter - happens just after the ngInclude contents change and a new DOM element is created and injected into the ngInclude container
     * leave - happens just after the ngInclude contents change and just before the former contents are removed from the DOM
     *
     * @scope
     *
     * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
     *                 make sure you wrap it in quotes, e.g. `src="'myPartialTemplate.html'"`.
     * @param {string=} onload Expression to evaluate when a new partial is loaded.
     *
     * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll
     *                  $anchorScroll} to scroll the viewport after the content is loaded.
     *
     *                  - If the attribute is not set, disable scrolling.
     *                  - If the attribute is set without value, enable scrolling.
     *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
     *
     * @example
     <example animations="true">
     <file name="index.html">
     <div ng-controller="Ctrl">
     <select ng-model="template" ng-options="t.name for t in templates">
     <option value="">(blank)</option>
     </select>
     url of the template: <tt>{{template.url}}</tt>
     <hr/>
     <div class="example-animate-container"
     ng-include="template.url"
     ng-animate="{enter: 'example-enter', leave: 'example-leave'}"></div>
     </div>
     </file>
     <file name="script.js">
     function Ctrl($scope) {
        $scope.templates =
          [ { name: 'template1.html', url: 'template1.html'}
          , { name: 'template2.html', url: 'template2.html'} ];
        $scope.template = $scope.templates[0];
      }
     </file>
     <file name="template1.html">
     <div>Content of template1.html</div>
     </file>
     <file name="template2.html">
     <div>Content of template2.html</div>
     </file>
     <file name="animations.css">
     .example-leave,
     .example-enter {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
      }

     .example-animate-container > * {
        display:block;
        padding:10px;
      }

     .example-enter {
        top:-50px;
      }
     .example-enter.example-enter-active {
        top:0;
      }

     .example-leave {
        top:0;
      }
     .example-leave.example-leave-active {
        top:50px;
      }
     </file>
     <file name="scenario.js">
     it('should load template1.html', function() {
       expect(element('.doc-example-live [ng-include]').text()).
         toMatch(/Content of template1.html/);
      });
     it('should load template2.html', function() {
       select('template').option('1');
       expect(element('.doc-example-live [ng-include]').text()).
         toMatch(/Content of template2.html/);
      });
     it('should change to blank', function() {
       select('template').option('');
       expect(element('.doc-example-live [ng-include]').text()).toEqual('');
      });
     </file>
     </example>
     */


    /**
     * @ngdoc event
     * @name ng.directive:ngInclude#$includeContentRequested
     * @eventOf ng.directive:ngInclude
     * @eventType emit on the scope ngInclude was declared in
     * @description
     * Emitted every time the ngInclude content is requested.
     */


    /**
     * @ngdoc event
     * @name ng.directive:ngInclude#$includeContentLoaded
     * @eventOf ng.directive:ngInclude
     * @eventType emit on the current ngInclude scope
     * @description
     * Emitted every time the ngInclude content is reloaded.
     */
    var ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$compile', '$animator',
        function($http,   $templateCache,   $anchorScroll,   $compile,   $animator) {
            return {
                restrict: 'ECA',
                terminal: true,
                compile: function(element, attr) {
                    var srcExp = attr.ngInclude || attr.src,
                        onloadExp = attr.onload || '',
                        autoScrollExp = attr.autoscroll;

                    return function(scope, element, attr) {
                        var animate = $animator(scope, attr);
                        var changeCounter = 0,
                            childScope;

                        var clearContent = function() {
                            if (childScope) {
                                childScope.$destroy();
                                childScope = null;
                            }
                            animate.leave(element.contents(), element);
                        };

                        scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                            var thisChangeId = ++changeCounter;

                            if (src) {
                                $http.get(src, {cache: $templateCache}).success(function(response) {
                                    if (thisChangeId !== changeCounter) return;

                                    if (childScope) childScope.$destroy();
                                    childScope = scope.$new();
                                    animate.leave(element.contents(), element);

                                    var contents = jqLite('<div/>').html(response).contents();

                                    animate.enter(contents, element);
                                    $compile(contents)(childScope);

                                    if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                        $anchorScroll();
                                    }

                                    childScope.$emit('$includeContentLoaded');
                                    scope.$eval(onloadExp);
                                }).error(function() {
                                        if (thisChangeId === changeCounter) clearContent();
                                    });
                                scope.$emit('$includeContentRequested');
                            } else {
                                clearContent();
                            }
                        });
                    };
                }
            };
        }];

    /**
     * @ngdoc directive
     * @name ng.directive:ngInit
     *
     * @description
     * The `ngInit` directive specifies initialization tasks to be executed
     *  before the template enters execution mode during bootstrap.
     *
     * @element ANY
     * @param {expression} ngInit {@link guide/expression Expression} to eval.
     *
     * @example
     <doc:example>
     <doc:source>
     <div ng-init="greeting='Hello'; person='World'">
     {{greeting}} {{person}}!
     </div>
     </doc:source>
     <doc:scenario>
     it('should check greeting', function() {
         expect(binding('greeting')).toBe('Hello');
         expect(binding('person')).toBe('World');
       });
     </doc:scenario>
     </doc:example>
     */
    var ngInitDirective = ngDirective({
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            }
        }
    });

    /**
     * @ngdoc directive
     * @name ng.directive:ngNonBindable
     * @priority 1000
     *
     * @description
     * Sometimes it is necessary to write code which looks like bindings but which should be left alone
     * by angular. Use `ngNonBindable` to make angular ignore a chunk of HTML.
     *
     * @element ANY
     *
     * @example
     * In this example there are two location where a simple binding (`{{}}`) is present, but the one
     * wrapped in `ngNonBindable` is left alone.
     *
     * @example
     <doc:example>
     <doc:source>
     <div>Normal: {{1 + 2}}</div>
     <div ng-non-bindable>Ignored: {{1 + 2}}</div>
     </doc:source>
     <doc:scenario>
     it('should check ng-non-bindable', function() {
         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');
         expect(using('.doc-example-live').element('div:last').text()).
           toMatch(/1 \+ 2/);
       });
     </doc:scenario>
     </doc:example>
     */
    var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });

    /**
     * @ngdoc directive
     * @name ng.directive:ngPluralize
     * @restrict EA
     *
     * @description
     * # Overview
     * `ngPluralize` is a directive that displays messages according to en-US localization rules.
     * These rules are bundled with angular.js and the rules can be overridden
     * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive
     * by specifying the mappings between
     * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
     * plural categories} and the strings to be displayed.
     *
     * # Plural categories and explicit number rules
     * There are two
     * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
     * plural categories} in Angular's default en-US locale: "one" and "other".
     *
     * While a plural category may match many numbers (for example, in en-US locale, "other" can match
     * any number that is not 1), an explicit number rule can only match one number. For example, the
     * explicit number rule for "3" matches the number 3. You will see the use of plural categories
     * and explicit number rules throughout later parts of this documentation.
     *
     * # Configuring ngPluralize
     * You configure ngPluralize by providing 2 attributes: `count` and `when`.
     * You can also provide an optional attribute, `offset`.
     *
     * The value of the `count` attribute can be either a string or an {@link guide/expression
     * Angular expression}; these are evaluated on the current scope for its bound value.
     *
     * The `when` attribute specifies the mappings between plural categories and the actual
     * string to be displayed. The value of the attribute should be a JSON object so that Angular
     * can interpret it correctly.
     *
     * The following example shows how to configure ngPluralize:
     *
     * <pre>
     * <ng-pluralize count="personCount"
     when="{'0': 'Nobody is viewing.',
 *                      'one': '1 person is viewing.',
 *                      'other': '{} people are viewing.'}">
     * </ng-pluralize>
     *</pre>
     *
     * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
     * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
     * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
     * other numbers, for example 12, so that instead of showing "12 people are viewing", you can
     * show "a dozen people are viewing".
     *
     * You can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted
     * into pluralized strings. In the previous example, Angular will replace `{}` with
     * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
     * for <span ng-non-bindable>{{numberExpression}}</span>.
     *
     * # Configuring ngPluralize with offset
     * The `offset` attribute allows further customization of pluralized text, which can result in
     * a better user experience. For example, instead of the message "4 people are viewing this document",
     * you might display "John, Kate and 2 others are viewing this document".
     * The offset attribute allows you to offset a number by any desired value.
     * Let's take a look at an example:
     *
     * <pre>
     * <ng-pluralize count="personCount" offset=2
     *               when="{'0': 'Nobody is viewing.',
 *                      '1': '{{person1}} is viewing.',
 *                      '2': '{{person1}} and {{person2}} are viewing.',
 *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',
 *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
     * </ng-pluralize>
     * </pre>
     *
     * Notice that we are still using two plural categories(one, other), but we added
     * three explicit number rules 0, 1 and 2.
     * When one person, perhaps John, views the document, "John is viewing" will be shown.
     * When three people view the document, no explicit number rule is found, so
     * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
     * In this case, plural category 'one' is matched and "John, Marry and one other person are viewing"
     * is shown.
     *
     * Note that when you specify offsets, you must provide explicit number rules for
     * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
     * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
     * plural categories "one" and "other".
     *
     * @param {string|expression} count The variable to be bounded to.
     * @param {string} when The mapping between plural category to its corresponding strings.
     * @param {number=} offset Offset to deduct from the total number.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
            $scope.person1 = 'Igor';
            $scope.person2 = 'Misko';
            $scope.personCount = 1;
          }
     </script>
     <div ng-controller="Ctrl">
     Person 1:<input type="text" ng-model="person1" value="Igor" /><br/>
     Person 2:<input type="text" ng-model="person2" value="Misko" /><br/>
     Number of People:<input type="text" ng-model="personCount" value="1" /><br/>

     <!--- Example with simple pluralization rules for en locale --->
     Without Offset:
     <ng-pluralize count="personCount"
     when="{'0': 'Nobody is viewing.',
                               'one': '1 person is viewing.',
                               'other': '{} people are viewing.'}">
     </ng-pluralize><br>

     <!--- Example with offset --->
     With Offset(2):
     <ng-pluralize count="personCount" offset=2
     when="{'0': 'Nobody is viewing.',
                               '1': '{{person1}} is viewing.',
                               '2': '{{person1}} and {{person2}} are viewing.',
                               'one': '{{person1}}, {{person2}} and one other person are viewing.',
                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
     </ng-pluralize>
     </div>
     </doc:source>
     <doc:scenario>
     it('should show correct pluralized string', function() {
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                             toBe('1 person is viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                                                toBe('Igor is viewing.');

          using('.doc-example-live').input('personCount').enter('0');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                               toBe('Nobody is viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                                              toBe('Nobody is viewing.');

          using('.doc-example-live').input('personCount').enter('2');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('2 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor and Misko are viewing.');

          using('.doc-example-live').input('personCount').enter('3');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('3 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor, Misko and one other person are viewing.');

          using('.doc-example-live').input('personCount').enter('4');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('4 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor, Misko and 2 other people are viewing.');
        });

     it('should show data-binded names', function() {
          using('.doc-example-live').input('personCount').enter('4');
          expect(element('.doc-example-live ng-pluralize:last').text()).
              toBe('Igor, Misko and 2 other people are viewing.');

          using('.doc-example-live').input('person1').enter('Di');
          using('.doc-example-live').input('person2').enter('Vojta');
          expect(element('.doc-example-live ng-pluralize:last').text()).
              toBe('Di, Vojta and 2 other people are viewing.');
        });
     </doc:scenario>
     </doc:example>
     */
    var ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
            restrict: 'EA',
            link: function(scope, element, attr) {
                var numberExp = attr.count,
                    whenExp = element.attr(attr.$attr.when), // this is because we have {{}} in attrs
                    offset = attr.offset || 0,
                    whens = scope.$eval(whenExp),
                    whensExpFns = {},
                    startSymbol = $interpolate.startSymbol(),
                    endSymbol = $interpolate.endSymbol();

                forEach(whens, function(expression, key) {
                    whensExpFns[key] =
                        $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' +
                            offset + endSymbol));
                });

                scope.$watch(function ngPluralizeWatch() {
                    var value = parseFloat(scope.$eval(numberExp));

                    if (!isNaN(value)) {
                        //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,
                        //check it against pluralization rules in $locale service
                        if (!(value in whens)) value = $locale.pluralCat(value - offset);
                        return whensExpFns[value](scope, element, true);
                    } else {
                        return '';
                    }
                }, function ngPluralizeWatchAction(newVal) {
                    element.text(newVal);
                });
            }
        };
    }];

    /**
     * @ngdoc directive
     * @name ng.directive:ngRepeat
     *
     * @description
     * The `ngRepeat` directive instantiates a template once per item from a collection. Each template
     * instance gets its own scope, where the given loop variable is set to the current collection item,
     * and `$index` is set to the item index or key.
     *
     * Special properties are exposed on the local scope of each template instance, including:
     *
     *   * `$index` â€“ `{number}` â€“ iterator offset of the repeated element (0..length-1)
     *   * `$first` â€“ `{boolean}` â€“ true if the repeated element is first in the iterator.
     *   * `$middle` â€“ `{boolean}` â€“ true if the repeated element is between the first and last in the iterator.
     *   * `$last` â€“ `{boolean}` â€“ true if the repeated element is last in the iterator.
     *
     * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**,
     * **leave** and **move** effects.
     *
     * @animations
     * enter - when a new item is added to the list or when an item is revealed after a filter
     * leave - when an item is removed from the list or when an item is filtered out
     * move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered
     *
     * @element ANY
     * @scope
     * @priority 1000
     * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These
     *   formats are currently supported:
     *
     *   * `variable in expression` â€“ where variable is the user defined loop variable and `expression`
     *     is a scope expression giving the collection to enumerate.
     *
     *     For example: `track in cd.tracks`.
     *
     *   * `(key, value) in expression` â€“ where `key` and `value` can be any user defined identifiers,
     *     and `expression` is the scope expression giving the collection to enumerate.
     *
     *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
     *
     *   * `variable in expression track by tracking_expression` â€“ You can also provide an optional tracking function
     *     which can be used to associate the objects in the collection with the DOM elements. If no tractking function
     *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have
     *     more then one tractking function to  resolve to the same key. (This would mean that two distinct objects are
     *     mapped to the same DOM element, which is not possible.)
     *
     *     For example: `item in items` is equivalent to `item in items track by $id(item)'. This implies that the DOM elements
     *     will be associated by item identity in the array.
     *
     *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique
     *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements
     *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM
     *     element in the same way ian the DOM.
     *
     *     For example: `item in items track by item.id` Is a typical pattern when the items come from the database. In this
     *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`
     *     property is same.
     *
     * @example
     * This example initializes the scope to a list of names and
     * then uses `ngRepeat` to display every person:
     <example animations="true">
     <file name="index.html">
     <div ng-init="friends = [
     {name:'John', age:25, gender:'boy'},
     {name:'Jessie', age:30, gender:'girl'},
     {name:'Johanna', age:28, gender:'girl'},
     {name:'Joy', age:15, gender:'girl'},
     {name:'Mary', age:28, gender:'girl'},
     {name:'Peter', age:95, gender:'boy'},
     {name:'Sebastian', age:50, gender:'boy'},
     {name:'Erika', age:27, gender:'girl'},
     {name:'Patrick', age:40, gender:'boy'},
     {name:'Samantha', age:60, gender:'girl'}
     ]">
     I have {{friends.length}} friends. They are:
     <input type="search" ng-model="q" placeholder="filter friends..." />
     <ul>
     <li ng-repeat="friend in friends | filter:q"
     ng-animate="{enter: 'example-repeat-enter',
                          leave: 'example-repeat-leave',
                          move: 'example-repeat-move'}">
     [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
     </li>
     </ul>
     </div>
     </file>
     <file name="animations.css">
     .example-repeat-enter,
     .example-repeat-leave,
     .example-repeat-move {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -ms-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

     .example-repeat-enter {
        line-height:0;
        opacity:0;
      }
     .example-repeat-enter.example-repeat-enter-active {
        line-height:20px;
        opacity:1;
      }

     .example-repeat-leave {
        opacity:1;
        line-height:20px;
      }
     .example-repeat-leave.example-repeat-leave-active {
        opacity:0;
        line-height:0;
      }

     .example-repeat-move { }
     .example-repeat-move.example-repeat-move-active { }
     </file>
     <file name="scenario.js">
     it('should render initial data set', function() {
         var r = using('.doc-example-live').repeater('ul li');
         expect(r.count()).toBe(10);
         expect(r.row(0)).toEqual(["1","John","25"]);
         expect(r.row(1)).toEqual(["2","Jessie","30"]);
         expect(r.row(9)).toEqual(["10","Samantha","60"]);
         expect(binding('friends.length')).toBe("10");
       });

     it('should update repeater when filter predicate changes', function() {
         var r = using('.doc-example-live').repeater('ul li');
         expect(r.count()).toBe(10);

         input('q').enter('ma');

         expect(r.count()).toBe(2);
         expect(r.row(0)).toEqual(["1","Mary","28"]);
         expect(r.row(1)).toEqual(["2","Samantha","60"]);
       });
     </file>
     </example>
     */
    var ngRepeatDirective = ['$parse', '$animator', function($parse, $animator) {
        var NG_REMOVED = '$$NG_REMOVED';
        return {
            transclude: 'element',
            priority: 1000,
            terminal: true,
            compile: function(element, attr, linker) {
                return function($scope, $element, $attr){
                    var animate = $animator($scope, $attr);
                    var expression = $attr.ngRepeat;
                    var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),
                        trackByExp, trackByExpGetter, trackByIdFn, lhs, rhs, valueIdentifier, keyIdentifier,
                        hashFnLocals = {$id: hashKey};

                    if (!match) {
                        throw Error("Expected ngRepeat in form of '_item_ in _collection_[ track by _id_]' but got '" +
                            expression + "'.");
                    }

                    lhs = match[1];
                    rhs = match[2];
                    trackByExp = match[4];

                    if (trackByExp) {
                        trackByExpGetter = $parse(trackByExp);
                        trackByIdFn = function(key, value, index) {
                            // assign key, value, and $index to the locals so that they can be used in hash functions
                            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                            hashFnLocals[valueIdentifier] = value;
                            hashFnLocals.$index = index;
                            return trackByExpGetter($scope, hashFnLocals);
                        };
                    } else {
                        trackByIdFn = function(key, value) {
                            return hashKey(value);
                        }
                    }

                    match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
                    if (!match) {
                        throw Error("'item' in 'item in collection' should be identifier or (key, value) but got '" +
                            lhs + "'.");
                    }
                    valueIdentifier = match[3] || match[1];
                    keyIdentifier = match[2];

                    // Store a list of elements from previous run. This is a hash where key is the item from the
                    // iterator, and the value is objects with following properties.
                    //   - scope: bound scope
                    //   - element: previous element.
                    //   - index: position
                    var lastBlockMap = {};

                    //watch props
                    $scope.$watchCollection(rhs, function ngRepeatAction(collection){
                        var index, length,
                            cursor = $element,     // current position of the node
                            nextCursor,
                        // Same as lastBlockMap but it has the current state. It will become the
                        // lastBlockMap on the next iteration.
                            nextBlockMap = {},
                            arrayLength,
                            childScope,
                            key, value, // key/value of iteration
                            trackById,
                            collectionKeys,
                            block,       // last object information {scope, element, id}
                            nextBlockOrder = [];


                        if (isArrayLike(collection)) {
                            collectionKeys = collection;
                        } else {
                            // if object, extract keys, sort them and use to determine order of iteration over obj props
                            collectionKeys = [];
                            for (key in collection) {
                                if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                                    collectionKeys.push(key);
                                }
                            }
                            collectionKeys.sort();
                        }

                        arrayLength = collectionKeys.length;

                        // locate existing items
                        length = nextBlockOrder.length = collectionKeys.length;
                        for(index = 0; index < length; index++) {
                            key = (collection === collectionKeys) ? index : collectionKeys[index];
                            value = collection[key];
                            trackById = trackByIdFn(key, value, index);
                            if(lastBlockMap.hasOwnProperty(trackById)) {
                                block = lastBlockMap[trackById]
                                delete lastBlockMap[trackById];
                                nextBlockMap[trackById] = block;
                                nextBlockOrder[index] = block;
                            } else if (nextBlockMap.hasOwnProperty(trackById)) {
                                // restore lastBlockMap
                                forEach(nextBlockOrder, function(block) {
                                    if (block && block.element) lastBlockMap[block.id] = block;
                                });
                                // This is a duplicate and we need to throw an error
                                throw new Error('Duplicates in a repeater are not allowed. Repeater: ' + expression +
                                    ' key: ' + trackById);
                            } else {
                                // new never before seen block
                                nextBlockOrder[index] = { id: trackById };
                                nextBlockMap[trackById] = false;
                            }
                        }

                        // remove existing items
                        for (key in lastBlockMap) {
                            if (lastBlockMap.hasOwnProperty(key)) {
                                block = lastBlockMap[key];
                                animate.leave(block.element);
                                block.element[0][NG_REMOVED] = true;
                                block.scope.$destroy();
                            }
                        }

                        // we are not using forEach for perf reasons (trying to avoid #call)
                        for (index = 0, length = collectionKeys.length; index < length; index++) {
                            key = (collection === collectionKeys) ? index : collectionKeys[index];
                            value = collection[key];
                            block = nextBlockOrder[index];

                            if (block.element) {
                                // if we have already seen this object, then we need to reuse the
                                // associated scope/element
                                childScope = block.scope;

                                nextCursor = cursor[0];
                                do {
                                    nextCursor = nextCursor.nextSibling;
                                } while(nextCursor && nextCursor[NG_REMOVED]);

                                if (block.element[0] == nextCursor) {
                                    // do nothing
                                    cursor = block.element;
                                } else {
                                    // existing item which got moved
                                    animate.move(block.element, null, cursor);
                                    cursor = block.element;
                                }
                            } else {
                                // new item which we don't know about
                                childScope = $scope.$new();
                            }

                            childScope[valueIdentifier] = value;
                            if (keyIdentifier) childScope[keyIdentifier] = key;
                            childScope.$index = index;
                            childScope.$first = (index === 0);
                            childScope.$last = (index === (arrayLength - 1));
                            childScope.$middle = !(childScope.$first || childScope.$last);

                            if (!block.element) {
                                linker(childScope, function(clone) {
                                    animate.enter(clone, null, cursor);
                                    cursor = clone;
                                    block.scope = childScope;
                                    block.element = clone;
                                    nextBlockMap[block.id] = block;
                                });
                            }
                        }
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    }];

    /**
     * @ngdoc directive
     * @name ng.directive:ngShow
     *
     * @description
     * The `ngShow` and `ngHide` directives show or hide a portion of the DOM tree (HTML)
     * conditionally based on **"truthy"** values evaluated within an {expression}. In other
     * words, if the expression assigned to **ngShow evaluates to a true value** then **the element is set to visible**
     * (via `display:block` in css) and **if false** then **the element is set to hidden** (so display:none).
     * With ngHide this is the reverse whereas true values cause the element itself to become
     * hidden.
     *
     * Additionally, you can also provide animations via the ngAnimate attribute to animate the **show**
     * and **hide** effects.
     *
     * @animations
     * show - happens after the ngShow expression evaluates to a truthy value and the contents are set to visible
     * hide - happens before the ngShow expression evaluates to a non truthy value and just before the contents are set to hidden
     *
     * @element ANY
     * @param {expression} ngShow If the {@link guide/expression expression} is truthy
     *     then the element is shown or hidden respectively.
     *
     * @example
     <example animations="true">
     <file name="index.html">
     Click me: <input type="checkbox" ng-model="checked"><br/>
     <div>
     Show:
     <span class="check-element"
     ng-show="checked"
     ng-animate="{show: 'example-show', hide: 'example-hide'}">
     <span class="icon-thumbs-up"></span> I show up when your checkbox is checked.
     </span>
     </div>
     <div>
     Hide:
     <span class="check-element"
     ng-hide="checked"
     ng-animate="{show: 'example-show', hide: 'example-hide'}">
     <span class="icon-thumbs-down"></span> I hide when your checkbox is checked.
     </span>
     </div>
     </file>
     <file name="animations.css">
     .example-show, .example-hide {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -ms-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

     .example-show {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }
     .example-show-active.example-show-active {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

     .example-hide {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }
     .example-hide-active.example-hide-active {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

     .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
     </file>
     <file name="scenario.js">
     it('should check ng-show / ng-hide', function() {
         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);
         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);

         input('checked').check();

         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);
         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);
       });
     </file>
     </example>
     */
//TODO(misko): refactor to remove element from the DOM
    var ngShowDirective = ['$animator', function($animator) {
        return function(scope, element, attr) {
            var animate = $animator(scope, attr);
            scope.$watch(attr.ngShow, function ngShowWatchAction(value){
                animate[toBoolean(value) ? 'show' : 'hide'](element);
            });
        };
    }];


    /**
     * @ngdoc directive
     * @name ng.directive:ngHide
     *
     * @description
     * The `ngShow` and `ngHide` directives show or hide a portion of the DOM tree (HTML)
     * conditionally based on **"truthy"** values evaluated within an {expression}. In other
     * words, if the expression assigned to **ngShow evaluates to a true value** then **the element is set to visible**
     * (via `display:block` in css) and **if false** then **the element is set to hidden** (so display:none).
     * With ngHide this is the reverse whereas true values cause the element itself to become
     * hidden.
     *
     * Additionally, you can also provide animations via the ngAnimate attribute to animate the **show**
     * and **hide** effects.
     *
     * @animations
     * show - happens after the ngHide expression evaluates to a non truthy value and the contents are set to visible
     * hide - happens after the ngHide expression evaluates to a truthy value and just before the contents are set to hidden
     *
     * @element ANY
     * @param {expression} ngHide If the {@link guide/expression expression} is truthy then
     *     the element is shown or hidden respectively.
     *
     * @example
     <example animations="true">
     <file name="index.html">
     Click me: <input type="checkbox" ng-model="checked"><br/>
     <div>
     Show:
     <span class="check-element"
     ng-show="checked"
     ng-animate="{show: 'example-show', hide: 'example-hide'}">
     <span class="icon-thumbs-up"></span> I show up when your checkbox is checked.
     </span>
     </div>
     <div>
     Hide:
     <span class="check-element"
     ng-hide="checked"
     ng-animate="{show: 'example-show', hide: 'example-hide'}">
     <span class="icon-thumbs-down"></span> I hide when your checkbox is checked.
     </span>
     </div>
     </file>
     <file name="animations.css">
     .example-show, .example-hide {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -ms-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

     .example-show {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }
     .example-show.example-show-active {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

     .example-hide {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }
     .example-hide.example-hide-active {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

     .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
     </file>
     <file name="scenario.js">
     it('should check ng-show / ng-hide', function() {
         expect(element('.doc-example-live .check-element:first:hidden').count()).toEqual(1);
         expect(element('.doc-example-live .check-element:last:visible').count()).toEqual(1);

         input('checked').check();

         expect(element('.doc-example-live .check-element:first:visible').count()).toEqual(1);
         expect(element('.doc-example-live .check-element:last:hidden').count()).toEqual(1);
       });
     </file>
     </example>
     */
//TODO(misko): refactor to remove element from the DOM
    var ngHideDirective = ['$animator', function($animator) {
        return function(scope, element, attr) {
            var animate = $animator(scope, attr);
            scope.$watch(attr.ngHide, function ngHideWatchAction(value){
                animate[toBoolean(value) ? 'hide' : 'show'](element);
            });
        };
    }];

    /**
     * @ngdoc directive
     * @name ng.directive:ngStyle
     *
     * @description
     * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.
     *
     * @element ANY
     * @param {expression} ngStyle {@link guide/expression Expression} which evals to an
     *      object whose keys are CSS style names and values are corresponding values for those CSS
     *      keys.
     *
     * @example
     <example>
     <file name="index.html">
     <input type="button" value="set" ng-click="myStyle={color:'red'}">
     <input type="button" value="clear" ng-click="myStyle={}">
     <br/>
     <span ng-style="myStyle">Sample Text</span>
     <pre>myStyle={{myStyle}}</pre>
     </file>
     <file name="style.css">
     span {
         color: black;
       }
     </file>
     <file name="scenario.js">
     it('should check ng-style', function() {
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
         element('.doc-example-live :button[value=set]').click();
         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');
         element('.doc-example-live :button[value=clear]').click();
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
       });
     </file>
     </example>
     */
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && (newStyles !== oldStyles)) {
                forEach(oldStyles, function(val, style) { element.css(style, '');});
            }
            if (newStyles) element.css(newStyles);
        }, true);
    });

    /**
     * @ngdoc directive
     * @name ng.directive:ngSwitch
     * @restrict EA
     *
     * @description
     * The ngSwitch directive is used to conditionally swap DOM structure on your template based on a scope expression.
     * Elements within ngSwitch but without ngSwitchWhen or ngSwitchDefault directives will be preserved at the location
     * as specified in the template.
     *
     * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
     * from the template cache), ngSwitch simply choses one of the nested elements and makes it visible based on which element
     * matches the value obtained from the evaluated expression. In other words, you define a container element
     * (where you place the directive), place an expression on the **on="..." attribute**
     * (or the **ng-switch="..." attribute**), define any inner elements inside of the directive and place
     * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
     * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
     * attribute is displayed.
     *
     * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**
     * and **leave** effects.
     *
     * @animations
     * enter - happens after the ngSwtich contents change and the matched child element is placed inside the container
     * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM
     *
     * @usage
     * <ANY ng-switch="expression">
     *   <ANY ng-switch-when="matchValue1">...</ANY>
     *   <ANY ng-switch-when="matchValue2">...</ANY>
     *   <ANY ng-switch-default>...</ANY>
     * </ANY>
     *
     * @scope
     * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.
     * @paramDescription
     * On child elements add:
     *
     * * `ngSwitchWhen`: the case statement to match against. If match then this
     *   case will be displayed. If the same match appears multiple times, all the
     *   elements will be displayed.
     * * `ngSwitchDefault`: the default case when no other case match. If there
     *   are multiple default cases, all of them will be displayed when no other
     *   case match.
     *
     *
     * @example
     <example animations="true">
     <file name="index.html">
     <div ng-controller="Ctrl">
     <select ng-model="selection" ng-options="item for item in items">
     </select>
     <tt>selection={{selection}}</tt>
     <hr/>
     <div
     class="example-animate-container"
     ng-switch on="selection"
     ng-animate="{enter: 'example-enter', leave: 'example-leave'}">
     <div ng-switch-when="settings">Settings Div</div>
     <div ng-switch-when="home">Home Span</div>
     <div ng-switch-default>default</div>
     </div>
     </div>
     </file>
     <file name="script.js">
     function Ctrl($scope) {
        $scope.items = ['settings', 'home', 'other'];
        $scope.selection = $scope.items[0];
      }
     </file>
     <file name="animations.css">
     .example-leave, .example-enter {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
      }

     .example-animate-container > * {
        display:block;
        padding:10px;
      }

     .example-enter {
        top:-50px;
      }
     .example-enter.example-enter-active {
        top:0;
      }

     .example-leave {
        top:0;
      }
     .example-leave.example-leave-active {
        top:50px;
      }
     </file>
     <file name="scenario.js">
     it('should start in settings', function() {
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);
      });
     it('should change to home', function() {
        select('selection').option('home');
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);
      });
     it('should select default', function() {
        select('selection').option('other');
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);
      });
     </file>
     </example>
     */
    var ngSwitchDirective = ['$animator', function($animator) {
        return {
            restrict: 'EA',
            require: 'ngSwitch',

            // asks for $scope to fool the BC controller module
            controller: ['$scope', function ngSwitchController() {
                this.cases = {};
            }],
            link: function(scope, element, attr, ngSwitchController) {
                var animate = $animator(scope, attr);
                var watchExpr = attr.ngSwitch || attr.on,
                    selectedTranscludes,
                    selectedElements,
                    selectedScopes = [];

                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    for (var i= 0, ii=selectedScopes.length; i<ii; i++) {
                        selectedScopes[i].$destroy();
                        animate.leave(selectedElements[i]);
                    }

                    selectedElements = [];
                    selectedScopes = [];

                    if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                        scope.$eval(attr.change);
                        forEach(selectedTranscludes, function(selectedTransclude) {
                            var selectedScope = scope.$new();
                            selectedScopes.push(selectedScope);
                            selectedTransclude.transclude(selectedScope, function(caseElement) {
                                var anchor = selectedTransclude.element;

                                selectedElements.push(caseElement);
                                animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        }
    }];

    var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 500,
        require: '^ngSwitch',
        compile: function(element, attrs, transclude) {
            return function(scope, element, attr, ctrl) {
                ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
                ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: transclude, element: element });
            };
        }
    });

    var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 500,
        require: '^ngSwitch',
        compile: function(element, attrs, transclude) {
            return function(scope, element, attr, ctrl) {
                ctrl.cases['?'] = (ctrl.cases['?'] || []);
                ctrl.cases['?'].push({ transclude: transclude, element: element });
            };
        }
    });

    /**
     * @ngdoc directive
     * @name ng.directive:ngTransclude
     *
     * @description
     * Insert the transcluded DOM here.
     *
     * @element ANY
     *
     * @example
     <doc:example module="transclude">
     <doc:source>
     <script>
     function Ctrl($scope) {
           $scope.title = 'Lorem Ipsum';
           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';
         }

     angular.module('transclude', [])
     .directive('pane', function(){
             return {
               restrict: 'E',
               transclude: true,
               scope: 'isolate',
               locals: { title:'bind' },
               template: '<div style="border: 1px solid black;">' +
                           '<div style="background-color: gray">{{title}}</div>' +
                           '<div ng-transclude></div>' +
                         '</div>'
             };
         });
     </script>
     <div ng-controller="Ctrl">
     <input ng-model="title"><br>
     <textarea ng-model="text"></textarea> <br/>
     <pane title="{{title}}">{{text}}</pane>
     </div>
     </doc:source>
     <doc:scenario>
     it('should have transcluded', function() {
          input('title').enter('TITLE');
          input('text').enter('TEXT');
          expect(binding('title')).toEqual('TITLE');
          expect(binding('text')).toEqual('TEXT');
        });
     </doc:scenario>
     </doc:example>
     *
     */
    var ngTranscludeDirective = ngDirective({
        controller: ['$transclude', '$element', function($transclude, $element) {
            $transclude(function(clone) {
                $element.append(clone);
            });
        }]
    });

    /**
     * @ngdoc directive
     * @name ng.directive:ngView
     * @restrict ECA
     *
     * @description
     * # Overview
     * `ngView` is a directive that complements the {@link ng.$route $route} service by
     * including the rendered template of the current route into the main layout (`index.html`) file.
     * Every time the current route changes, the included view changes with it according to the
     * configuration of the `$route` service.
     *
     * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**
     * and **leave** effects.
     *
     * @animations
     * enter - happens just after the ngView contents are changed (when the new view DOM element is inserted into the DOM)
     * leave - happens just after the current ngView contents change and just before the former contents are removed from the DOM
     *
     * @scope
     * @example
     <example module="ngView" animations="true">
     <file name="index.html">
     <div ng-controller="MainCntl as main">
     Choose:
     <a href="Book/Moby">Moby</a> |
     <a href="Book/Moby/ch/1">Moby: Ch1</a> |
     <a href="Book/Gatsby">Gatsby</a> |
     <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
     <a href="Book/Scarlet">Scarlet Letter</a><br/>

     <div
     ng-view
     class="example-animate-container"
     ng-animate="{enter: 'example-enter', leave: 'example-leave'}"></div>
     <hr />

     <pre>$location.path() = {{main.$location.path()}}</pre>
     <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>
     <pre>$route.current.params = {{main.$route.current.params}}</pre>
     <pre>$route.current.scope.name = {{main.$route.current.scope.name}}</pre>
     <pre>$routeParams = {{main.$routeParams}}</pre>
     </div>
     </file>

     <file name="book.html">
     <div>
     controller: {{book.name}}<br />
     Book Id: {{book.params.bookId}}<br />
     </div>
     </file>

     <file name="chapter.html">
     <div>
     controller: {{chapter.name}}<br />
     Book Id: {{chapter.params.bookId}}<br />
     Chapter Id: {{chapter.params.chapterId}}
     </div>
     </file>

     <file name="animations.css">
     .example-leave, .example-enter {
          -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
        }

     .example-animate-container {
          position:relative;
          height:100px;
        }

     .example-animate-container > * {
          display:block;
          width:100%;
          border-left:1px solid black;

          position:absolute;
          top:0;
          left:0;
          right:0;
          bottom:0;
          padding:10px;
        }

     .example-enter {
          left:100%;
        }
     .example-enter.example-enter-active {
          left:0;
        }

     .example-leave { }
     .example-leave.example-leave-active {
          left:-100%;
        }
     </file>

     <file name="script.js">
     angular.module('ngView', [], function($routeProvider, $locationProvider) {
          $routeProvider.when('/Book/:bookId', {
            templateUrl: 'book.html',
            controller: BookCntl,
            controllerAs: 'book'
          });
          $routeProvider.when('/Book/:bookId/ch/:chapterId', {
            templateUrl: 'chapter.html',
            controller: ChapterCntl,
            controllerAs: 'chapter'
          });

          // configure html5 to get links working on jsfiddle
          $locationProvider.html5Mode(true);
        });

     function MainCntl($route, $routeParams, $location) {
          this.$route = $route;
          this.$location = $location;
          this.$routeParams = $routeParams;
        }

     function BookCntl($routeParams) {
          this.name = "BookCntl";
          this.params = $routeParams;
        }

     function ChapterCntl($routeParams) {
          this.name = "ChapterCntl";
          this.params = $routeParams;
        }
     </file>

     <file name="scenario.js">
     it('should load and compile correct template', function() {
          element('a:contains("Moby: Ch1")').click();
          var content = element('.doc-example-live [ng-view]').text();
          expect(content).toMatch(/controller\: ChapterCntl/);
          expect(content).toMatch(/Book Id\: Moby/);
          expect(content).toMatch(/Chapter Id\: 1/);

          element('a:contains("Scarlet")').click();
          content = element('.doc-example-live [ng-view]').text();
          expect(content).toMatch(/controller\: BookCntl/);
          expect(content).toMatch(/Book Id\: Scarlet/);
        });
     </file>
     </example>
     */


    /**
     * @ngdoc event
     * @name ng.directive:ngView#$viewContentLoaded
     * @eventOf ng.directive:ngView
     * @eventType emit on the current ngView scope
     * @description
     * Emitted every time the ngView content is reloaded.
     */
    var ngViewDirective = ['$http', '$templateCache', '$route', '$anchorScroll', '$compile',
        '$controller', '$animator',
        function($http,   $templateCache,   $route,   $anchorScroll,   $compile,
                 $controller,  $animator) {
            return {
                restrict: 'ECA',
                terminal: true,
                link: function(scope, element, attr) {
                    var lastScope,
                        onloadExp = attr.onload || '',
                        animate = $animator(scope, attr);

                    scope.$on('$routeChangeSuccess', update);
                    update();


                    function destroyLastScope() {
                        if (lastScope) {
                            lastScope.$destroy();
                            lastScope = null;
                        }
                    }

                    function clearContent() {
                        animate.leave(element.contents(), element);
                        destroyLastScope();
                    }

                    function update() {
                        var locals = $route.current && $route.current.locals,
                            template = locals && locals.$template;

                        if (template) {
                            clearContent();
                            var enterElements = jqLite('<div></div>').html(template).contents();
                            animate.enter(enterElements, element);

                            var link = $compile(enterElements),
                                current = $route.current,
                                controller;

                            lastScope = current.scope = scope.$new();
                            if (current.controller) {
                                locals.$scope = lastScope;
                                controller = $controller(current.controller, locals);
                                if (current.controllerAs) {
                                    lastScope[current.controllerAs] = controller;
                                }
                                element.children().data('$ngControllerController', controller);
                            }

                            link(lastScope);
                            lastScope.$emit('$viewContentLoaded');
                            lastScope.$eval(onloadExp);

                            // $anchorScroll might listen on event...
                            $anchorScroll();
                        } else {
                            clearContent();
                        }
                    }
                }
            };
        }];

    /**
     * @ngdoc directive
     * @name ng.directive:script
     *
     * @description
     * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the
     * template can be used by `ngInclude`, `ngView` or directive templates.
     *
     * @restrict E
     * @param {'text/ng-template'} type must be set to `'text/ng-template'`
     *
     * @example
     <doc:example>
     <doc:source>
     <script type="text/ng-template" id="/tpl.html">
     Content of the template.
     </script>

     <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
     <div id="tpl-content" ng-include src="currentTpl"></div>
     </doc:source>
     <doc:scenario>
     it('should load template defined inside script tag', function() {
        element('#tpl-link').click();
        expect(element('#tpl-content').text()).toMatch(/Content of the template/);
      });
     </doc:scenario>
     </doc:example>
     */
    var scriptDirective = ['$templateCache', function($templateCache) {
        return {
            restrict: 'E',
            terminal: true,
            compile: function(element, attr) {
                if (attr.type == 'text/ng-template') {
                    var templateUrl = attr.id,
                    // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent
                        text = element[0].text;

                    $templateCache.put(templateUrl, text);
                }
            }
        };
    }];

    /**
     * @ngdoc directive
     * @name ng.directive:select
     * @restrict E
     *
     * @description
     * HTML `SELECT` element with angular data-binding.
     *
     * # `ngOptions`
     *
     * Optionally `ngOptions` attribute can be used to dynamically generate a list of `<option>`
     * elements for a `<select>` element using an array or an object obtained by evaluating the
     * `ngOptions` expression.
     *ËË
     * When an item in the select menu is select, the value of array element or object property
     * represented by the selected option will be bound to the model identified by the `ngModel`
     * directive of the parent select element.
     *
     * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
     * be nested into the `<select>` element. This element will then represent `null` or "not selected"
     * option. See example below for demonstration.
     *
     * Note: `ngOptions` provides iterator facility for `<option>` element which should be used instead
     * of {@link ng.directive:ngRepeat ngRepeat} when you want the
     * `select` model to be bound to a non-string value. This is because an option element can currently
     * be bound to string values only.
     *
     * @param {string} ngModel Assignable angular expression to data-bind to.
     * @param {string=} name Property name of the form under which the control is published.
     * @param {string=} required The control is considered valid only if value is entered.
     * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
     *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
     *    `required` when you want to data-bind to the `required` attribute.
     * @param {comprehension_expression=} ngOptions in one of the following forms:
     *
     *   * for array data sources:
     *     * `label` **`for`** `value` **`in`** `array`
     *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`
     *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`
     *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`
     *   * for object data sources:
     *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
     *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
     *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`
     *     * `select` **`as`** `label` **`group by`** `group`
     *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
     *
     * Where:
     *
     *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
     *   * `value`: local variable which will refer to each item in the `array` or each property value
     *      of `object` during iteration.
     *   * `key`: local variable which will refer to a property name in `object` during iteration.
     *   * `label`: The result of this expression will be the label for `<option>` element. The
     *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
     *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
     *      element. If not specified, `select` expression will default to `value`.
     *   * `group`: The result of this expression will be used to group options using the `<optgroup>`
     *      DOM element.
     *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be
     *      used to identify the objects in the array. The `trackexpr` will most likely refer to the
     *     `value` variable (e.g. `value.propertyName`).
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function MyCntrl($scope) {
          $scope.colors = [
            {name:'black', shade:'dark'},
            {name:'white', shade:'light'},
            {name:'red', shade:'dark'},
            {name:'blue', shade:'dark'},
            {name:'yellow', shade:'light'}
          ];
          $scope.color = $scope.colors[2]; // red
        }
     </script>
     <div ng-controller="MyCntrl">
     <ul>
     <li ng-repeat="color in colors">
     Name: <input ng-model="color.name">
     [<a href ng-click="colors.splice($index, 1)">X</a>]
     </li>
     <li>
     [<a href ng-click="colors.push({})">add</a>]
     </li>
     </ul>
     <hr/>
     Color (null not allowed):
     <select ng-model="color" ng-options="c.name for c in colors"></select><br>

     Color (null allowed):
     <span  class="nullable">
     <select ng-model="color" ng-options="c.name for c in colors">
     <option value="">-- chose color --</option>
     </select>
     </span><br/>

     Color grouped by shade:
     <select ng-model="color" ng-options="c.name group by c.shade for c in colors">
     </select><br/>


     Select <a href ng-click="color={name:'not in list'}">bogus</a>.<br>
     <hr/>
     Currently selected: {{ {selected_color:color}  }}
     <div style="border:solid 1px black; height:20px"
     ng-style="{'background-color':color.name}">
     </div>
     </div>
     </doc:source>
     <doc:scenario>
     it('should check ng-options', function() {
           expect(binding('{selected_color:color}')).toMatch('red');
           select('color').option('0');
           expect(binding('{selected_color:color}')).toMatch('black');
           using('.nullable').select('color').option('');
           expect(binding('{selected_color:color}')).toMatch('null');
         });
     </doc:scenario>
     </doc:example>
     */

    var ngOptionsDirective = valueFn({ terminal: true });
    var selectDirective = ['$compile', '$parse', function($compile,   $parse) {
        //0000111110000000000022220000000000000000000000333300000000000000444444444444444440000000005555555555555555500000006666666666666666600000000000000007777000000000000000000088888
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,
            nullModelCtrl = {$setViewValue: noop};

        return {
            restrict: 'E',
            require: ['select', '?ngModel'],
            controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
                var self = this,
                    optionsMap = {},
                    ngModelCtrl = nullModelCtrl,
                    nullOption,
                    unknownOption;


                self.databound = $attrs.ngModel;


                self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_;
                    nullOption = nullOption_;
                    unknownOption = unknownOption_;
                }


                self.addOption = function(value) {
                    optionsMap[value] = true;

                    if (ngModelCtrl.$viewValue == value) {
                        $element.val(value);
                        if (unknownOption.parent()) unknownOption.remove();
                    }
                };


                self.removeOption = function(value) {
                    if (this.hasOption(value)) {
                        delete optionsMap[value];
                        if (ngModelCtrl.$viewValue == value) {
                            this.renderUnknownOption(value);
                        }
                    }
                };


                self.renderUnknownOption = function(val) {
                    var unknownVal = '? ' + hashKey(val) + ' ?';
                    unknownOption.val(unknownVal);
                    $element.prepend(unknownOption);
                    $element.val(unknownVal);
                    unknownOption.prop('selected', true); // needed for IE
                }


                self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value);
                }

                $scope.$on('$destroy', function() {
                    // disable unknown option so that we don't do work when the whole select is being destroyed
                    self.renderUnknownOption = noop;
                });
            }],

            link: function(scope, element, attr, ctrls) {
                // if ngModel is not defined, we don't need to do anything
                if (!ctrls[1]) return;

                var selectCtrl = ctrls[0],
                    ngModelCtrl = ctrls[1],
                    multiple = attr.multiple,
                    optionsExp = attr.ngOptions,
                    nullOption = false, // if false, user will not be able to select it (used by ngOptions)
                    emptyOption,
                // we can't just jqLite('<option>') since jqLite is not smart enough
                // to create it in <select> and IE barfs otherwise.
                    optionTemplate = jqLite(document.createElement('option')),
                    optGroupTemplate =jqLite(document.createElement('optgroup')),
                    unknownOption = optionTemplate.clone();

                // find "null" option
                for(var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
                    if (children[i].value == '') {
                        emptyOption = nullOption = children.eq(i);
                        break;
                    }
                }

                selectCtrl.init(ngModelCtrl, nullOption, unknownOption);

                // required validator
                if (multiple && (attr.required || attr.ngRequired)) {
                    var requiredValidator = function(value) {
                        ngModelCtrl.$setValidity('required', !attr.required || (value && value.length));
                        return value;
                    };

                    ngModelCtrl.$parsers.push(requiredValidator);
                    ngModelCtrl.$formatters.unshift(requiredValidator);

                    attr.$observe('required', function() {
                        requiredValidator(ngModelCtrl.$viewValue);
                    });
                }

                if (optionsExp) Options(scope, element, ngModelCtrl);
                else if (multiple) Multiple(scope, element, ngModelCtrl);
                else Single(scope, element, ngModelCtrl, selectCtrl);


                ////////////////////////////



                function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function() {
                        var viewValue = ngModelCtrl.$viewValue;

                        if (selectCtrl.hasOption(viewValue)) {
                            if (unknownOption.parent()) unknownOption.remove();
                            selectElement.val(viewValue);
                            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy
                        } else {
                            if (isUndefined(viewValue) && emptyOption) {
                                selectElement.val('');
                            } else {
                                selectCtrl.renderUnknownOption(viewValue);
                            }
                        }
                    };

                    selectElement.bind('change', function() {
                        scope.$apply(function() {
                            if (unknownOption.parent()) unknownOption.remove();
                            ngModelCtrl.$setViewValue(selectElement.val());
                        });
                    });
                }

                function Multiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.find('option'), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };

                    // we have to do it on each watch since ngModel watches reference, but
                    // we need to work of an array, so we need to see if anything was inserted/removed
                    scope.$watch(function selectMultipleWatch() {
                        if (!equals(lastView, ctrl.$viewValue)) {
                            lastView = copy(ctrl.$viewValue);
                            ctrl.$render();
                        }
                    });

                    selectElement.bind('change', function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.find('option'), function(option) {
                                if (option.selected) {
                                    array.push(option.value);
                                }
                            });
                            ctrl.$setViewValue(array);
                        });
                    });
                }

                function Options(scope, selectElement, ctrl) {
                    var match;

                    if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                        throw Error(
                            "Expected ngOptions in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_ (track by _expr_)?'" +
                                " but got '" + optionsExp + "'.");
                    }

                    var displayFn = $parse(match[2] || match[1]),
                        valueName = match[4] || match[6],
                        keyName = match[5],
                        groupByFn = $parse(match[3] || ''),
                        valueFn = $parse(match[2] ? match[1] : valueName),
                        valuesFn = $parse(match[7]),
                        track = match[8],
                        trackFn = track ? $parse(match[8]) : null,
                    // This is an array of array of existing option groups in DOM. We try to reuse these if possible
                    // optionGroupsCache[0] is the options with no option group
                    // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
                        optionGroupsCache = [[{element: selectElement, label:''}]];

                    if (nullOption) {
                        // compile the element since there might be bindings in it
                        $compile(nullOption)(scope);

                        // remove the class, which is added automatically because we recompile the element and it
                        // becomes the compilation root
                        nullOption.removeClass('ng-scope');

                        // we need to remove it before calling selectElement.html('') because otherwise IE will
                        // remove the label from the element. wtf?
                        nullOption.remove();
                    }

                    // clear contents, we'll add what's needed based on the model
                    selectElement.html('');

                    selectElement.bind('change', function() {
                        scope.$apply(function() {
                            var optionGroup,
                                collection = valuesFn(scope) || [],
                                locals = {},
                                key, value, optionElement, index, groupIndex, length, groupLength;

                            if (multiple) {
                                value = [];
                                for (groupIndex = 0, groupLength = optionGroupsCache.length;
                                     groupIndex < groupLength;
                                     groupIndex++) {
                                    // list of options for that group. (first item has the parent)
                                    optionGroup = optionGroupsCache[groupIndex];

                                    for(index = 1, length = optionGroup.length; index < length; index++) {
                                        if ((optionElement = optionGroup[index].element)[0].selected) {
                                            key = optionElement.val();
                                            if (keyName) locals[keyName] = key;
                                            if (trackFn) {
                                                for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                                                    locals[valueName] = collection[trackIndex];
                                                    if (trackFn(scope, locals) == key) break;
                                                }
                                            } else {
                                                locals[valueName] = collection[key];
                                            }
                                            value.push(valueFn(scope, locals));
                                        }
                                    }
                                }
                            } else {
                                key = selectElement.val();
                                if (key == '?') {
                                    value = undefined;
                                } else if (key == ''){
                                    value = null;
                                } else {
                                    if (trackFn) {
                                        for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                                            locals[valueName] = collection[trackIndex];
                                            if (trackFn(scope, locals) == key) {
                                                value = valueFn(scope, locals);
                                                break;
                                            }
                                        }
                                    } else {
                                        locals[valueName] = collection[key];
                                        if (keyName) locals[keyName] = key;
                                        value = valueFn(scope, locals);
                                    }
                                }
                            }
                            ctrl.$setViewValue(value);
                        });
                    });

                    ctrl.$render = render;

                    // TODO(vojta): can't we optimize this ?
                    scope.$watch(render);

                    function render() {
                        var optionGroups = {'':[]}, // Temporary location for the option groups before we render them
                            optionGroupNames = [''],
                            optionGroupName,
                            optionGroup,
                            option,
                            existingParent, existingOptions, existingOption,
                            modelValue = ctrl.$modelValue,
                            values = valuesFn(scope) || [],
                            keys = keyName ? sortedKeys(values) : values,
                            groupLength, length,
                            groupIndex, index,
                            locals = {},
                            selected,
                            selectedSet = false, // nothing is selected yet
                            lastElement,
                            element,
                            label;

                        if (multiple) {
                            if (trackFn && isArray(modelValue)) {
                                selectedSet = new HashMap([]);
                                for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {
                                    locals[valueName] = modelValue[trackIndex];
                                    selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
                                }
                            } else {
                                selectedSet = new HashMap(modelValue);
                            }
                        }

                        // We now build up the list of options we need (we merge later)
                        for (index = 0; length = keys.length, index < length; index++) {
                            locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];
                            optionGroupName = groupByFn(scope, locals) || '';
                            if (!(optionGroup = optionGroups[optionGroupName])) {
                                optionGroup = optionGroups[optionGroupName] = [];
                                optionGroupNames.push(optionGroupName);
                            }
                            if (multiple) {
                                selected = selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)) != undefined;
                            } else {
                                if (trackFn) {
                                    var modelCast = {};
                                    modelCast[valueName] = modelValue;
                                    selected = trackFn(scope, modelCast) === trackFn(scope, locals);
                                } else {
                                    selected = modelValue === valueFn(scope, locals);
                                }
                                selectedSet = selectedSet || selected; // see if at least one item is selected
                            }
                            label = displayFn(scope, locals); // what will be seen by the user
                            label = label === undefined ? '' : label; // doing displayFn(scope, locals) || '' overwrites zero values
                            optionGroup.push({
                                id: trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index),   // either the index into array or key from object
                                label: label,
                                selected: selected                   // determine if we should be selected
                            });
                        }
                        if (!multiple) {
                            if (nullOption || modelValue === null) {
                                // insert null option if we have a placeholder, or the model is null
                                optionGroups[''].unshift({id:'', label:'', selected:!selectedSet});
                            } else if (!selectedSet) {
                                // option could not be found, we have to insert the undefined item
                                optionGroups[''].unshift({id:'?', label:'', selected:true});
                            }
                        }

                        // Now we need to update the list of DOM nodes to match the optionGroups we computed above
                        for (groupIndex = 0, groupLength = optionGroupNames.length;
                             groupIndex < groupLength;
                             groupIndex++) {
                            // current option group name or '' if no group
                            optionGroupName = optionGroupNames[groupIndex];

                            // list of options for that group. (first item has the parent)
                            optionGroup = optionGroups[optionGroupName];

                            if (optionGroupsCache.length <= groupIndex) {
                                // we need to grow the optionGroups
                                existingParent = {
                                    element: optGroupTemplate.clone().attr('label', optionGroupName),
                                    label: optionGroup.label
                                };
                                existingOptions = [existingParent];
                                optionGroupsCache.push(existingOptions);
                                selectElement.append(existingParent.element);
                            } else {
                                existingOptions = optionGroupsCache[groupIndex];
                                existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element

                                // update the OPTGROUP label if not the same.
                                if (existingParent.label != optionGroupName) {
                                    existingParent.element.attr('label', existingParent.label = optionGroupName);
                                }
                            }

                            lastElement = null;  // start at the beginning
                            for(index = 0, length = optionGroup.length; index < length; index++) {
                                option = optionGroup[index];
                                if ((existingOption = existingOptions[index+1])) {
                                    // reuse elements
                                    lastElement = existingOption.element;
                                    if (existingOption.label !== option.label) {
                                        lastElement.text(existingOption.label = option.label);
                                    }
                                    if (existingOption.id !== option.id) {
                                        lastElement.val(existingOption.id = option.id);
                                    }
                                    // lastElement.prop('selected') provided by jQuery has side-effects
                                    if (lastElement[0].selected !== option.selected) {
                                        lastElement.prop('selected', (existingOption.selected = option.selected));
                                    }
                                } else {
                                    // grow elements

                                    // if it's a null option
                                    if (option.id === '' && nullOption) {
                                        // put back the pre-compiled element
                                        element = nullOption;
                                    } else {
                                        // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
                                        // in this version of jQuery on some browser the .text() returns a string
                                        // rather then the element.
                                        (element = optionTemplate.clone())
                                            .val(option.id)
                                            .attr('selected', option.selected)
                                            .text(option.label);
                                    }

                                    existingOptions.push(existingOption = {
                                        element: element,
                                        label: option.label,
                                        id: option.id,
                                        selected: option.selected
                                    });
                                    if (lastElement) {
                                        lastElement.after(element);
                                    } else {
                                        existingParent.element.append(element);
                                    }
                                    lastElement = element;
                                }
                            }
                            // remove any excessive OPTIONs in a group
                            index++; // increment since the existingOptions[0] is parent element not OPTION
                            while(existingOptions.length > index) {
                                existingOptions.pop().element.remove();
                            }
                        }
                        // remove any excessive OPTGROUPs from select
                        while(optionGroupsCache.length > groupIndex) {
                            optionGroupsCache.pop()[0].element.remove();
                        }
                    }
                }
            }
        }
    }];

    var optionDirective = ['$interpolate', function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };

        return {
            restrict: 'E',
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), true);
                    if (!interpolateFn) {
                        attr.$set('value', element.text());
                    }
                }

                return function (scope, element, attr) {
                    var selectCtrlName = '$selectController',
                        parent = element.parent(),
                        selectCtrl = parent.data(selectCtrlName) ||
                            parent.parent().data(selectCtrlName); // in case we are in optgroup

                    if (selectCtrl && selectCtrl.databound) {
                        // For some reason Opera defaults to true and if not overridden this messes up the repeater.
                        // We don't want the view to drive the initialization of the model anyway.
                        element.prop('selected', false);
                    } else {
                        selectCtrl = nullSelectCtrl;
                    }

                    if (interpolateFn) {
                        scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                            attr.$set('value', newVal);
                            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);
                            selectCtrl.addOption(newVal);
                        });
                    } else {
                        selectCtrl.addOption(attr.value);
                    }

                    element.bind('$destroy', function() {
                        selectCtrl.removeOption(attr.value);
                    });
                };
            }
        }
    }];

    var styleDirective = valueFn({
        restrict: 'E',
        terminal: true
    });

    //try to bind to jquery now so that one can write angular.element().read()
    //but we will rebind on bootstrap again.
    bindJQuery();

    publishExternalAPI(angular);

    jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    });

})(window, document);
angular.element(document).find('head').append('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\:form{display:block;}</style>');
/**
 * Angular Carousel - Mobile friendly touch carousel for AngularJS
 * @version v0.0.9 - 2013-10-11
 * @link http://revolunet.github.com/angular-carousel
 * @author Julien Bouquillon <julien@revolunet.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
/**
 * @license AngularJS v1.1.5-3814986
 * (c) 2010-2012 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {
'use strict';

/**
 * @ngdoc overview
 * @name ngMobile
 * @description
 * Touch events and other mobile helpers.
 * Based on jQuery Mobile touch event handling (jquerymobile.com)
 */

// define ngMobile module
var ngMobile = angular.module('ngMobile', []);

/**
 * A service for abstracting swipe behavior. Deliberately internal; it is only intended for use in
 * ngSwipeLeft/Right and ngCarousel.
 *
 * Determining whether the user is swiping or scrolling, and handling both mouse and touch events,
 * make writing swipe code challenging. This service allows setting callbacks on the start,
 * movement and completion of a swipe gesture, without worrying about the complications.
 *
 */

ngMobile.factory('$swipe', [function() {
  // The total distance in any direction before we make the call on swipe vs. scroll.
  var MOVE_BUFFER_RADIUS = 10;

  // Absolute total movement, used to control swipe vs. scroll.
  var totalX, totalY;
  // Coordinates of the start position.
  var startCoords;
  // Last event's position.
  var lastPos;
  // Whether a swipe is active.
  var active = false;

  function getCoordinates(event) {
    var touches = event.touches && event.touches.length ? event.touches : [event];
    var e = (event.changedTouches && event.changedTouches[0]) ||
        (event.originalEvent && event.originalEvent.changedTouches &&
            event.originalEvent.changedTouches[0]) ||
        touches[0].originalEvent || touches[0];

    return {
      x: e.clientX,
      y: e.clientY
    };
  }

  return {
    bind: function(element, events) {
      element.bind('touchstart mousedown', function(event) {
        startCoords = getCoordinates(event);
        active = true;
        totalX = 0;
        totalY = 0;
        lastPos = startCoords;
        events['start'] && events['start'](startCoords);
      });

      element.bind('touchcancel', function(event) {
        active = false;
        events['cancel'] && events['cancel']();
      });

      element.bind('touchmove mousemove', function(event) {
        if (!active) return;

        // Android will send a touchcancel if it thinks we're starting to scroll.
        // So when the total distance (+ or - or both) exceeds 10px in either direction,
        // we either:
        // - On totalX > totalY, we send preventDefault() and treat this as a swipe.
        // - On totalY > totalX, we let the browser handle it as a scroll.

        if (!startCoords) return;
        var coords = getCoordinates(event);

        totalX += Math.abs(coords.x - lastPos.x);
        totalY += Math.abs(coords.y - lastPos.y);

        lastPos = coords;

        if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {
          return;
        }

        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.
        if (totalY > totalX) {
          // Allow native scrolling to take over.
          active = false;
          return;
        } else {
          // Prevent the browser from scrolling.
          event.preventDefault();

          events['move'] && events['move'](coords);
        }
      });

      element.bind('touchend mouseup', function(event) {
        if (!active) return;
        active = false;
        events['end'] && events['end'](getCoordinates(event));
      });
    }
  };
}]);

/**
 * @ngdoc directive
 * @name ngMobile.directive:ngTap
 *
 * @description
 * Specify custom behavior when element is tapped on a touchscreen device.
 * A tap is a brief, down-and-up touch without much motion.
 *
 * @element ANY
 * @param {expression} ngClick {@link guide/expression Expression} to evaluate
 * upon tap. (Event object is available as `$event`)
 *
 * @example
    <doc:example>
      <doc:source>
        <button ng-tap="count = count + 1" ng-init="count=0">
          Increment
        </button>
        count: {{ count }}
      </doc:source>
    </doc:example>
 */

ngMobile.config(['$provide', function($provide) {
  $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
    // drop the default ngClick directive
    $delegate.shift();
    return $delegate;
  }]);
}]);

ngMobile.directive('ngClick', ['$parse', '$timeout', '$rootElement',
    function($parse, $timeout, $rootElement) {
  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.
  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.
  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click
  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.
  var lastPreventedTime;
  var touchCoordinates;


  // TAP EVENTS AND GHOST CLICKS
  //
  // Why tap events?
  // Mobile browsers detect a tap, then wait a moment (usually ~300ms) to see if you're
  // double-tapping, and then fire a click event.
  //
  // This delay sucks and makes mobile apps feel unresponsive.
  // So we detect touchstart, touchmove, touchcancel and touchend ourselves and determine when
  // the user has tapped on something.
  //
  // What happens when the browser then generates a click event?
  // The browser, of course, also detects the tap and fires a click after a delay. This results in
  // tapping/clicking twice. So we do "clickbusting" to prevent it.
  //
  // How does it work?
  // We attach global touchstart and click handlers, that run during the capture (early) phase.
  // So the sequence for a tap is:
  // - global touchstart: Sets an "allowable region" at the point touched.
  // - element's touchstart: Starts a touch
  // (- touchmove or touchcancel ends the touch, no click follows)
  // - element's touchend: Determines if the tap is valid (didn't move too far away, didn't hold
  //   too long) and fires the user's tap handler. The touchend also calls preventGhostClick().
  // - preventGhostClick() removes the allowable region the global touchstart created.
  // - The browser generates a click event.
  // - The global click handler catches the click, and checks whether it was in an allowable region.
  //     - If preventGhostClick was called, the region will have been removed, the click is busted.
  //     - If the region is still there, the click proceeds normally. Therefore clicks on links and
  //       other elements without ngTap on them work normally.
  //
  // This is an ugly, terrible hack!
  // Yeah, tell me about it. The alternatives are using the slow click events, or making our users
  // deal with the ghost clicks, so I consider this the least of evils. Fortunately Angular
  // encapsulates this ugly logic away from the user.
  //
  // Why not just put click handlers on the element?
  // We do that too, just to be sure. The problem is that the tap event might have caused the DOM
  // to change, so that the click fires in the same position but something else is there now. So
  // the handlers are global and care only about coordinates and not elements.

  // Checks if the coordinates are close enough to be within the region.
  function hit(x1, y1, x2, y2) {
    return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;
  }

  // Checks a list of allowable regions against a click location.
  // Returns true if the click should be allowed.
  // Splices out the allowable region from the list after it has been used.
  function checkAllowableRegions(touchCoordinates, x, y) {
    for (var i = 0; i < touchCoordinates.length; i += 2) {
      if (hit(touchCoordinates[i], touchCoordinates[i+1], x, y)) {
        touchCoordinates.splice(i, i + 2);
        return true; // allowable region
      }
    }
    return false; // No allowable region; bust it.
  }

  // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick
  // was called recently.
  function onClick(event) {
    if (Date.now() - lastPreventedTime > PREVENT_DURATION) {
      return; // Too old.
    }

    var touches = event.touches && event.touches.length ? event.touches : [event];
    var x = touches[0].clientX;
    var y = touches[0].clientY;
    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label
    // and on the input element). Depending on the exact browser, this second click we don't want
    // to bust has either (0,0) or negative coordinates.
    if (x < 1 && y < 1) {
      return; // offscreen
    }

    // Look for an allowable region containing this click.
    // If we find one, that means it was created by touchstart and not removed by
    // preventGhostClick, so we don't bust it.
    if (checkAllowableRegions(touchCoordinates, x, y)) {
      return;
    }

    // If we didn't find an allowable region, bust the click.
    event.stopPropagation();
    event.preventDefault();
  }


  // Global touchstart handler that creates an allowable region for a click event.
  // This allowable region can be removed by preventGhostClick if we want to bust it.
  function onTouchStart(event) {
    var touches = event.touches && event.touches.length ? event.touches : [event];
    var x = touches[0].clientX;
    var y = touches[0].clientY;
    touchCoordinates.push(x, y);

    $timeout(function() {
      // Remove the allowable region.
      for (var i = 0; i < touchCoordinates.length; i += 2) {
        if (touchCoordinates[i] == x && touchCoordinates[i+1] == y) {
          touchCoordinates.splice(i, i + 2);
          return;
        }
      }
    }, PREVENT_DURATION, false);
  }

  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a
  // zone around the touchstart where clicks will get busted.
  function preventGhostClick(x, y) {
    if (!touchCoordinates) {
      $rootElement[0].addEventListener('click', onClick, true);
      $rootElement[0].addEventListener('touchstart', onTouchStart, true);
      touchCoordinates = [];
    }

    lastPreventedTime = Date.now();

    checkAllowableRegions(touchCoordinates, x, y);
  }

  // Actual linking function.
  return function(scope, element, attr) {
    var clickHandler = $parse(attr.ngClick),
        tapping = false,
        tapElement,  // Used to blur the element after a tap.
        startTime,   // Used to check if the tap was held too long.
        touchStartX,
        touchStartY;

    function resetState() {
      tapping = false;
    }

    element.bind('touchstart', function(event) {
      tapping = true;
      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.
      // Hack for Safari, which can target text nodes instead of containers.
      if(tapElement.nodeType == 3) {
        tapElement = tapElement.parentNode;
      }

      startTime = Date.now();

      var touches = event.touches && event.touches.length ? event.touches : [event];
      var e = touches[0].originalEvent || touches[0];
      touchStartX = e.clientX;
      touchStartY = e.clientY;
    });

    element.bind('touchmove', function(event) {
      resetState();
    });

    element.bind('touchcancel', function(event) {
      resetState();
    });

    element.bind('touchend', function(event) {
      var diff = Date.now() - startTime;

      var touches = (event.changedTouches && event.changedTouches.length) ? event.changedTouches :
          ((event.touches && event.touches.length) ? event.touches : [event]);
      var e = touches[0].originalEvent || touches[0];
      var x = e.clientX;
      var y = e.clientY;
      var dist = Math.sqrt( Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2) );

      if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {
        // Call preventGhostClick so the clickbuster will catch the corresponding click.
        preventGhostClick(x, y);

        // Blur the focused element (the button, probably) before firing the callback.
        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.
        // I couldn't get anything to work reliably on Android Chrome.
        if (tapElement) {
          tapElement.blur();
        }

        scope.$apply(function() {
          // TODO(braden): This is sending the touchend, not a tap or click. Is that kosher?
          clickHandler(scope, {$event: event});
        });
      }
      tapping = false;
    });

    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click
    // something else nearby.
    element.onclick = function(event) { };

    // Fallback click handler.
    // Busted clicks don't get this far, and adding this handler allows ng-tap to be used on
    // desktop as well, to allow more portable sites.
    element.bind('click', function(event) {
      scope.$apply(function() {
        clickHandler(scope, {$event: event});
      });
    });
  };
}]);

/**
 * @ngdoc directive
 * @name ngMobile.directive:ngSwipeLeft
 *
 * @description
 * Specify custom behavior when an element is swiped to the left on a touchscreen device.
 * A leftward swipe is a quick, right-to-left slide of the finger.
 * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag too.
 *
 * @element ANY
 * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate
 * upon left swipe. (Event object is available as `$event`)
 *
 * @example
    <doc:example>
      <doc:source>
        <div ng-show="!showActions" ng-swipe-left="showActions = true">
          Some list content, like an email in the inbox
        </div>
        <div ng-show="showActions" ng-swipe-right="showActions = false">
          <button ng-click="reply()">Reply</button>
          <button ng-click="delete()">Delete</button>
        </div>
      </doc:source>
    </doc:example>
 */

/**
 * @ngdoc directive
 * @name ngMobile.directive:ngSwipeRight
 *
 * @description
 * Specify custom behavior when an element is swiped to the right on a touchscreen device.
 * A rightward swipe is a quick, left-to-right slide of the finger.
 * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag too.
 *
 * @element ANY
 * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate
 * upon right swipe. (Event object is available as `$event`)
 *
 * @example
    <doc:example>
      <doc:source>
        <div ng-show="!showActions" ng-swipe-left="showActions = true">
          Some list content, like an email in the inbox
        </div>
        <div ng-show="showActions" ng-swipe-right="showActions = false">
          <button ng-click="reply()">Reply</button>
          <button ng-click="delete()">Delete</button>
        </div>
      </doc:source>
    </doc:example>
 */

function makeSwipeDirective(directiveName, direction) {
  ngMobile.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {
    // The maximum vertical delta for a swipe should be less than 75px.
    var MAX_VERTICAL_DISTANCE = 75;
    // Vertical distance should not be more than a fraction of the horizontal distance.
    var MAX_VERTICAL_RATIO = 0.3;
    // At least a 30px lateral motion is necessary for a swipe.
    var MIN_HORIZONTAL_DISTANCE = 30;

    return function(scope, element, attr) {
      var swipeHandler = $parse(attr[directiveName]);

      var startCoords, valid;

      function validSwipe(coords) {
        // Check that it's within the coordinates.
        // Absolute vertical distance must be within tolerances.
        // Horizontal distance, we take the current X - the starting X.
        // This is negative for leftward swipes and positive for rightward swipes.
        // After multiplying by the direction (-1 for left, +1 for right), legal swipes
        // (ie. same direction as the directive wants) will have a positive delta and
        // illegal ones a negative delta.
        // Therefore this delta must be positive, and larger than the minimum.
        if (!startCoords) return false;
        var deltaY = Math.abs(coords.y - startCoords.y);
        var deltaX = (coords.x - startCoords.x) * direction;
        return valid && // Short circuit for already-invalidated swipes.
            deltaY < MAX_VERTICAL_DISTANCE &&
            deltaX > 0 &&
            deltaX > MIN_HORIZONTAL_DISTANCE &&
            deltaY / deltaX < MAX_VERTICAL_RATIO;
      }

      $swipe.bind(element, {
        'start': function(coords) {
          startCoords = coords;
          valid = true;
        },
        'cancel': function() {
          valid = false;
        },
        'end': function(coords) {
          if (validSwipe(coords)) {
            scope.$apply(function() {
              swipeHandler(scope);
            });
          }
        }
      });
    };
  }]);
}

// Left is negative X-coordinate, right is positive.
makeSwipeDirective('ngSwipeLeft', -1);
makeSwipeDirective('ngSwipeRight', 1);



})(window, window.angular);

/**
 * Angular Carousel - Mobile friendly touch carousel for AngularJS
 * @version v0.0.9 - 2013-10-11
 * @link http://revolunet.github.com/angular-carousel
 * @author Julien Bouquillon <julien@revolunet.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
/*global angular */

/*
Angular touch carousel with CSS GPU accel and slide buffering/cycling
http://github.com/revolunet/angular-carousel

TODO : 
 - skip initial animation
 - add/remove ngRepeat collection
 - prev/next cbs
 - cycle + no initial index ? (is -1 and has bug)
 - cycle + indicator
*/

angular.module('angular-carousel', ['ngMobile']);

angular.module('angular-carousel')

.directive('rnCarouselIndicators', [function() {
  return {
    restrict: 'A',
    replace: true,
    scope: {
      items: '=',
      index: '='
    },
    template: '<div class="rn-carousel-indicator">' +
                '<span ng-repeat="item in items" ng-class="{active: $index==$parent.index}">●</span>' +
              '</div>'
  };
}]);

angular.module('angular-carousel')

.directive('rnCarouselInfinite', ['$parse', '$compile', function($parse, $compile) {
  return {
    restrict: 'EA',
    transclude:  true,
    replace: true,
    scope: true,
    template: '<ul rn-carousel rn-carousel-buffered><li ng-transclude></li></ul>',
    compile: function(tElement, tAttrs, linker) {
      var repeatExpr = tAttrs.rnCarouselCurrent + ' in items';
      tElement.children('li').attr('ng-repeat', repeatExpr);
      return function(scope, iElement, iAttrs) {
        // wrap the original content in a real rn-carousel
        scope.items = [$parse(iAttrs.rnCarouselCurrent)(scope)];
        scope.$watchCollection('carouselCollection.position', function(newValue) {
          // assign the new item to the parent scope
          $parse(iAttrs.rnCarouselCurrent).assign(scope.$parent, scope.items[newValue]);
        });
      };
    }
  };
}]);

angular.module('angular-carousel')

.directive('rnCarousel', ['$compile', '$parse', '$swipe', '$document', '$window', 'CollectionManager', function($compile, $parse, $swipe, $document, $window, CollectionManager) {
  /* track number of carousel instances */
  var carousels = 0;

  return {
    restrict: 'A',
    scope: true,
    compile: function(tElement, tAttrs) {

      tElement.addClass('rn-carousel-slides');

      /* extract the ngRepeat expression from the first li attribute
         this expression will be used to update the carousel
         buffered carousels will add a slice operator to that expression

         if no ng-repeat found, try to use existing <li> DOM nodes
      */
      var liAttributes = tElement.children('li')[0].attributes,
          repeatAttribute = liAttributes['ng-repeat'],
          isBuffered = false,
          originalCollection,
          fakeArray;
      if (!repeatAttribute) repeatAttribute = liAttributes['data-ng-repeat'];
      if (!repeatAttribute) repeatAttribute = liAttributes['x-ng-repeat'];
      if (!repeatAttribute) {
        var liChilds = tElement.children('li');
        if (liChilds.length < 2) {
          throw new Error("carousel: cannot find the ngRepeat attribute OR no childNodes detected");
        }
        // if we use DOM nodes instead of ng-repeat, create a fake collection
        originalCollection = 'fakeArray';
        fakeArray = Array.prototype.slice.apply(liChilds);
      } else {
        var exprMatch = repeatAttribute.value.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),
            originalItem = exprMatch[1],
            trackProperty = exprMatch[3] || '';
        originalCollection = exprMatch[2];
        isBuffered = angular.isDefined(tAttrs['rnCarouselBuffered']);

          /* update the current ngRepeat expression and add a slice operator */
          repeatAttribute.value = originalItem + ' in carouselCollection.cards ' + trackProperty;
      }
      return function(scope, iElement, iAttrs, controller) {
        carousels++;
        var carouselId = 'rn-carousel-' + carousels,
            swiping = 0,                    // swipe status
            startX = 0,                     // initial swipe
            startOffset  = 0,               // first move offset
            offset  = 0,                    // move offset
            minSwipePercentage = 0.1,       // minimum swipe required to trigger slide change
            containerWidth = 0,          // store width of the first slide
            skipAnimation = false;

        /* add a wrapper div that will hide the overflow */
        var carousel = iElement.wrap("<div id='" + carouselId +"' class='rn-carousel-container'></div>"),
            container = carousel.parent();

        if (fakeArray) {
          // publish the fakeArray on the scope to be able to add indicators
          scope.fakeArray = fakeArray;
        }

        function getTransformCoordinates(el) {
          var results = angular.element(el).css('transform').match(/translate3d\((-?\d+(?:px)?),\s*(-?\d+(?:px)?),\s*(-?\d+(?:px)?)\)/);
          if(!results) return [0, 0, 0];
          return results.slice(1, 3);
        }

        function transitionEndCallback(event) {
          /* when slide transition finished, update buffer */
          if ((event.target && event.target=== carousel[0]) && (
              event.propertyName === 'transform' ||
              event.propertyName === '-webkit-transform' ||
              event.propertyName === '-moz-transform')
          ) {
            scope.$apply(function() {
              checkEdges();
              scope.carouselCollection.adjustBuffer();
              updateSlidePosition(true);
            });

          // we should replace the 3d transform with 2d transform to prevent blurry effect on some phones (eg: GS3)
          // todo : use non-3d version for browsers not supporting it
          carousel.css(translateSlideProperty(getTransformCoordinates(carousel[0]), true));

          }
        }

        function updateSlides(method, items) {
          // force apply if no apply/digest phase in progress
          function cb() {
            skipAnimation = true;
            scope.carouselCollection[method](items, true);
          }
          if(!scope.$$phase) {
            scope.$apply(cb);
          } else {
            cb();
          }

        }

        function addSlides(position, items) {
          var method = (position==='after')?'push':'unshift';
          if (items) {
            if (angular.isObject(items.promise)) {
              items.promise.then(function(items) {
                if (items) {
                  updateSlides(method, items);
                }
              });
            } else if (angular.isFunction(items.then)) {
              items.then(function(items) {
                if (items) {
                  updateSlides(method, items);
                }
              });
            } else {
              updateSlides(method, items);
            }
          }
        }

        function checkEdges() {
          var position = scope.carouselCollection.position,
              lastIndex = scope.carouselCollection.getLastIndex(),
              slides=null;
          if (position===0 && angular.isDefined(iAttrs.rnCarouselPrev)) {
            slides = $parse(iAttrs.rnCarouselPrev)(scope, {
              item: scope.carouselCollection.cards[0]
            });
            addSlides('before', slides);
          }
          if (position===lastIndex && angular.isDefined(iAttrs.rnCarouselNext)) {
            slides = $parse(iAttrs.rnCarouselNext)(scope, {
              item: scope.carouselCollection.cards[scope.carouselCollection.cards.length - 1]
            });
            addSlides('after', slides);
          }
        }

        var collectionModel = $parse(originalCollection);
        var collectionParams = {};

        /* rn-carousel-index attribute data binding */
        var initialIndex = 0;
        if (iAttrs.rnCarouselIndex) {
            var indexModel = $parse(iAttrs.rnCarouselIndex);
            if (angular.isFunction(indexModel.assign)) {
              /* check if this property is assignable then watch it */
              scope.$watch('carouselCollection.index', function(newValue) {
                indexModel.assign(scope.$parent, newValue);
              });
              initialIndex = indexModel(scope);
              scope.$parent.$watch(indexModel, function(newValue, oldValue) {
                  if (newValue!==undefined) {
                    scope.carouselCollection.goToIndex(newValue, true);
                  }
                });
            } else if (!isNaN(iAttrs.rnCarouselIndex)) {
              /* if user just set an initial number, set it */
              initialIndex = parseInt(iAttrs.rnCarouselIndex, 10);
            }
        }

        if (angular.isDefined(iAttrs.rnCarouselCycle)) {
          collectionParams.cycle = true;
        }
        collectionParams.index = initialIndex;

        if (isBuffered) {
          collectionParams.bufferSize = 3;
          collectionParams.buffered = true;
        }

        // initialise the collection
        scope.carouselCollection = CollectionManager.create(collectionParams);

        scope.$watch('carouselCollection.updated', function(newValue, oldValue) {
          if (newValue) updateSlidePosition();
        });

        var collectionReady = false;
        scope.$watch(collectionModel, function(newValue, oldValue) {
          // update whole collection contents
          // reinitialise index
          scope.carouselCollection.setItems(newValue, collectionReady);
          collectionReady = true;
          if (containerWidth===0) updateContainerWidth();
          updateSlidePosition();
        });

        if (angular.isDefined(iAttrs.rnCarouselWatch)) {
          scope.$watch(originalCollection, function(newValue, oldValue) {
            // partial collection update, watch deeply so use carefully
            scope.carouselCollection.setItems(newValue, false);
            collectionReady = true;
            if (containerWidth===0) updateContainerWidth();
            updateSlidePosition();
          }, true);
        }

        var vendorPrefixes = ["webkit", "moz"];
        function genCSSProperties(property, value) {
          /* cross browser CSS properties generator */
          var css = {};
          css[property] = value;
          angular.forEach(vendorPrefixes, function(prefix, idx) {
            css['-' + prefix.toLowerCase() + '-' + property] = value;
          });
          return css;
        }
        function translateSlideProperty(offset, is3d) {
          if (is3d) {
            return genCSSProperties('transform', 'translate3d(' + offset + 'px,0,0)');
          } else {
            return genCSSProperties('transform', 'translate(' + offset + 'px,0)');
          }
        }

        carousel[0].addEventListener('webkitTransitionEnd', transitionEndCallback, false);  // webkit
        carousel[0].addEventListener('transitionend', transitionEndCallback, false);        // mozilla

        // when orientation change, force width re-redetection
        window.addEventListener('orientationchange', resize);
        // when window is resized (responsive design)
        window.addEventListener('resize', resize);

        function resize () {
            updateContainerWidth();
            updateSlidePosition();
        }

        function updateContainerWidth() {
            container.css('width', 'auto');
            skipAnimation = true;
            var slides = carousel.children('li');
            if (slides.length === 0) {
              containerWidth = carousel[0].getBoundingClientRect().width;
            } else {
              containerWidth = slides[0].getBoundingClientRect().width;
            }
            container.css('width', containerWidth + 'px');
            return containerWidth;
        }

        /* enable carousel indicator */
        if (angular.isDefined(iAttrs.rnCarouselIndicator)) {
          var indicator = $compile("<div id='" + carouselId +"-indicator' index='carouselCollection.index' items='carouselCollection.items' data-rn-carousel-indicators class='rn-carousel-indicator'></div>")(scope);
          container.append(indicator);
        }

        function updateSlidePosition(forceSkipAnimation) {
          /* trigger carousel position update */
          skipAnimation = !!forceSkipAnimation || skipAnimation;
          if (containerWidth===0) updateContainerWidth();
          offset = Math.round(scope.carouselCollection.getRelativeIndex() * -containerWidth);
          if (skipAnimation===true) {
              carousel.removeClass('rn-carousel-animate')
                  .addClass('rn-carousel-noanimate')
                  .css(translateSlideProperty(offset, false));
          } else {
              carousel.removeClass('rn-carousel-noanimate')
                  .addClass('rn-carousel-animate')
                  .css(translateSlideProperty(offset, true));
          }
          skipAnimation = false;
        }

        /* bind events */

        function swipeEnd(coords) {
            /* when movement ends, go to next slide or stay on the same */
            $document.unbind('mouseup', documentMouseUpEvent);
            if (containerWidth===0) updateContainerWidth();
            if (swiping > 1) {
              var lastIndex = scope.carouselCollection.getLastIndex(),
                  position = scope.carouselCollection.position,
                  slideOffset = (offset < startOffset)?1:-1,
                  tmpSlideIndex = Math.min(Math.max(0, position + slideOffset), lastIndex);
              var delta = coords.x - startX;
              if (Math.abs(delta) <= containerWidth * minSwipePercentage) {
                /* prevent swipe if not swipped enough */
                tmpSlideIndex = position;
              }
              var changed = (position !== tmpSlideIndex);
              //console.log(offset, startOffset, slideOffset);
              /* reset slide position if same slide (watch not triggered) */
              if (!changed) {
                scope.$apply(function() {
                  updateSlidePosition();
                });
              } else {
                scope.$apply(function() {
                  if (angular.isDefined(iAttrs.rnCarouselCycle)) {
                    // force slide move even if invalid position for cycle carousels
                    scope.carouselCollection.position = tmpSlideIndex;
                    updateSlidePosition();
                  }
                  scope.carouselCollection.goTo(tmpSlideIndex, true);
                });
              }
            }
            swiping = 0;
        }
        function isInsideCarousel(coords) {
          // check coords are inside the carousel area
          // we always compute the container dimensions in case user have scrolled the page
          var containerRect = container[0].getBoundingClientRect();

          var isInside = (coords.x > containerRect.left && coords.x < (containerRect.left + containerWidth) &&
                  (coords.y > containerRect.top && coords.y < containerRect.top + containerRect.height));

          // console.log('isInsideCarousel', {
          //   containerLeft: containerRect.left,
          //   containerTop: containerRect.top,
          //   containerHeight: containerRect.height,
          //   isInside: isInside,
          //   x: coords.x,
          //   y: coords.y
          // });
          return isInside;
        }
        function documentMouseUpEvent(event) {
          swipeEnd({
            x: event.clientX,
            y: event.clientY
          });
        }
        // move throttling
        var lastMove = null,
            // todo: requestAnimationFrame instead
            moveDelay = ($window.jasmine || $window.navigator.platform=='iPad')?0:50;

        $swipe.bind(carousel, {
          /* use angular $swipe service */
          start: function(coords) {
           // console.log('$swipe start');
            /* capture initial event position */
            if (swiping === 0) {
              swiping = 1;
              startX = coords.x;
            }
            $document.bind('mouseup', documentMouseUpEvent);
          },
          move: function (coords) {
            // cancel movement if not inside
            if (!isInsideCarousel(coords)) {
             // console.log('force end');
              swipeEnd(coords);
              return;
            }
            //console.log('$swipe move');
            if (swiping===0) return;
            var deltaX = coords.x - startX;
            if (swiping === 1 && deltaX !== 0) {
              swiping = 2;
              startOffset = offset;
            }
            else if (swiping === 2) {
              var now = (new Date()).getTime();
              if (lastMove && (now-lastMove) < moveDelay) return;
              lastMove = now;
              var lastIndex = scope.carouselCollection.getLastIndex(),
                  position = scope.carouselCollection.position;
              /* ratio is used for the 'rubber band' effect */
              var ratio = 1;
              if ((position === 0 && coords.x > startX) || (position === lastIndex && coords.x < startX))
                ratio = 3;
              /* follow cursor movement */
              offset = startOffset + deltaX / ratio;
              carousel.css(translateSlideProperty(offset, true))
                      .removeClass('rn-carousel-animate')
                      .addClass('rn-carousel-noanimate');
            }
          },
          end: function (coords) {
            //console.log('$swipe end');
            swipeEnd(coords);
          }
        });
      //  if (containerWidth===0) updateContainerWidth();
      };
    }
  };
}]);

/**
* CollectionManager.js
* - manage a collection of items
* - rearrange items if buffered or cycle
* - the service is just a wrapper around a non-angular collection manager
**/
angular.module('angular-carousel')

.service('CollectionManager', [function() {

    function CollectionManager(options) {
        var initial = {
            bufferSize: 0,
            bufferStart: 0,
            buffered: false,
            cycle: false,
            cycleOffset: 0,            // offset
            index: 0,                  // index relative to the original collection
            position: 0,               // position relative to the current elements
            items: [],                 // total collection
            cards: [],                 // bufered DOM collection
            updated: null,             // triggers DOM change
            debug: false
        };

        var i;
        if(options) for(i in options) initial[i] = options[i];
        for(i in initial) this[i] = initial[i];

        angular.extend(this, initial, options);

        this.init();

    }

    CollectionManager.prototype.log = function() {
        if (this.debug) {
            console.log.apply(console, arguments);
           // console.log('CollectionManager:', this);
        }
    };
    CollectionManager.prototype.getPositionFromIndex = function(index) {
        return (index + this.cycleOffset) % this.length();
    };

    CollectionManager.prototype.goToIndex = function(index, delayedUpdate) {
        // cap index
        index = Math.max(0, Math.min(index, this.getLastIndex()));
        if (this.updated && index===this.index) {
            this.log('skip position change(same)');
            return false;
        }
        var position = this.getPositionFromIndex(index);
        return this.goTo(position, delayedUpdate);
    };

    CollectionManager.prototype.goTo = function(position, delayedUpdate) {
        this.log('goto start', position, delayedUpdate);

        if (this.length()===0) {
            this.log('empty, skip gotoIndex');
            return;
        }
        // cap position
        position = Math.max(0, Math.min(position, this.getLastIndex()));
        var cycled = false;
        if (this.cycle) {
            if (position===0) {
                // unshift
                this.log('cycleAtBeginning', position);
                this.cycleAtBeginning();
                position = 1;
                this.cycleOffset++;
                cycled = true;
            } else if (position === this.getLastIndex()) {
                // push
                this.log('cycleAtEnd', position);
                this.cycleAtEnd();
                position--;
                this.cycleOffset--;
                cycled = true;
            }
            this.cycleOffset %= this.length();
        }

        this.position = Math.max(0, Math.min(position, this.getLastIndex()));

        var realIndex = (this.position - this.cycleOffset + this.length()) % this.length();
        this.index = Math.max(0, Math.min(realIndex, this.getLastIndex()));

        if (!delayedUpdate) {
            this.adjustBuffer();
        }
        if (!cycled) this.updated = new Date();

    };

    CollectionManager.prototype.next = function() {
        // go to next item
        if (this.cycle) {
            this.goTo((this.position + 1) % this.length());
        } else {
            this.goTo(Math.min(this.position + 1, this.getLastIndex()));
        }
    };
    CollectionManager.prototype.prev = function() {
        // go to prev item
        if (this.cycle) {
            this.goTo((this.position - 1 + this.length()) % this.length());
        } else {
            var prevIndex = (this.length()>0)?(Math.max(0, (this.position - 1) % this.length())):0;
            this.goTo(prevIndex);
        }
    };
    CollectionManager.prototype.setBufferSize = function(length) {
        this.log('setBufferSize', length);
        this.bufferSize = length;
        this.adjustBuffer();
    };
    CollectionManager.prototype.isBuffered = function() {
        return this.buffered;
    };
    CollectionManager.prototype.getRelativeIndex = function() {
        var relativeIndex = Math.max(0, Math.min(this.getLastIndex(), this.position - this.bufferStart));
        return relativeIndex;
    };
    CollectionManager.prototype.adjustBuffer = function() {
        // adjust buffer start position
        var maxBufferStart = (this.getLastIndex() + 1 - this.bufferSize) % this.length();
        this.log('maxBufferStart', maxBufferStart);
        this.bufferStart = Math.max(0, Math.min(maxBufferStart, this.position - 1));
        this.cards = this.items.slice(this.bufferStart, this.bufferStart + this.bufferSize);
        this.log('adjustBuffer from', this.bufferStart, 'to', this.bufferStart + this.bufferSize);
    };
    CollectionManager.prototype.length = function() {
        return this.items.length;
    };
    CollectionManager.prototype.getLastIndex = function() {
        var lastIndex = Math.max(0, this.length() - 1);
        return lastIndex;
    };
    CollectionManager.prototype.init = function() {
        //this.log('init', this);
        this.setBufferSize(this.isBuffered()?this.bufferSize:this.length());
        if (this.length() > 0) this.goToIndex(this.index);
    };
    CollectionManager.prototype.setItems = function(items, reset) {
        this.log('setItems', items, reset);
        if (reset) {
            this.index=0;
            this.position=0;
        }
        this.items = items || [];  // prevent internal errors when items is undefined
        this.init();
    };
    CollectionManager.prototype.cycleAtEnd = function() {
        // extract first item and put it at end
        this.push(this.items.shift());
    };
    CollectionManager.prototype.push = function(slide, updateIndex) {
        // insert item(s) at end
        this.log('push item(s)', slide, updateIndex);
        // if (this.items.indexOf(slide)>-1) {
        //     this.log('item already present, skip it');
        //     return;
        // }
        this.items.push(slide);
        if (updateIndex) {
            // no need to change index when appending items
            this.adjustBuffer();
            this.updated = new Date();
        }
        if (!this.buffered) {
            this.bufferSize++;
        }
    };
    CollectionManager.prototype.unshift = function(slide, updateIndex) {
        // insert item(s) at beginning
        this.log('unshift item(s)', slide, updateIndex);
        // if (this.items.indexOf(slide)>-1) {
        //     this.log('item already present, skip it');
        //     return;
        // }
        this.items.unshift(slide);
        if (!this.buffered) {
            this.bufferSize++;
        }
        if (updateIndex) {
            this.position++;
            this.adjustBuffer();
            this.updated = new Date();
        }
    };
    CollectionManager.prototype.cycleAtBeginning = function() {
        // extract last item and put it at beginning
        this.unshift(this.items.pop());
    };
    return {
        create: function(options) {
            return new CollectionManager(options);
        }
    };
}]);

/* ===================================================
 * bootstrap-transition.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#transitions
 * ===================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


  /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
   * ======================================================= */

  $(function () {

    $.support.transition = (function () {

      var transitionEnd = (function () {

        var el = document.createElement('bootstrap')
          , transEndEventNames = {
               'WebkitTransition' : 'webkitTransitionEnd'
            ,  'MozTransition'    : 'transitionend'
            ,  'OTransition'      : 'oTransitionEnd otransitionend'
            ,  'transition'       : 'transitionend'
            }
          , name

        for (name in transEndEventNames){
          if (el.style[name] !== undefined) {
            return transEndEventNames[name]
          }
        }

      }())

      return transitionEnd && {
        end: transitionEnd
      }

    })()

  })

}(window.jQuery);
/* =========================================================
 * bootstrap-modal.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#modals
 * =========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */


!function ($) {

  "use strict"; // jshint ;_;


 /* MODAL CLASS DEFINITION
  * ====================== */

  var Modal = function (element, options) {
    this.options = options
    this.$element = $(element)
      .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)
  }

  Modal.prototype = {

      constructor: Modal

    , toggle: function () {
        return this[!this.isShown ? 'show' : 'hide']()
      }

    , show: function () {
        var that = this
          , e = $.Event('show')

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        this.isShown = true

        this.escape()

        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade')

          if (!that.$element.parent().length) {
            that.$element.appendTo(document.body) //don't move modals dom position
          }

          that.$element.show()

          if (transition) {
            that.$element[0].offsetWidth // force reflow
          }

          that.$element
            .addClass('in')
            .attr('aria-hidden', false)

          that.enforceFocus()

          transition ?
            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :
            that.$element.focus().trigger('shown')

        })
      }

    , hide: function (e) {
        e && e.preventDefault()

        var that = this

        e = $.Event('hide')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        this.escape()

        $(document).off('focusin.modal')

        this.$element
          .removeClass('in')
          .attr('aria-hidden', true)

        $.support.transition && this.$element.hasClass('fade') ?
          this.hideWithTransition() :
          this.hideModal()
      }

    , enforceFocus: function () {
        var that = this
        $(document).on('focusin.modal', function (e) {
          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
            that.$element.focus()
          }
        })
      }

    , escape: function () {
        var that = this
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keyup.dismiss.modal', function ( e ) {
            e.which == 27 && that.hide()
          })
        } else if (!this.isShown) {
          this.$element.off('keyup.dismiss.modal')
        }
      }

    , hideWithTransition: function () {
        var that = this
          , timeout = setTimeout(function () {
              that.$element.off($.support.transition.end)
              that.hideModal()
            }, 500)

        this.$element.one($.support.transition.end, function () {
          clearTimeout(timeout)
          that.hideModal()
        })
      }

    , hideModal: function () {
        var that = this
        this.$element.hide()
        this.backdrop(function () {
          that.removeBackdrop()
          that.$element.trigger('hidden')
        })
      }

    , removeBackdrop: function () {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
      }

    , backdrop: function (callback) {
        var that = this
          , animate = this.$element.hasClass('fade') ? 'fade' : ''

        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate

          this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
            .appendTo(document.body)

          this.$backdrop.click(
            this.options.backdrop == 'static' ?
              $.proxy(this.$element[0].focus, this.$element[0])
            : $.proxy(this.hide, this)
          )

          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

          this.$backdrop.addClass('in')

          if (!callback) return

          doAnimate ?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in')

          $.support.transition && this.$element.hasClass('fade')?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (callback) {
          callback()
        }
      }
  }


 /* MODAL PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.modal

  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('modal')
        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option]()
      else if (options.show) data.show()
    })
  }

  $.fn.modal.defaults = {
      backdrop: true
    , keyboard: true
    , show: true
  }

  $.fn.modal.Constructor = Modal


 /* MODAL NO CONFLICT
  * ================= */

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


 /* MODAL DATA-API
  * ============== */

  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this)
      , href = $this.attr('href')
      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())

    e.preventDefault()

    $target
      .modal(option)
      .one('hide', function () {
        $this.focus()
      })
  })

}(window.jQuery);

/* ===========================================================
 * bootstrap-tooltip.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init('tooltip', element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut
        , triggers
        , trigger
        , i

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      triggers = this.options.trigger.split(' ')

      for (i = triggers.length; i--;) {
        trigger = triggers[i]
        if (trigger == 'click') {
          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
        } else if (trigger != 'manual') {
          eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
          eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
          this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var defaults = $.fn[this.type].defaults
        , options = {}
        , self

      this._options && $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      }, this)

      self = $(e.currentTarget)[this.type](options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = 'in'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = 'out'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp
        , e = $.Event('show')

      if (this.hasContent() && this.enabled) {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass('fade')
        }

        placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        $tip
          .detach()
          .css({ top: 0, left: 0, display: 'block' })

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

        pos = this.getPosition()

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (placement) {
          case 'bottom':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'top':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'left':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case 'right':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break
        }

        this.applyPlacement(tp, placement)
        this.$element.trigger('shown')
      }
    }

  , applyPlacement: function(offset, placement){
      var $tip = this.tip()
        , width = $tip[0].offsetWidth
        , height = $tip[0].offsetHeight
        , actualWidth
        , actualHeight
        , delta
        , replace

      $tip
        .offset(offset)
        .addClass(placement)
        .addClass('in')

      actualWidth = $tip[0].offsetWidth
      actualHeight = $tip[0].offsetHeight

      if (placement == 'top' && actualHeight != height) {
        offset.top = offset.top + height - actualHeight
        replace = true
      }

      if (placement == 'bottom' || placement == 'top') {
        delta = 0

        if (offset.left < 0){
          delta = offset.left * -2
          offset.left = 0
          $tip.offset(offset)
          actualWidth = $tip[0].offsetWidth
          actualHeight = $tip[0].offsetHeight
        }

        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
      } else {
        this.replaceArrow(actualHeight - height, actualHeight, 'top')
      }

      if (replace) $tip.offset(offset)
    }

  , replaceArrow: function(delta, dimension, position){
      this
        .arrow()
        .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()
        , e = $.Event('hide')

      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return

      $tip.removeClass('in')

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).detach()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.detach()
        })
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        removeWithAnimation() :
        $tip.detach()

      this.$element.trigger('hidden')

      return this
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function () {
      var el = this.$element[0]
      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
        width: el.offsetWidth
      , height: el.offsetHeight
      }, this.$element.offset())
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , arrow: function(){
      return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function (e) {
      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
      self.tip().hasClass('in') ? self.hide() : self.show()
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  var old = $.fn.tooltip

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tooltip')
        , options = typeof option == 'object' && option
      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }


 /* TOOLTIP NO CONFLICT
  * =================== */

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(window.jQuery);

/* ===========================================================
 * bootstrap-popover.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#popovers
 * ===========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* POPOVER PUBLIC CLASS DEFINITION
  * =============================== */

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }


  /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
     ========================================== */

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {

    constructor: Popover

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()
        , content = this.getContent()

      $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
      $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

      $tip.removeClass('fade top bottom left right in')
    }

  , hasContent: function () {
      return this.getTitle() || this.getContent()
    }

  , getContent: function () {
      var content
        , $e = this.$element
        , o = this.options

      content = (typeof o.content == 'function' ? o.content.call($e[0]) :  o.content)
        || $e.attr('data-content')

      return content
    }

  , tip: function () {
      if (!this.$tip) {
        this.$tip = $(this.options.template)
      }
      return this.$tip
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  })


 /* POPOVER PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.popover

  $.fn.popover = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('popover')
        , options = typeof option == 'object' && option
      if (!data) $this.data('popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.popover.Constructor = Popover

  $.fn.popover.defaults = $.extend({} , $.fn.tooltip.defaults, {
    placement: 'right'
  , trigger: 'click'
  , content: ''
  , template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


 /* POPOVER NO CONFLICT
  * =================== */

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(window.jQuery);

/* ==========================================================
 * bootstrap-affix.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#affix
 * ==========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* AFFIX CLASS DEFINITION
  * ====================== */

  var Affix = function (element, options) {
    this.options = $.extend({}, $.fn.affix.defaults, options)
    this.$window = $(window)
      .on('scroll.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.affix.data-api',  $.proxy(function () { setTimeout($.proxy(this.checkPosition, this), 1) }, this))
    this.$element = $(element)
    this.checkPosition()
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var scrollHeight = $(document).height()
      , scrollTop = this.$window.scrollTop()
      , position = this.$element.offset()
      , offset = this.options.offset
      , offsetBottom = offset.bottom
      , offsetTop = offset.top
      , reset = 'affix affix-top affix-bottom'
      , affix

    if (typeof offset != 'object') offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function') offsetTop = offset.top()
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()

    affix = this.unpin != null && (scrollTop + this.unpin <= position.top) ?
      false    : offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ?
      'bottom' : offsetTop != null && scrollTop <= offsetTop ?
      'top'    : false

    if (this.affixed === affix) return

    this.affixed = affix
    this.unpin = affix == 'bottom' ? position.top - scrollTop : null

    this.$element.removeClass(reset).addClass('affix' + (affix ? '-' + affix : ''))
  }


 /* AFFIX PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.affix

  $.fn.affix = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('affix')
        , options = typeof option == 'object' && option
      if (!data) $this.data('affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.affix.Constructor = Affix

  $.fn.affix.defaults = {
    offset: 0
  }


 /* AFFIX NO CONFLICT
  * ================= */

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


 /* AFFIX DATA-API
  * ============== */

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
        , data = $spy.data()

      data.offset = data.offset || {}

      data.offsetBottom && (data.offset.bottom = data.offsetBottom)
      data.offsetTop && (data.offset.top = data.offsetTop)

      $spy.affix(data)
    })
  })


}(window.jQuery);
/* ==========================================================
 * bootstrap-alert.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#alerts
 * ==========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* ALERT CLASS DEFINITION
  * ====================== */

  var dismiss = '[data-dismiss="alert"]'
    , Alert = function (el) {
        $(el).on('click', dismiss, this.close)
      }

  Alert.prototype.close = function (e) {
    var $this = $(this)
      , selector = $this.attr('data-target')
      , $parent

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    $parent = $(selector)

    e && e.preventDefault()

    $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())

    $parent.trigger(e = $.Event('close'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      $parent
        .trigger('closed')
        .remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent.on($.support.transition.end, removeElement) :
      removeElement()
  }


 /* ALERT PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.alert

  $.fn.alert = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('alert')
      if (!data) $this.data('alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.alert.Constructor = Alert


 /* ALERT NO CONFLICT
  * ================= */

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


 /* ALERT DATA-API
  * ============== */

  $(document).on('click.alert.data-api', dismiss, Alert.prototype.close)

}(window.jQuery);
/* ============================================================
 * bootstrap-button.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#buttons
 * ============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

  "use strict"; // jshint ;_;


 /* BUTTON PUBLIC CLASS DEFINITION
  * ============================== */

  var Button = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, $.fn.button.defaults, options)
  }

  Button.prototype.setState = function (state) {
    var d = 'disabled'
      , $el = this.$element
      , data = $el.data()
      , val = $el.is('input') ? 'val' : 'html'

    state = state + 'Text'
    data.resetText || $el.data('resetText', $el[val]())

    $el[val](data[state] || this.options[state])

    // push to event loop to allow forms to submit
    setTimeout(function () {
      state == 'loadingText' ?
        $el.addClass(d).attr(d, d) :
        $el.removeClass(d).removeAttr(d)
    }, 0)
  }

  Button.prototype.toggle = function () {
    var $parent = this.$element.closest('[data-toggle="buttons-radio"]')

    $parent && $parent
      .find('.active')
      .removeClass('active')

    this.$element.toggleClass('active')
  }


 /* BUTTON PLUGIN DEFINITION
  * ======================== */

  var old = $.fn.button

  $.fn.button = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('button')
        , options = typeof option == 'object' && option
      if (!data) $this.data('button', (data = new Button(this, options)))
      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  $.fn.button.defaults = {
    loadingText: 'loading...'
  }

  $.fn.button.Constructor = Button


 /* BUTTON NO CONFLICT
  * ================== */

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


 /* BUTTON DATA-API
  * =============== */

  $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) {
    var $btn = $(e.target)
    if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
    $btn.button('toggle')
  })

}(window.jQuery);
/* =============================================================
 * bootstrap-collapse.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#collapse
 * =============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

  "use strict"; // jshint ;_;


 /* COLLAPSE PUBLIC CLASS DEFINITION
  * ================================ */

  var Collapse = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, $.fn.collapse.defaults, options)

    if (this.options.parent) {
      this.$parent = $(this.options.parent)
    }

    this.options.toggle && this.toggle()
  }

  Collapse.prototype = {

    constructor: Collapse

  , dimension: function () {
      var hasWidth = this.$element.hasClass('width')
      return hasWidth ? 'width' : 'height'
    }

  , show: function () {
      var dimension
        , scroll
        , actives
        , hasData

      if (this.transitioning || this.$element.hasClass('in')) return

      dimension = this.dimension()
      scroll = $.camelCase(['scroll', dimension].join('-'))
      actives = this.$parent && this.$parent.find('> .accordion-group > .in')

      if (actives && actives.length) {
        hasData = actives.data('collapse')
        if (hasData && hasData.transitioning) return
        actives.collapse('hide')
        hasData || actives.data('collapse', null)
      }

      this.$element[dimension](0)
      this.transition('addClass', $.Event('show'), 'shown')
      $.support.transition && this.$element[dimension](this.$element[0][scroll])
    }

  , hide: function () {
      var dimension
      if (this.transitioning || !this.$element.hasClass('in')) return
      dimension = this.dimension()
      this.reset(this.$element[dimension]())
      this.transition('removeClass', $.Event('hide'), 'hidden')
      this.$element[dimension](0)
    }

  , reset: function (size) {
      var dimension = this.dimension()

      this.$element
        .removeClass('collapse')
        [dimension](size || 'auto')
        [0].offsetWidth

      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse')

      return this
    }

  , transition: function (method, startEvent, completeEvent) {
      var that = this
        , complete = function () {
            if (startEvent.type == 'show') that.reset()
            that.transitioning = 0
            that.$element.trigger(completeEvent)
          }

      this.$element.trigger(startEvent)

      if (startEvent.isDefaultPrevented()) return

      this.transitioning = 1

      this.$element[method]('in')

      $.support.transition && this.$element.hasClass('collapse') ?
        this.$element.one($.support.transition.end, complete) :
        complete()
    }

  , toggle: function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']()
    }

  }


 /* COLLAPSE PLUGIN DEFINITION
  * ========================== */

  var old = $.fn.collapse

  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('collapse')
        , options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.collapse.defaults = {
    toggle: true
  }

  $.fn.collapse.Constructor = Collapse


 /* COLLAPSE NO CONFLICT
  * ==================== */

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


 /* COLLAPSE DATA-API
  * ================= */

  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this = $(this), href
      , target = $this.attr('data-target')
        || e.preventDefault()
        || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
      , option = $(target).data('collapse') ? 'toggle' : $this.data()
    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
    $(target).collapse(option)
  })

}(window.jQuery);
/**
 * AngularStrap - Twitter Bootstrap directives for AngularJS
 * @version v0.7.7 - 2013-10-04
 * @link http://mgcrea.github.com/angular-strap
 * @author Olivier Louvignes <olivier@mg-crea.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

(function (window, document, undefined) {
  'use strict';
  angular.module('$strap.config', []).value('$strapConfig', {});
  angular.module('$strap.filters', ['$strap.config']);
  angular.module('$strap.directives', ['$strap.config']);
  angular.module('$strap', [
    '$strap.filters',
    '$strap.directives',
    '$strap.config'
  ]);
  angular.module('$strap.directives').directive('bsAlert', [
    '$parse',
    '$timeout',
    '$compile',
    function ($parse, $timeout, $compile) {
      return {
        restrict: 'A',
        link: function postLink(scope, element, attrs) {
          var getter = $parse(attrs.bsAlert), setter = getter.assign, value = getter(scope);
          var closeAlert = function closeAlertFn(delay) {
            $timeout(function () {
              element.alert('close');
            }, delay * 1);
          };
          if (!attrs.bsAlert) {
            if (angular.isUndefined(attrs.closeButton) || attrs.closeButton !== '0' && attrs.closeButton !== 'false') {
              element.prepend('<button type="button" class="close" data-dismiss="alert">&times;</button>');
            }
            if (attrs.closeAfter)
              closeAlert(attrs.closeAfter);
          } else {
            scope.$watch(attrs.bsAlert, function (newValue, oldValue) {
              value = newValue;
              element.html((newValue.title ? '<strong>' + newValue.title + '</strong>&nbsp;' : '') + newValue.content || '');
              if (!!newValue.closed) {
                element.hide();
              }
              $compile(element.contents())(scope);
              if (newValue.type || oldValue.type) {
                oldValue.type && element.removeClass('alert-' + oldValue.type);
                newValue.type && element.addClass('alert-' + newValue.type);
              }
              if (angular.isDefined(newValue.closeAfter))
                closeAlert(newValue.closeAfter);
              else if (attrs.closeAfter)
                closeAlert(attrs.closeAfter);
              if (angular.isUndefined(attrs.closeButton) || attrs.closeButton !== '0' && attrs.closeButton !== 'false') {
                element.prepend('<button type="button" class="close" data-dismiss="alert">&times;</button>');
              }
            }, true);
          }
          element.addClass('alert').alert();
          if (element.hasClass('fade')) {
            element.removeClass('in');
            setTimeout(function () {
              element.addClass('in');
            });
          }
          var parentArray = attrs.ngRepeat && attrs.ngRepeat.split(' in ').pop();
          element.on('close', function (ev) {
            var removeElement;
            if (parentArray) {
              ev.preventDefault();
              element.removeClass('in');
              removeElement = function () {
                element.trigger('closed');
                if (scope.$parent) {
                  scope.$parent.$apply(function () {
                    var path = parentArray.split('.');
                    var curr = scope.$parent;
                    for (var i = 0; i < path.length; ++i) {
                      if (curr) {
                        curr = curr[path[i]];
                      }
                    }
                    if (curr) {
                      curr.splice(scope.$index, 1);
                    }
                  });
                }
              };
              $.support.transition && element.hasClass('fade') ? element.on($.support.transition.end, removeElement) : removeElement();
            } else if (value) {
              ev.preventDefault();
              element.removeClass('in');
              removeElement = function () {
                element.trigger('closed');
                scope.$apply(function () {
                  value.closed = true;
                });
              };
              $.support.transition && element.hasClass('fade') ? element.on($.support.transition.end, removeElement) : removeElement();
            } else {
            }
          });
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsButton', [
    '$parse',
    '$timeout',
    function ($parse, $timeout) {
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function postLink(scope, element, attrs, controller) {
          if (controller) {
            if (!element.parent('[data-toggle="buttons-checkbox"], [data-toggle="buttons-radio"]').length) {
              element.attr('data-toggle', 'button');
            }
            var startValue = !!scope.$eval(attrs.ngModel);
            if (startValue) {
              element.addClass('active');
            }
            scope.$watch(attrs.ngModel, function (newValue, oldValue) {
              var bNew = !!newValue, bOld = !!oldValue;
              if (bNew !== bOld) {
                $.fn.button.Constructor.prototype.toggle.call(button);
              } else if (bNew && !startValue) {
                element.addClass('active');
              }
            });
          }
          if (!element.hasClass('btn')) {
            element.on('click.button.data-api', function (ev) {
              element.button('toggle');
            });
          }
          element.button();
          var button = element.data('button');
          button.toggle = function () {
            if (!controller) {
              return $.fn.button.Constructor.prototype.toggle.call(this);
            }
            var $parent = element.parent('[data-toggle="buttons-radio"]');
            if ($parent.length) {
              element.siblings('[ng-model]').each(function (k, v) {
                $parse($(v).attr('ng-model')).assign(scope, false);
              });
              scope.$digest();
              if (!controller.$modelValue) {
                controller.$setViewValue(!controller.$modelValue);
                scope.$digest();
              }
            } else {
              scope.$apply(function () {
                controller.$setViewValue(!controller.$modelValue);
              });
            }
          };
        }
      };
    }
  ]).directive('bsButtonsCheckbox', [
    '$parse',
    function ($parse) {
      return {
        restrict: 'A',
        require: '?ngModel',
        compile: function compile(tElement, tAttrs, transclude) {
          tElement.attr('data-toggle', 'buttons-checkbox').find('a, button').each(function (k, v) {
            $(v).attr('bs-button', '');
          });
        }
      };
    }
  ]).directive('bsButtonsRadio', [
    '$timeout',
    function ($timeout) {
      return {
        restrict: 'A',
        require: '?ngModel',
        compile: function compile(tElement, tAttrs, transclude) {
          tElement.attr('data-toggle', 'buttons-radio');
          if (!tAttrs.ngModel) {
            tElement.find('a, button').each(function (k, v) {
              $(v).attr('bs-button', '');
            });
          }
          return function postLink(scope, iElement, iAttrs, controller) {
            if (controller) {
              $timeout(function () {
                iElement.find('[value]').button().filter('[value="' + controller.$viewValue + '"]').addClass('active');
              });
              iElement.on('click.button.data-api', function (ev) {
                scope.$apply(function () {
                  controller.$setViewValue($(ev.target).closest('button').attr('value'));
                });
              });
              scope.$watch(iAttrs.ngModel, function (newValue, oldValue) {
                if (newValue !== oldValue) {
                  var $btn = iElement.find('[value="' + scope.$eval(iAttrs.ngModel) + '"]');
                  if ($btn.length) {
                    $btn.button('toggle');
                  }
                }
              });
            }
          };
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsButtonSelect', [
    '$parse',
    '$timeout',
    function ($parse, $timeout) {
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function postLink(scope, element, attrs, ctrl) {
          var getter = $parse(attrs.bsButtonSelect), setter = getter.assign;
          if (ctrl) {
            element.text(scope.$eval(attrs.ngModel));
            scope.$watch(attrs.ngModel, function (newValue, oldValue) {
              element.text(newValue);
            });
          }
          var values, value, index, newValue;
          element.bind('click', function (ev) {
            values = getter(scope);
            value = ctrl ? scope.$eval(attrs.ngModel) : element.text();
            index = values.indexOf(value);
            newValue = index > values.length - 2 ? values[0] : values[index + 1];
            scope.$apply(function () {
              element.text(newValue);
              if (ctrl) {
                ctrl.$setViewValue(newValue);
              }
            });
          });
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsDatepicker', [
    '$timeout',
    '$strapConfig',
    function ($timeout, $strapConfig) {
      var isAppleTouch = /(iP(a|o)d|iPhone)/g.test(navigator.userAgent);
      var regexpMap = function regexpMapFn(language) {
        if (!($.fn.datepicker.dates[language] && language)) {
          language = 'en';
        }
        return {
          '/': '[\\/]',
          '-': '[-]',
          '.': '[.]',
          ' ': '[\\s]',
          'dd': '(?:(?:[0-2]?[0-9]{1})|(?:[3][01]{1}))',
          'd': '(?:(?:[0-2]?[0-9]{1})|(?:[3][01]{1}))',
          'mm': '(?:[0]?[1-9]|[1][012])',
          'm': '(?:[0]?[1-9]|[1][012])',
          'DD': '(?:' + $.fn.datepicker.dates[language].days.join('|') + ')',
          'D': '(?:' + $.fn.datepicker.dates[language].daysShort.join('|') + ')',
          'MM': '(?:' + $.fn.datepicker.dates[language].months.join('|') + ')',
          'M': '(?:' + $.fn.datepicker.dates[language].monthsShort.join('|') + ')',
          'yyyy': '(?:(?:[1]{1}[0-9]{1}[0-9]{1}[0-9]{1})|(?:[2]{1}[0-9]{3}))(?![[0-9]])',
          'yy': '(?:(?:[0-9]{1}[0-9]{1}))(?![[0-9]])'
        };
      };
      var regexpForDateFormat = function regexpForDateFormatFn(format, language) {
        var re = format, map = regexpMap(language), i;
        i = 0;
        angular.forEach(map, function (v, k) {
          re = re.split(k).join('${' + i + '}');
          i++;
        });
        i = 0;
        angular.forEach(map, function (v, k) {
          re = re.split('${' + i + '}').join(v);
          i++;
        });
        return new RegExp('^' + re + '$', ['i']);
      };
      var ISODateRegexp = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function postLink(scope, element, attrs, controller) {
          var options = angular.extend({ autoclose: true }, $strapConfig.datepicker || {});
          var type = attrs.dateType || options.type || 'date';
          var getFormattedModelValue = function (modelValue, format, language) {
            if (modelValue && type === 'iso' && ISODateRegexp.test(modelValue)) {
              return $.fn.datepicker.DPGlobal.parseDate(new Date(modelValue), $.fn.datepicker.DPGlobal.parseFormat(format), language);
            } else if (modelValue && type === 'date' && angular.isString(modelValue)) {
              return $.fn.datepicker.DPGlobal.parseDate(modelValue, $.fn.datepicker.DPGlobal.parseFormat(format), language);
            } else {
              return modelValue;
            }
          };
          var init = function () {
            options = angular.extend({ autoclose: true }, $strapConfig.datepicker || {});
            type = attrs.dateType || options.type || 'date';
            angular.forEach([
              'format',
              'weekStart',
              'calendarWeeks',
              'startDate',
              'endDate',
              'daysOfWeekDisabled',
              'autoclose',
              'startView',
              'minViewMode',
              'todayBtn',
              'todayHighlight',
              'keyboardNavigation',
              'language',
              'forceParse'
            ], function (key) {
              if (angular.isDefined(attrs[key]))
                options[key] = attrs[key];
            });
            var language = options.language || 'en', readFormat = attrs.dateFormat || options.format || $.fn.datepicker.dates[language] && $.fn.datepicker.dates[language].format || 'mm/dd/yyyy', format = isAppleTouch ? 'yyyy-mm-dd' : readFormat, dateFormatRegexp = regexpForDateFormat(format, language);
            if (controller) {
              controller.$formatters.unshift(function (modelValue) {
                return getFormattedModelValue(modelValue, readFormat, language);
              });
              controller.$parsers.unshift(function (viewValue) {
                if (!viewValue) {
                  controller.$setValidity('date', true);
                  return null;
                } else if ((type === 'date' || type === 'iso') && angular.isDate(viewValue)) {
                  controller.$setValidity('date', true);
                  return viewValue;
                } else if (angular.isString(viewValue) && dateFormatRegexp.test(viewValue)) {
                  controller.$setValidity('date', true);
                  if (isAppleTouch)
                    return new Date(viewValue);
                  return type === 'string' ? viewValue : $.fn.datepicker.DPGlobal.parseDate(viewValue, $.fn.datepicker.DPGlobal.parseFormat(format), language);
                } else {
                  controller.$setValidity('date', false);
                  return undefined;
                }
              });
              controller.$render = function ngModelRender() {
                if (isAppleTouch) {
                  var date = controller.$viewValue ? $.fn.datepicker.DPGlobal.formatDate(controller.$viewValue, $.fn.datepicker.DPGlobal.parseFormat(format), language) : '';
                  element.val(date);
                  return date;
                }
                if (!controller.$viewValue)
                  element.val('');
                return element.datepicker('update', controller.$viewValue);
              };
            }
            if (isAppleTouch) {
              element.prop('type', 'date').css('-webkit-appearance', 'textfield');
            } else {
              if (controller) {
                element.on('changeDate', function (ev) {
                  scope.$apply(function () {
                    controller.$setViewValue(type === 'string' ? element.val() : ev.date);
                  });
                });
              }
              element.datepicker(angular.extend(options, {
                format: format,
                language: language
              }));
              scope.$on('$destroy', function () {
                var datepicker = element.data('datepicker');
                if (datepicker) {
                  datepicker.picker.remove();
                  element.data('datepicker', null);
                }
              });
              attrs.$observe('startDate', function (value) {
                element.datepicker('setStartDate', value);
              });
              attrs.$observe('endDate', function (value) {
                element.datepicker('setEndDate', value);
              });
            }
            var component = element.siblings('[data-toggle="datepicker"]');
            if (component.length) {
              component.on('click', function () {
                if (!element.prop('disabled')) {
                  element.trigger('focus');
                }
              });
            }
          };
          init();
          scope.$watch(function () {
            return attrs.language;
          }, function (newValue, oldValue) {
            if (newValue !== oldValue) {
              var oldLanguage = $.fn.datepicker.dates[oldValue] ? oldValue : 'en';
              var oldFormat = attrs.dateFormat || options.format || $.fn.datepicker.dates[oldLanguage] && $.fn.datepicker.dates[oldLanguage].format || 'mm/dd/yyyy';
              var oldDate = $.fn.datepicker.DPGlobal.parseDate(element.val(), $.fn.datepicker.DPGlobal.parseFormat(oldFormat), oldLanguage);
              var newLanguage = $.fn.datepicker.dates[newValue] ? newValue : 'en';
              var newFormat = $.fn.datepicker.dates[newLanguage] && $.fn.datepicker.dates[newLanguage].format || 'mm/dd/yyyy';
              var newDateString = $.fn.datepicker.DPGlobal.formatDate(oldDate, $.fn.datepicker.DPGlobal.parseFormat(newFormat), newLanguage);
              element.datepicker('remove');
              element.val('');
              init();
              var mValue = getFormattedModelValue(newDateString, newFormat, newLanguage);
              controller.$modelValue = mValue;
              controller.$viewValue = newDateString;
            }
          });
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsDropdown', [
    '$parse',
    '$compile',
    '$timeout',
    function ($parse, $compile, $timeout) {
      var buildTemplate = function (items, ul) {
        if (!ul)
          ul = [
            '<ul class="dropdown-menu" role="menu" aria-labelledby="drop1">',
            '</ul>'
          ];
        angular.forEach(items, function (item, index) {
          if (item.divider)
            return ul.splice(index + 1, 0, '<li class="divider"></li>');
          var li = '<li' + (item.submenu && item.submenu.length ? ' class="dropdown-submenu"' : '') + '>' + '<a tabindex="-1" ng-href="' + (item.href || '') + '"' + (item.click ? '" ng-click="' + item.click + '"' : '') + (item.target ? '" target="' + item.target + '"' : '') + (item.method ? '" data-method="' + item.method + '"' : '') + '>' + (item.icon && '<i class="' + item.icon + '"></i>&nbsp;' || '') + (item.text || '') + '</a>';
          if (item.submenu && item.submenu.length)
            li += buildTemplate(item.submenu).join('\n');
          li += '</li>';
          ul.splice(index + 1, 0, li);
        });
        return ul;
      };
      return {
        restrict: 'EA',
        scope: true,
        link: function postLink(scope, iElement, iAttrs) {
          var getter = $parse(iAttrs.bsDropdown), items = getter(scope);
          $timeout(function () {
            if (!angular.isArray(items)) {
            }
            var dropdown = angular.element(buildTemplate(items).join(''));
            dropdown.insertAfter(iElement);
            $compile(iElement.next('ul.dropdown-menu'))(scope);
          });
          iElement.addClass('dropdown-toggle').attr('data-toggle', 'dropdown');
        }
      };
    }
  ]);
  angular.module('$strap.directives').factory('$modal', [
    '$rootScope',
    '$compile',
    '$http',
    '$timeout',
    '$q',
    '$templateCache',
    '$strapConfig',
    function ($rootScope, $compile, $http, $timeout, $q, $templateCache, $strapConfig) {
      var ModalFactory = function ModalFactoryFn(config) {
        function Modal(config) {
          var options = angular.extend({ show: true }, $strapConfig.modal, config), scope = options.scope ? options.scope : $rootScope.$new(), templateUrl = options.template;
          return $q.when($templateCache.get(templateUrl) || $http.get(templateUrl, { cache: true }).then(function (res) {
            return res.data;
          })).then(function onSuccess(template) {
            var id = templateUrl.replace('.html', '').replace(/[\/|\.|:]/g, '-') + '-' + scope.$id;
            var $modal = $('<div class="modal hide" tabindex="-1"></div>').attr('id', id).addClass('fade').html(template);
            if (options.modalClass)
              $modal.addClass(options.modalClass);
            $('body').append($modal);
            $timeout(function () {
              $compile($modal)(scope);
            });
            scope.$modal = function (name) {
              $modal.modal(name);
            };
            angular.forEach([
              'show',
              'hide'
            ], function (name) {
              scope[name] = function () {
                $modal.modal(name);
              };
            });
            scope.dismiss = scope.hide;
            angular.forEach([
              'show',
              'shown',
              'hide',
              'hidden'
            ], function (name) {
              $modal.on(name, function (ev) {
                scope.$emit('modal-' + name, ev);
              });
            });
            $modal.on('shown', function (ev) {
              $('input[autofocus], textarea[autofocus]', $modal).first().trigger('focus');
            });
            $modal.on('hidden', function (ev) {
              if (!options.persist)
                scope.$destroy();
            });
            scope.$on('$destroy', function () {
              $modal.remove();
            });
            $modal.modal(options);
            return $modal;
          });
        }
        return new Modal(config);
      };
      return ModalFactory;
    }
  ]).directive('bsModal', [
    '$q',
    '$modal',
    function ($q, $modal) {
      return {
        restrict: 'A',
        scope: true,
        link: function postLink(scope, iElement, iAttrs, controller) {
          var options = {
              template: scope.$eval(iAttrs.bsModal),
              persist: true,
              show: false,
              scope: scope
            };
          angular.forEach([
            'modalClass',
            'backdrop',
            'keyboard'
          ], function (key) {
            if (angular.isDefined(iAttrs[key]))
              options[key] = iAttrs[key];
          });
          $q.when($modal(options)).then(function onSuccess(modal) {
            iElement.attr('data-target', '#' + modal.attr('id')).attr('data-toggle', 'modal');
          });
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsNavbar', [
    '$location',
    function ($location) {
      return {
        restrict: 'A',
        link: function postLink(scope, element, attrs, controller) {
          scope.$watch(function () {
            return $location.path();
          }, function (newValue, oldValue) {
            $('li[data-match-route]', element).each(function (k, li) {
              var $li = angular.element(li), pattern = $li.attr('data-match-route'), regexp = new RegExp('^' + pattern + '$', ['i']);
              if (regexp.test(newValue)) {
                $li.addClass('active');
                var $collapse = $li.find('.collapse.in');
                if ($collapse.length)
                  $collapse.collapse('hide');
              } else {
                $li.removeClass('active');
              }
            });
          });
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsPopover', [
    '$parse',
    '$compile',
    '$http',
    '$timeout',
    '$q',
    '$templateCache',
    function ($parse, $compile, $http, $timeout, $q, $templateCache) {
      $('body').on('keyup', function (ev) {
        if (ev.keyCode === 27) {
          $('.popover.in').popover('hide');
        }
      });
      return {
        restrict: 'A',
        scope: true,
        link: function postLink(scope, element, attr, ctrl) {
          var getter = $parse(attr.bsPopover), setter = getter.assign, value = getter(scope), options = {};
          if (angular.isObject(value)) {
            options = value;
          }
          $q.when(options.content || $templateCache.get(value) || $http.get(value, { cache: true })).then(function onSuccess(template) {
            if (angular.isObject(template)) {
              template = template.data;
            }
            angular.forEach([
              'placement',
              'trigger'
            ], function (name) {
              if (!!attr[name]) {
                options[name] = attr[name];
              }
            });
            if (!!attr.unique) {
              element.on('show', function (ev) {
                $('.popover.in').not(element).popover('hide');
              });
            }
            if (!!attr.hide) {
              scope.$watch(attr.hide, function (newValue, oldValue) {
                if (!!newValue) {
                  popover.hide();
                } else if (newValue !== oldValue) {
                  $timeout(function () {
                    popover.show();
                  });
                }
              });
            }
            if (!!attr.show) {
              scope.$watch(attr.show, function (newValue, oldValue) {
                if (!!newValue) {
                  $timeout(function () {
                    popover.show();
                  });
                } else if (newValue !== oldValue) {
                  popover.hide();
                }
              });
            }
            element.popover(angular.extend({}, options, {
              content: template,
              html: true
            }));
            var popover = element.data('popover');
            popover.hasContent = function () {
              return this.getTitle() || template;
            };
            popover.getPosition = function () {
              var r = $.fn.popover.Constructor.prototype.getPosition.apply(this, arguments);
              $compile(this.$tip)(scope);
              scope.$digest();
              this.$tip.data('popover', this);
              return r;
            };
            scope.$popover = function (name) {
              popover(name);
            };
            angular.forEach([
              'show',
              'hide'
            ], function (name) {
              scope[name] = function () {
                popover[name]();
              };
            });
            scope.dismiss = scope.hide;
            angular.forEach([
              'show',
              'shown',
              'hide',
              'hidden'
            ], function (name) {
              element.on(name, function (ev) {
                scope.$emit('popover-' + name, ev);
              });
            });
          });
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsSelect', [
    '$timeout',
    function ($timeout) {
      var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/;
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function postLink(scope, element, attrs, controller) {
          var options = scope.$eval(attrs.bsSelect) || {};
          $timeout(function () {
            element.selectpicker(options);
            element.next().removeClass('ng-scope');
          });
          if (controller) {
            var refresh = function (newValue, oldValue) {
              if (!angular.equals(newValue, oldValue)) {
                element.selectpicker('refresh');
              }
            };
            scope.$watch(attrs.ngModel, function (newValue, oldValue) {
              refresh(newValue, oldValue);
            });
            if (attrs.ngOptions) {
              var match = attrs.ngOptions.match(NG_OPTIONS_REGEXP);
              if (match && scope[match[7]]) {
                scope.$watch(function () {
                  return scope[match[7]];
                }, function (newValue, oldValue) {
                  if (!angular.equals(newValue, oldValue)) {
                    refresh(newValue, oldValue);
                  }
                }, true);
              }
            }
          }
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsTabs', [
    '$parse',
    '$compile',
    '$timeout',
    function ($parse, $compile, $timeout) {
      var template = '<div class="tabs">' + '<ul class="nav nav-tabs">' + '<li ng-repeat="pane in panes" ng-class="{active:pane.active}">' + '<a data-target="#{{pane.id}}" data-index="{{$index}}" data-toggle="tab">{{pane.title}}</a>' + '</li>' + '</ul>' + '<div class="tab-content" ng-transclude>' + '</div>';
      return {
        restrict: 'A',
        require: '?ngModel',
        priority: 0,
        scope: true,
        template: template,
        replace: true,
        transclude: true,
        compile: function compile(tElement, tAttrs, transclude) {
          return function postLink(scope, iElement, iAttrs, controller) {
            var getter = $parse(iAttrs.bsTabs), setter = getter.assign, value = getter(scope);
            scope.panes = [];
            var $tabs = iElement.find('ul.nav-tabs');
            var $panes = iElement.find('div.tab-content');
            var activeTab = 0, id, title, active;
            $timeout(function () {
              $panes.find('[data-title], [data-tab]').each(function (index) {
                var $this = angular.element(this);
                id = 'tab-' + scope.$id + '-' + index;
                title = $this.data('title') || $this.data('tab');
                active = !active && $this.hasClass('active');
                $this.attr('id', id).addClass('tab-pane');
                if (iAttrs.fade)
                  $this.addClass('fade');
                scope.panes.push({
                  id: id,
                  title: title,
                  content: this.innerHTML,
                  active: active
                });
              });
              if (scope.panes.length && !active) {
                $panes.find('.tab-pane:first-child').addClass('active' + (iAttrs.fade ? ' in' : ''));
                scope.panes[0].active = true;
              }
            });
            if (controller) {
              iElement.on('show', function (ev) {
                var $target = $(ev.target);
                scope.$apply(function () {
                  controller.$setViewValue($target.data('index'));
                });
              });
              scope.$watch(iAttrs.ngModel, function (newValue, oldValue) {
                if (angular.isUndefined(newValue))
                  return;
                activeTab = newValue;
                setTimeout(function () {
                  var $next = $($tabs[0].querySelectorAll('li')[newValue * 1]);
                  if (!$next.hasClass('active')) {
                    $next.children('a').tab('show');
                  }
                });
              });
            }
          };
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsTimepicker', [
    '$timeout',
    '$strapConfig',
    function ($timeout, $strapConfig) {
      var TIME_REGEXP = '((?:(?:[0-1][0-9])|(?:[2][0-3])|(?:[0-9])):(?:[0-5][0-9])(?::[0-5][0-9])?(?:\\s?(?:am|AM|pm|PM))?)';
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function postLink(scope, element, attrs, controller) {
          var pad = function (number) {
            var r = String(number);
            if (r.length === 1) {
              r = '0' + r;
            }
            return r;
          };
          var options = angular.extend({ openOnFocus: false }, $strapConfig.timepicker);
          var defaultTime = attrs.defaultTime || options.defaultTime || false;
          options.defaultTime = false;
          var type = attrs.timeType || options.timeType || 'string';
          angular.forEach([
            'template',
            'minuteStep',
            'showSeconds',
            'secondStep',
            'showMeridian',
            'showInputs',
            'disableFocus',
            'modalBackdrop',
            'openOnFocus'
          ], function (key) {
            if (angular.isDefined(attrs[key])) {
              if (attrs[key] === 'true' || attrs[key] === 'false') {
                options[key] = attrs[key] === 'true';
              } else if (/^\-?([0-9]+|Infinity)$/.test(attrs[key])) {
                options[key] = parseInt(attrs[key], 10);
              } else {
                options[key] = attrs[key];
              }
            }
          });
          if (controller) {
            element.on('changeTime.timepicker', function (ev) {
              $timeout(function () {
                if (type === 'string') {
                  controller.$setViewValue(element.val());
                } else if (type === 'date') {
                  var date = new Date();
                  date.setHours(ev.time.hours);
                  date.setMinutes(ev.time.minutes);
                  controller.$setViewValue(date);
                }
              });
            });
            var timeRegExp = new RegExp('^' + TIME_REGEXP + '$', ['i']);
            controller.$formatters.unshift(function (modelValue) {
              if (modelValue) {
                if (type === 'date') {
                  controller.$setViewValue(new Date(modelValue));
                  element.val(new Date(modelValue));
                  return new Date(modelValue);
                }
                controller.$setViewValue(modelValue);
                element.val(modelValue);
                return modelValue;
              } else if (defaultTime) {
                if (defaultTime === 'current') {
                  if (type === 'date') {
                    controller.$setViewValue(new Date());
                    element.val(new Date());
                    return new Date();
                  } else {
                    var currentDate = new Date();
                    var currentTime = pad(currentDate.getHours()) + ':' + pad(currentDate.getMinutes());
                    controller.$setViewValue(currentDate);
                    element.val(currentDate);
                    return currentDate;
                  }
                } else {
                  controller.$setViewValue(defaultTime);
                  element.val(defaultTime);
                  return defaultTime;
                }
              }
              controller.$setViewValue(element.val());
              return element.val();
            });
            controller.$render = function ngModelRender() {
              if (controller.$viewValue) {
                if (type === 'date') {
                  var renderedDate;
                  if (timeRegExp.test(controller.$viewValue)) {
                    renderedDate = new Date();
                    var dateParts = controller.$viewValue.split(':');
                    var hours = !isNaN(parseInt(dateParts[0], 10)) ? parseInt(dateParts[0], 10) : '0';
                    var minutes = !isNaN(parseInt(dateParts[1], 10)) ? parseInt(dateParts[1], 10) : '0';
                    renderedDate.setHours(hours);
                    renderedDate.setMinutes(minutes);
                    element.val(controller.$viewValue);
                    controller.$setViewValue(renderedDate);
                    return renderedDate;
                  } else {
                    renderedDate = new Date(controller.$viewValue);
                    var modelRender = renderedDate !== 'Invalid Date' ? pad(renderedDate.getHours()) + ':' + pad(renderedDate.getMinutes()) : '';
                    element.val(modelRender);
                    controller.$setViewValue(renderedDate);
                    return renderedDate;
                  }
                }
                element.val(controller.$viewValue);
                controller.$setViewValue(controller.$viewValue);
                return controller.$viewValue;
              }
              element.val('');
              return '';
            };
            controller.$parsers.unshift(function (viewValue) {
              if (!viewValue || type === 'string' && timeRegExp.test(viewValue)) {
                controller.$setValidity('time', true);
                return viewValue;
              } else if (type === 'date' && typeof viewValue === 'object' && viewValue.toString() !== 'Invalid Date') {
                controller.$setValidity('time', true);
                return viewValue;
              } else {
                controller.$setValidity('time', false);
                return;
              }
            });
          }
          element.attr('data-toggle', 'timepicker');
          element.parent().addClass('bootstrap-timepicker');
          element.timepicker(options || {});
          var timepicker = element.data('timepicker');
          var component = element.siblings('[data-toggle="timepicker"]');
          if (component.length) {
            component.on('click', $.proxy(timepicker.showWidget, timepicker));
          }
          if (options.openOnFocus) {
            element.on('focus', $.proxy(timepicker.showWidget, timepicker));
          }
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsTooltip', [
    '$parse',
    '$compile',
    function ($parse, $compile) {
      return {
        restrict: 'A',
        scope: true,
        link: function postLink(scope, element, attrs, ctrl) {
          var getter = $parse(attrs.bsTooltip), setter = getter.assign, value = getter(scope);
          scope.$watch(attrs.bsTooltip, function (newValue, oldValue) {
            value = newValue;
          });
          if (!!attrs.unique) {
            element.on('show', function (ev) {
              $('.tooltip.in').each(function () {
                var $this = $(this), tooltip = $this.data('tooltip');
                if (tooltip && !tooltip.$element.is(element)) {
                  $this.tooltip('hide');
                }
              });
            });
          }
          element.tooltip({
            title: function () {
              return angular.isFunction(value) ? value.apply(null, arguments) : value;
            },
            html: true
          });
          var tooltip = element.data('tooltip');
          tooltip.show = function () {
            var r = $.fn.tooltip.Constructor.prototype.show.apply(this, arguments);
            this.tip().data('tooltip', this);
            return r;
          };
          scope._tooltip = function (event) {
            element.tooltip(event);
          };
          scope.hide = function () {
            element.tooltip('hide');
          };
          scope.show = function () {
            element.tooltip('show');
          };
          scope.dismiss = scope.hide;
        }
      };
    }
  ]);
  angular.module('$strap.directives').directive('bsTypeahead', [
    '$parse',
    function ($parse) {
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function postLink(scope, element, attrs, controller) {
          var getter = $parse(attrs.bsTypeahead), setter = getter.assign, value = getter(scope);
          scope.$watch(attrs.bsTypeahead, function (newValue, oldValue) {
            if (newValue !== oldValue) {
              value = newValue;
            }
          });
          element.attr('data-provide', 'typeahead');
          element.typeahead({
            source: function (query) {
              return angular.isFunction(value) ? value.apply(null, arguments) : value;
            },
            minLength: attrs.minLength || 1,
            items: attrs.items,
            updater: function (value) {
              if (controller) {
                scope.$apply(function () {
                  controller.$setViewValue(value);
                });
              }
              scope.$emit('typeahead-updated', value, attrs.id);
              return value;
            }
          });
          var typeahead = element.data('typeahead');
          typeahead.lookup = function (ev) {
            var items;
            this.query = this.$element.val() || '';
            if (this.query.length < this.options.minLength) {
              return this.shown ? this.hide() : this;
            }
            items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source;
            return items ? this.process(items) : this;
          };
          if (!!attrs.matchAll) {
            typeahead.matcher = function (item) {
              return true;
            };
          }
          if (attrs.minLength === '0') {
            setTimeout(function () {
              element.on('focus', function () {
                element.val().length === 0 && setTimeout(element.typeahead.bind(element, 'lookup'), 200);
              });
            });
          }
        }
      };
    }
  ]);
}(window, document));
/*! gridster.js - v0.2.0 - 2013-10-26
* http://gridster.net/
* Copyright (c) 2013 ducksboard; Licensed MIT */

;(function($, window, document, undefined){
    /**
    * Creates objects with coordinates (x1, y1, x2, y2, cx, cy, width, height)
    * to simulate DOM elements on the screen.
    * Coords is used by Gridster to create a faux grid with any DOM element can
    * collide.
    *
    * @class Coords
    * @param {HTMLElement|Object} obj The jQuery HTMLElement or a object with: left,
    * top, width and height properties.
    * @return {Object} Coords instance.
    * @constructor
    */
    function Coords(obj) {
        if (obj[0] && $.isPlainObject(obj[0])) {
            this.data = obj[0];
        }else {
            this.el = obj;
        }

        this.isCoords = true;
        this.coords = {};
        this.init();
        return this;
    }


    var fn = Coords.prototype;


    fn.init = function(){
        this.set();
        this.original_coords = this.get();
    };


    fn.set = function(update, not_update_offsets) {
        var el = this.el;

        if (el && !update) {
            this.data = el.offset();
            this.data.width = el.width();
            this.data.height = el.height();
        }

        if (el && update && !not_update_offsets) {
            var offset = el.offset();
            this.data.top = offset.top;
            this.data.left = offset.left;
        }

        var d = this.data;

        this.coords.x1 = d.left;
        this.coords.y1 = d.top;
        this.coords.x2 = d.left + d.width;
        this.coords.y2 = d.top + d.height;
        this.coords.cx = d.left + (d.width / 2);
        this.coords.cy = d.top + (d.height / 2);
        this.coords.width  = d.width;
        this.coords.height = d.height;
        this.coords.el  = el || false ;

        return this;
    };


    fn.update = function(data){
        if (!data && !this.el) {
            return this;
        }

        if (data) {
            var new_data = $.extend({}, this.data, data);
            this.data = new_data;
            return this.set(true, true);
        }

        this.set(true);
        return this;
    };


    fn.get = function(){
        return this.coords;
    };


    //jQuery adapter
    $.fn.coords = function() {
        if (this.data('coords') ) {
            return this.data('coords');
        }

        var ins = new Coords(this, arguments[0]);
        this.data('coords', ins);
        return ins;
    };

}(jQuery, window, document));

;(function($, window, document, undefined){

    var defaults = {
        colliders_context: document.body
        // ,on_overlap: function(collider_data){},
        // on_overlap_start : function(collider_data){},
        // on_overlap_stop : function(collider_data){}
    };


    /**
    * Detects collisions between a DOM element against other DOM elements or
    * Coords objects.
    *
    * @class Collision
    * @uses Coords
    * @param {HTMLElement} el The jQuery wrapped HTMLElement.
    * @param {HTMLElement|Array} colliders Can be a jQuery collection
    *  of HTMLElements or an Array of Coords instances.
    * @param {Object} [options] An Object with all options you want to
    *        overwrite:
    *   @param {Function} [options.on_overlap_start] Executes a function the first
    *    time each `collider ` is overlapped.
    *   @param {Function} [options.on_overlap_stop] Executes a function when a
    *    `collider` is no longer collided.
    *   @param {Function} [options.on_overlap] Executes a function when the
    * mouse is moved during the collision.
    * @return {Object} Collision instance.
    * @constructor
    */
    function Collision(el, colliders, options) {
        this.options = $.extend(defaults, options);
        this.$element = el;
        this.last_colliders = [];
        this.last_colliders_coords = [];
        if (typeof colliders === 'string' || colliders instanceof jQuery) {
            this.$colliders = $(colliders,
                 this.options.colliders_context).not(this.$element);
        }else{
            this.colliders = $(colliders);
        }

        this.init();
    }


    var fn = Collision.prototype;


    fn.init = function() {
        this.find_collisions();
    };


    fn.overlaps = function(a, b) {
        var x = false;
        var y = false;

        if ((b.x1 >= a.x1 && b.x1 <= a.x2) ||
            (b.x2 >= a.x1 && b.x2 <= a.x2) ||
            (a.x1 >= b.x1 && a.x2 <= b.x2)
        ) { x = true; }

        if ((b.y1 >= a.y1 && b.y1 <= a.y2) ||
            (b.y2 >= a.y1 && b.y2 <= a.y2) ||
            (a.y1 >= b.y1 && a.y2 <= b.y2)
        ) { y = true; }

        return (x && y);
    };


    fn.detect_overlapping_region = function(a, b){
        var regionX = '';
        var regionY = '';

        if (a.y1 > b.cy && a.y1 < b.y2) { regionX = 'N'; }
        if (a.y2 > b.y1 && a.y2 < b.cy) { regionX = 'S'; }
        if (a.x1 > b.cx && a.x1 < b.x2) { regionY = 'W'; }
        if (a.x2 > b.x1 && a.x2 < b.cx) { regionY = 'E'; }

        return (regionX + regionY) || 'C';
    };


    fn.calculate_overlapped_area_coords = function(a, b){
        var x1 = Math.max(a.x1, b.x1);
        var y1 = Math.max(a.y1, b.y1);
        var x2 = Math.min(a.x2, b.x2);
        var y2 = Math.min(a.y2, b.y2);

        return $({
            left: x1,
            top: y1,
             width : (x2 - x1),
            height: (y2 - y1)
          }).coords().get();
    };


    fn.calculate_overlapped_area = function(coords){
        return (coords.width * coords.height);
    };


    fn.manage_colliders_start_stop = function(new_colliders_coords, start_callback, stop_callback){
        var last = this.last_colliders_coords;

        for (var i = 0, il = last.length; i < il; i++) {
            if ($.inArray(last[i], new_colliders_coords) === -1) {
                start_callback.call(this, last[i]);
            }
        }

        for (var j = 0, jl = new_colliders_coords.length; j < jl; j++) {
            if ($.inArray(new_colliders_coords[j], last) === -1) {
                stop_callback.call(this, new_colliders_coords[j]);
            }

        }
    };


    fn.find_collisions = function(player_data_coords){
        var self = this;
        var colliders_coords = [];
        var colliders_data = [];
        var $colliders = (this.colliders || this.$colliders);
        var count = $colliders.length;
        var player_coords = self.$element.coords()
                             .update(player_data_coords || false).get();

        while(count--){
          var $collider = self.$colliders ?
                           $($colliders[count]) : $colliders[count];
          var $collider_coords_ins = ($collider.isCoords) ?
                  $collider : $collider.coords();
          var collider_coords = $collider_coords_ins.get();
          var overlaps = self.overlaps(player_coords, collider_coords);

          if (!overlaps) {
            continue;
          }

          var region = self.detect_overlapping_region(
              player_coords, collider_coords);

            //todo: make this an option
            if (region === 'C'){
                var area_coords = self.calculate_overlapped_area_coords(
                    player_coords, collider_coords);
                var area = self.calculate_overlapped_area(area_coords);
                var collider_data = {
                    area: area,
                    area_coords : area_coords,
                    region: region,
                    coords: collider_coords,
                    player_coords: player_coords,
                    el: $collider
                };

                if (self.options.on_overlap) {
                    self.options.on_overlap.call(this, collider_data);
                }
                colliders_coords.push($collider_coords_ins);
                colliders_data.push(collider_data);
            }
        }

        if (self.options.on_overlap_stop || self.options.on_overlap_start) {
            this.manage_colliders_start_stop(colliders_coords,
                self.options.on_overlap_start, self.options.on_overlap_stop);
        }

        this.last_colliders_coords = colliders_coords;

        return colliders_data;
    };


    fn.get_closest_colliders = function(player_data_coords){
        var colliders = this.find_collisions(player_data_coords);

        colliders.sort(function(a, b) {
            /* if colliders are being overlapped by the "C" (center) region,
             * we have to set a lower index in the array to which they are placed
             * above in the grid. */
            if (a.region === 'C' && b.region === 'C') {
                if (a.coords.y1 < b.coords.y1 || a.coords.x1 < b.coords.x1) {
                    return - 1;
                }else{
                    return 1;
                }
            }

            if (a.area < b.area) {
                return 1;
            }

            return 1;
        });
        return colliders;
    };


    //jQuery adapter
    $.fn.collision = function(collider, options) {
          return new Collision( this, collider, options );
    };


}(jQuery, window, document));

;(function(window, undefined) {


    window.delay = function(func, wait) {
        var args = Array.prototype.slice.call(arguments, 2);
        return setTimeout(function(){ return func.apply(null, args); }, wait);
    };


    /* Debounce and throttle functions taken from underscore.js */
    window.debounce = function(func, wait, immediate) {
        var timeout;
        return function() {
          var context = this, args = arguments;
          var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
          };
          if (immediate && !timeout) func.apply(context, args);
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
    };


    window.throttle = function(func, wait) {
        var context, args, timeout, throttling, more, result;
        var whenDone = debounce(
            function(){ more = throttling = false; }, wait);
        return function() {
          context = this; args = arguments;
          var later = function() {
            timeout = null;
            if (more) func.apply(context, args);
            whenDone();
          };
          if (!timeout) timeout = setTimeout(later, wait);
          if (throttling) {
            more = true;
          } else {
            result = func.apply(context, args);
          }
          whenDone();
          throttling = true;
          return result;
        };
    };

})(window);

;(function($, window, document, undefined) {

    var defaults = {
        items: 'li',
        distance: 1,
        limit: true,
        offset_left: 0,
        autoscroll: true,
        ignore_dragging: ['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON'],
        handle: null,
        container_width: 0,  // 0 == auto
        move_element: true,
        helper: false  // or 'clone'
        // drag: function(e) {},
        // start : function(e, ui) {},
        // stop : function(e) {}
    };

    var $window = $(window);
    var isTouch = !!('ontouchstart' in window);
    var pointer_events = {
        start: isTouch ? 'touchstart.gridster-draggable' : 'mousedown.gridster-draggable',
        move: isTouch ? 'touchmove.gridster-draggable' : 'mousemove.gridster-draggable',
        end: isTouch ? 'touchend.gridster-draggable' : 'mouseup.gridster-draggable'
    };

    /**
    * Basic drag implementation for DOM elements inside a container.
    * Provide start/stop/drag callbacks.
    *
    * @class Draggable
    * @param {HTMLElement} el The HTMLelement that contains all the widgets
    *  to be dragged.
    * @param {Object} [options] An Object with all options you want to
    *        overwrite:
    *    @param {HTMLElement|String} [options.items] Define who will
    *     be the draggable items. Can be a CSS Selector String or a
    *     collection of HTMLElements.
    *    @param {Number} [options.distance] Distance in pixels after mousedown
    *     the mouse must move before dragging should start.
    *    @param {Boolean} [options.limit] Constrains dragging to the width of
    *     the container
    *    @param {offset_left} [options.offset_left] Offset added to the item
    *     that is being dragged.
    *    @param {Number} [options.drag] Executes a callback when the mouse is
    *     moved during the dragging.
    *    @param {Number} [options.start] Executes a callback when the drag
    *     starts.
    *    @param {Number} [options.stop] Executes a callback when the drag stops.
    * @return {Object} Returns `el`.
    * @constructor
    */
    function Draggable(el, options) {
      this.options = $.extend({}, defaults, options);
      this.$body = $(document.body);
      this.$container = $(el);
      this.$dragitems = $(this.options.items, this.$container);
      this.is_dragging = false;
      this.player_min_left = 0 + this.options.offset_left;
      this.init();
    }

    var fn = Draggable.prototype;

    fn.init = function() {
        this.calculate_positions();
        this.$container.css('position', 'relative');
        this.disabled = false;
        this.events();

        $(window).bind('resize.gridster-draggable',
            throttle($.proxy(this.calculate_positions, this), 200));
    };

    fn.events = function() {
        this.$container.on('selectstart.gridster-draggable',
            $.proxy(this.on_select_start, this));

        this.$container.on(pointer_events.start, this.options.items,
            $.proxy(this.drag_handler, this));

        this.$body.on(pointer_events.end, $.proxy(function(e) {
            this.is_dragging = false;
            if (this.disabled) { return; }
            this.$body.off(pointer_events.move);
            if (this.drag_start) {
                this.on_dragstop(e);
            }
        }, this));
    };

    fn.get_actual_pos = function($el) {
        var pos = $el.position();
        return pos;
    };


    fn.get_mouse_pos = function(e) {
        if (isTouch) {
            var oe = e.originalEvent;
            e = oe.touches.length ? oe.touches[0] : oe.changedTouches[0];
        }

        return {
            left: e.clientX,
            top: e.clientY
        };
    };


    fn.get_offset = function(e) {
        e.preventDefault();
        var mouse_actual_pos = this.get_mouse_pos(e);
        var diff_x = Math.round(
            mouse_actual_pos.left - this.mouse_init_pos.left);
        var diff_y = Math.round(mouse_actual_pos.top - this.mouse_init_pos.top);

        var left = Math.round(this.el_init_offset.left + diff_x - this.baseX);
        var top = Math.round(
            this.el_init_offset.top + diff_y - this.baseY + this.scrollOffset);

        if (this.options.limit) {
            if (left > this.player_max_left) {
                left = this.player_max_left;
            } else if(left < this.player_min_left) {
                left = this.player_min_left;
            }
        }

        return {
            position: {
                left: left,
                top: top
            },
            pointer: {
                left: mouse_actual_pos.left,
                top: mouse_actual_pos.top,
                diff_left: diff_x,
                diff_top: diff_y + this.scrollOffset
            }
        };
    };


    fn.get_drag_data = function(e) {
        var offset = this.get_offset(e);
        offset.$player = this.$player;
        offset.$helper = this.helper ? this.$helper : this.$player;

        return offset;
    };


    fn.manage_scroll = function(data) {
        /* scroll document */
        var nextScrollTop;
        var scrollTop = $window.scrollTop();
        var min_window_y = scrollTop;
        var max_window_y = min_window_y + this.window_height;

        var mouse_down_zone = max_window_y - 50;
        var mouse_up_zone = min_window_y + 50;

        var abs_mouse_left = data.pointer.left;
        var abs_mouse_top = min_window_y + data.pointer.top;

        var max_player_y = (this.doc_height - this.window_height +
            this.player_height);

        if (abs_mouse_top >= mouse_down_zone) {
            nextScrollTop = scrollTop + 30;
            if (nextScrollTop < max_player_y) {
                $window.scrollTop(nextScrollTop);
                this.scrollOffset = this.scrollOffset + 30;
            }
        }

        if (abs_mouse_top <= mouse_up_zone) {
            nextScrollTop = scrollTop - 30;
            if (nextScrollTop > 0) {
                $window.scrollTop(nextScrollTop);
                this.scrollOffset = this.scrollOffset - 30;
            }
        }
    };


    fn.calculate_positions = function(e) {
        this.window_height = $window.height();
    };


    fn.drag_handler = function(e) {
        var node = e.target.nodeName;
        if (this.disabled || e.which !== 1 && !isTouch) {
            return;
        }

        if (this.ignore_drag(e)) {
            return;
        }

        var self = this;
        var first = true;
        this.$player = $(e.currentTarget);

        this.el_init_pos = this.get_actual_pos(this.$player);
        this.mouse_init_pos = this.get_mouse_pos(e);
        this.offsetY = this.mouse_init_pos.top - this.el_init_pos.top;

        this.$body.on(pointer_events.move, function(mme) {
            var mouse_actual_pos = self.get_mouse_pos(mme);
            var diff_x = Math.abs(
                mouse_actual_pos.left - self.mouse_init_pos.left);
            var diff_y = Math.abs(
                mouse_actual_pos.top - self.mouse_init_pos.top);
            if (!(diff_x > self.options.distance ||
                diff_y > self.options.distance)
                ) {
                return false;
            }

            if (first) {
                first = false;
                self.on_dragstart.call(self, mme);
                return false;
            }

            if (self.is_dragging === true) {
                self.on_dragmove.call(self, mme);
            }

            return false;
        });

        if (!isTouch) { return false; }
    };


    fn.on_dragstart = function(e) {
        e.preventDefault();

        if (this.is_dragging) { return this; }

        this.drag_start = this.is_dragging = true;
        var offset = this.$container.offset();
        this.baseX = Math.round(offset.left);
        this.baseY = Math.round(offset.top);
        this.doc_height = $(document).height();

        if (this.options.helper === 'clone') {
            this.$helper = this.$player.clone()
                .appendTo(this.$container).addClass('helper');
            this.helper = true;
        } else {
            this.helper = false;
        }

        this.scrollOffset = 0;
        this.el_init_offset = this.$player.offset();
        this.player_width = this.$player.width();
        this.player_height = this.$player.height();

        var container_width = this.options.container_width || this.$container.width();
        this.player_max_left = (container_width - this.player_width +
            this.options.offset_left);

        if (this.options.start) {
            this.options.start.call(this.$player, e, this.get_drag_data(e));
        }
        return false;
    };


    fn.on_dragmove = function(e) {
        var data = this.get_drag_data(e);

        this.options.autoscroll && this.manage_scroll(data);

        if (this.options.move_element) {
            (this.helper ? this.$helper : this.$player).css({
                'position': 'absolute',
                'left' : data.position.left,
                'top' : data.position.top
            });
        }

        var last_position = this.last_position || data.position;
        data.prev_position = last_position;

        if (this.options.drag) {
            this.options.drag.call(this.$player, e, data);
        }

        this.last_position = data.position;
        return false;
    };


    fn.on_dragstop = function(e) {
        var data = this.get_drag_data(e);
        this.drag_start = false;

        if (this.options.stop) {
            this.options.stop.call(this.$player, e, data);
        }

        if (this.helper) {
            this.$helper.remove();
        }

        return false;
    };

    fn.on_select_start = function(e) {
        if (this.disabled) { return; }

        if (this.ignore_drag(e)) {
            return;
        }

        return false;
    };

    fn.enable = function() {
        this.disabled = false;
    };

    fn.disable = function() {
        this.disabled = true;
    };

    fn.destroy = function() {
        this.disable();

        this.$container.off('.gridster-draggable');
        this.$body.off('.gridster-draggable');
        $(window).off('.gridster-draggable');

        $.removeData(this.$container, 'drag');
    };

    fn.ignore_drag = function(event) {
        if (this.options.handle) {
            return !$(event.target).is(this.options.handle);
        }

        return $(event.target).is(this.options.ignore_dragging.join(', '));
    };

    //jQuery adapter
    $.fn.drag = function ( options ) {
        return new Draggable(this, options);
    };


}(jQuery, window, document));

;(function($, window, document, undefined) {

    var defaults = {
        namespace: '',
        widget_selector: 'li',
        widget_margins: [10, 10],
        widget_base_dimensions: [400, 225],
        extra_rows: 0,
        extra_cols: 0,
        min_cols: 1,
        max_cols: null,
        min_rows: 15,
        max_size_x: false,
        autogenerate_stylesheet: true,
        avoid_overlapped_widgets: true,
        serialize_params: function($w, wgd) {
            return {
                col: wgd.col,
                row: wgd.row,
                size_x: wgd.size_x,
                size_y: wgd.size_y
            };
        },
        collision: {},
        draggable: {
            items: '.gs-w',
            distance: 4
        },
        resize: {
            enabled: false,
            axes: ['x', 'y', 'both'],
            handle_append_to: '',
            handle_class: 'gs-resize-handle',
            max_size: [Infinity, Infinity]
        }
    };

    /**
    * @class Gridster
    * @uses Draggable
    * @uses Collision
    * @param {HTMLElement} el The HTMLelement that contains all the widgets.
    * @param {Object} [options] An Object with all options you want to
    *        overwrite:
    *    @param {HTMLElement|String} [options.widget_selector] Define who will
    *     be the draggable widgets. Can be a CSS Selector String or a
    *     collection of HTMLElements
    *    @param {Array} [options.widget_margins] Margin between widgets.
    *     The first index for the horizontal margin (left, right) and
    *     the second for the vertical margin (top, bottom).
    *    @param {Array} [options.widget_base_dimensions] Base widget dimensions
    *     in pixels. The first index for the width and the second for the
    *     height.
    *    @param {Number} [options.extra_cols] Add more columns in addition to
    *     those that have been calculated.
    *    @param {Number} [options.extra_rows] Add more rows in addition to
    *     those that have been calculated.
    *    @param {Number} [options.min_cols] The minimum required columns.
    *    @param {Number} [options.max_cols] The maximum columns possible (set to null
    *     for no maximum).
    *    @param {Number} [options.min_rows] The minimum required rows.
    *    @param {Number} [options.max_size_x] The maximum number of columns
    *     that a widget can span.
    *    @param {Boolean} [options.autogenerate_stylesheet] If true, all the
    *     CSS required to position all widgets in their respective columns
    *     and rows will be generated automatically and injected to the
    *     `<head>` of the document. You can set this to false, and write
    *     your own CSS targeting rows and cols via data-attributes like so:
    *     `[data-col="1"] { left: 10px; }`
    *    @param {Boolean} [options.avoid_overlapped_widgets] Avoid that widgets loaded
    *     from the DOM can be overlapped. It is helpful if the positions were
    *     bad stored in the database or if there was any conflict.
    *    @param {Function} [options.serialize_params] Return the data you want
    *     for each widget in the serialization. Two arguments are passed:
    *     `$w`: the jQuery wrapped HTMLElement, and `wgd`: the grid
    *     coords object (`col`, `row`, `size_x`, `size_y`).
    *    @param {Object} [options.collision] An Object with all options for
    *     Collision class you want to overwrite. See Collision docs for
    *     more info.
    *    @param {Object} [options.draggable] An Object with all options for
    *     Draggable class you want to overwrite. See Draggable docs for more
    *     info.
    *       @param {Object} [options.resize] An Object with resize config
    *        options.
    *       @param {Boolean} [options.resize.enabled] Set to true to enable
    *        resizing.
    *       @param {Array} [options.resize.axes] Axes in which widgets can be
    *        resized. Possible values: ['x', 'y', 'both'].
    *       @param {String} [options.resize.handle_append_to] Set a valid CSS
    *        selector to append resize handles to.
    *       @param {String} [options.resize.handle_class] CSS class name used
    *        by resize handles.
    *       @param {Array} [options.resize.max_size] Limit widget dimensions
    *        when resizing. Array values should be integers:
    *        `[max_cols_occupied, max_rows_occupied]`
    *
    * @constructor
    */
    function Gridster(el, options) {
        this.options = $.extend(true, defaults, options);
        this.$el = $(el);
        this.$wrapper = this.$el.parent();
        this.$widgets = this.$el.children(
            this.options.widget_selector).addClass('gs-w');
        this.widgets = [];
        this.$changed = $([]);
        this.wrapper_width = this.$wrapper.width();
        this.min_widget_width = (this.options.widget_margins[0] * 2) +
          this.options.widget_base_dimensions[0];
        this.min_widget_height = (this.options.widget_margins[1] * 2) +
          this.options.widget_base_dimensions[1];

        this.$style_tags = $([]);

        this.init();
    }

    Gridster.generated_stylesheets = [];

    var fn = Gridster.prototype;

    fn.init = function() {
        this.options.resize.enabled && this.setup_resize();
        this.generate_grid_and_stylesheet();
        this.get_widgets_from_DOM();
        this.set_dom_grid_height();
        this.$wrapper.addClass('ready');
        this.draggable();
        this.options.resize.enabled && this.resizable();

        $(window).bind('resize.gridster', throttle(
            $.proxy(this.recalculate_faux_grid, this), 200));
    };


    /**
    * Disables dragging.
    *
    * @method disable
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.disable = function() {
        this.$wrapper.find('.player-revert').removeClass('player-revert');
        this.drag_api.disable();
        return this;
    };


    /**
    * Enables dragging.
    *
    * @method enable
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.enable = function() {
        this.drag_api.enable();
        return this;
    };



    /**
    * Disables drag-and-drop widget resizing.
    *
    * @method disable
    * @return {Class} Returns instance of gridster Class.
    */
    fn.disable_resize = function() {
        this.$el.addClass('gs-resize-disabled');
        this.resize_api.disable();
        return this;
    };


    /**
    * Enables drag-and-drop widget resizing.
    *
    * @method enable
    * @return {Class} Returns instance of gridster Class.
    */
    fn.enable_resize = function() {
        this.$el.removeClass('gs-resize-disabled');
        this.resize_api.enable();
        return this;
    };


    /**
    * Add a new widget to the grid.
    *
    * @method add_widget
    * @param {String|HTMLElement} html The string representing the HTML of the widget
    *  or the HTMLElement.
    * @param {Number} [size_x] The nº of rows the widget occupies horizontally.
    * @param {Number} [size_y] The nº of columns the widget occupies vertically.
    * @param {Number} [col] The column the widget should start in.
    * @param {Number} [row] The row the widget should start in.
    * @param {Array} [max_size] max_size Maximun size (in units) for width and height.
    * @return {HTMLElement} Returns the jQuery wrapped HTMLElement representing.
    *  the widget that was just created.
    */
    fn.add_widget = function(html, size_x, size_y, col, row, max_size) {
        var pos;
        size_x || (size_x = 1);
        size_y || (size_y = 1);

        if (!col & !row) {
            pos = this.next_position(size_x, size_y);
        }else{
            pos = {
                col: col,
                row: row
            };

            this.empty_cells(col, row, size_x, size_y);
        }

        var $w = $(html).attr({
                'data-col': pos.col,
                'data-row': pos.row,
                'data-sizex' : size_x,
                'data-sizey' : size_y
            }).addClass('gs-w').appendTo(this.$el).hide();

        this.$widgets = this.$widgets.add($w);

        this.register_widget($w);

        this.add_faux_rows(pos.size_y);
        //this.add_faux_cols(pos.size_x);

        if (max_size) {
            this.set_widget_max_size($w, max_size);
        }

        this.set_dom_grid_height();

        return $w.fadeIn();
    };


    /**
    * Change widget size limits.
    *
    * @method set_widget_max_size
    * @param {HTMLElement|Number} $widget The jQuery wrapped HTMLElement
    *  representing the widget or an index representing the desired widget.
    * @param {Array} max_size Maximun size (in units) for width and height.
    * @return {HTMLElement} Returns instance of gridster Class.
    */
    fn.set_widget_max_size = function($widget, max_size) {
        $widget = typeof $widget === 'number' ?
            this.$widgets.eq($widget) : $widget;

        if (!$widget.length) { return this; }

        var wgd = $widget.data('coords').grid;
        wgd.max_size_x = max_size[0];
        wgd.max_size_y = max_size[1];

        return this;
    };


    /**
    * Append the resize handle into a widget.
    *
    * @method add_resize_handle
    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement
    *  representing the widget.
    * @return {HTMLElement} Returns instance of gridster Class.
    */
    fn.add_resize_handle = function($w) {
        var append_to = this.options.resize.handle_append_to;
        $(this.resize_handle_tpl).appendTo( append_to ? $(append_to, $w) : $w);

        return this;
    };


    /**
    * Change the size of a widget. Width is limited to the current grid width.
    *
    * @method resize_widget
    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement
    *  representing the widget.
    * @param {Number} size_x The number of columns that will occupy the widget.
    * @param {Number} size_y The number of rows that will occupy the widget.
    * @param {Boolean} [reposition] Set to false to not move the widget to
    *  the left if there is insufficient space on the right.
    *  By default <code>size_x</code> is limited to the space available from
    *  the column where the widget begins, until the last column to the right.
    * @param {Function} [callback] Function executed when the widget is removed.
    * @return {HTMLElement} Returns $widget.
    */
    fn.resize_widget = function($widget, size_x, size_y, reposition, callback) {
        var wgd = $widget.coords().grid;
        reposition !== false && (reposition = true);
        size_x || (size_x = wgd.size_x);
        size_y || (size_y = wgd.size_y);

        if (size_x > this.cols) {
            size_x = this.cols;
        }

        var old_size_y = wgd.size_y;
        var old_col = wgd.col;
        var new_col = old_col;

        if (reposition && old_col + size_x - 1 > this.cols) {
            var diff = old_col + (size_x - 1) - this.cols;
            var c = old_col - diff;
            new_col = Math.max(1, c);
        }

        if (size_y > old_size_y) {
            this.add_faux_rows(Math.max(size_y - old_size_y, 0));
        }

        var new_grid_data = {
            col: new_col,
            row: wgd.row,
            size_x: size_x,
            size_y: size_y
        };

        this.mutate_widget_in_gridmap($widget, wgd, new_grid_data);

        this.set_dom_grid_height();

        if (callback) {
            callback.call(this, new_grid_data.size_x, new_grid_data.size_y);
        }

        return $widget;
    };


    /**
    * Mutate widget dimensions and position in the grid map.
    *
    * @method mutate_widget_in_gridmap
    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement
    *  representing the widget to mutate.
    * @param {Object} wgd Current widget grid data (col, row, size_x, size_y).
    * @param {Object} new_wgd New widget grid data.
    * @return {HTMLElement} Returns instance of gridster Class.
    */
    fn.mutate_widget_in_gridmap = function($widget, wgd, new_wgd) {
        var old_size_x = wgd.size_x;
        var old_size_y = wgd.size_y;

        var old_cells_occupied = this.get_cells_occupied(wgd);
        var new_cells_occupied = this.get_cells_occupied(new_wgd);

        var empty_cols = [];
        $.each(old_cells_occupied.cols, function(i, col) {
            if ($.inArray(col, new_cells_occupied.cols) === -1) {
                empty_cols.push(col);
            }
        });

        var occupied_cols = [];
        $.each(new_cells_occupied.cols, function(i, col) {
            if ($.inArray(col, old_cells_occupied.cols) === -1) {
                occupied_cols.push(col);
            }
        });

        var empty_rows = [];
        $.each(old_cells_occupied.rows, function(i, row) {
            if ($.inArray(row, new_cells_occupied.rows) === -1) {
                empty_rows.push(row);
            }
        });

        var occupied_rows = [];
        $.each(new_cells_occupied.rows, function(i, row) {
            if ($.inArray(row, old_cells_occupied.rows) === -1) {
                occupied_rows.push(row);
            }
        });

        this.remove_from_gridmap(wgd);

        if (occupied_cols.length) {
            var cols_to_empty = [
                new_wgd.col, new_wgd.row, new_wgd.size_x, Math.min(old_size_y, new_wgd.size_y), $widget
            ];
            this.empty_cells.apply(this, cols_to_empty);
        }

        if (occupied_rows.length) {
            var rows_to_empty = [new_wgd.col, new_wgd.row, new_wgd.size_x, new_wgd.size_y, $widget];
            this.empty_cells.apply(this, rows_to_empty);
        }

        // not the same that wgd = new_wgd;
        wgd.col = new_wgd.col;
        wgd.row = new_wgd.row;
        wgd.size_x = new_wgd.size_x;
        wgd.size_y = new_wgd.size_y;

        this.add_to_gridmap(new_wgd, $widget);

        $widget.removeClass('player-revert');

        //update coords instance attributes
        $widget.data('coords').update({
            width: (new_wgd.size_x * this.options.widget_base_dimensions[0] +
                ((new_wgd.size_x - 1) * this.options.widget_margins[0]) * 2),
            height: (new_wgd.size_y * this.options.widget_base_dimensions[1] +
                ((new_wgd.size_y - 1) * this.options.widget_margins[1]) * 2)
        });

        $widget.attr({
            'data-col': new_wgd.col,
            'data-row': new_wgd.row,
            'data-sizex': new_wgd.size_x,
            'data-sizey': new_wgd.size_y
        });

        if (empty_cols.length) {
            var cols_to_remove_holes = [
                empty_cols[0], new_wgd.row,
                empty_cols.length,
                Math.min(old_size_y, new_wgd.size_y),
                $widget
            ];

            this.remove_empty_cells.apply(this, cols_to_remove_holes);
        }

        if (empty_rows.length) {
            var rows_to_remove_holes = [
                new_wgd.col, new_wgd.row, new_wgd.size_x, new_wgd.size_y, $widget
            ];
            this.remove_empty_cells.apply(this, rows_to_remove_holes);
        }

        this.move_widget_up($widget);

        return this;
    };


    /**
    * Move down widgets in cells represented by the arguments col, row, size_x,
    * size_y
    *
    * @method empty_cells
    * @param {Number} col The column where the group of cells begin.
    * @param {Number} row The row where the group of cells begin.
    * @param {Number} size_x The number of columns that the group of cells
    * occupy.
    * @param {Number} size_y The number of rows that the group of cells
    * occupy.
    * @param {HTMLElement} $exclude Exclude widgets from being moved.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.empty_cells = function(col, row, size_x, size_y, $exclude) {
        var $nexts = this.widgets_below({
                col: col,
                row: row - size_y,
                size_x: size_x,
                size_y: size_y
            });

        $nexts.not($exclude).each($.proxy(function(i, w) {
            var wgd = $(w).coords().grid;
            if (!(wgd.row <= (row + size_y - 1))) { return; }
            var diff =  (row + size_y) - wgd.row;
            this.move_widget_down($(w), diff);
        }, this));

        this.set_dom_grid_height();

        return this;
    };


    /**
    * Move up widgets below cells represented by the arguments col, row, size_x,
    * size_y.
    *
    * @method remove_empty_cells
    * @param {Number} col The column where the group of cells begin.
    * @param {Number} row The row where the group of cells begin.
    * @param {Number} size_x The number of columns that the group of cells
    * occupy.
    * @param {Number} size_y The number of rows that the group of cells
    * occupy.
    * @param {HTMLElement} exclude Exclude widgets from being moved.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.remove_empty_cells = function(col, row, size_x, size_y, exclude) {
        var $nexts = this.widgets_below({
            col: col,
            row: row,
            size_x: size_x,
            size_y: size_y
        });

        $nexts.not(exclude).each($.proxy(function(i, widget) {
            this.move_widget_up( $(widget), size_y );
        }, this));

        this.set_dom_grid_height();

        return this;
    };


    /**
    * Get the most left column below to add a new widget.
    *
    * @method next_position
    * @param {Number} size_x The nº of rows the widget occupies horizontally.
    * @param {Number} size_y The nº of columns the widget occupies vertically.
    * @return {Object} Returns a grid coords object representing the future
    *  widget coords.
    */
    fn.next_position = function(size_x, size_y) {
        size_x || (size_x = 1);
        size_y || (size_y = 1);
        var ga = this.gridmap;
        var cols_l = ga.length;
        var valid_pos = [];
        var rows_l;

        for (var c = 1; c < cols_l; c++) {
            rows_l = ga[c].length;
            for (var r = 1; r <= rows_l; r++) {
                var can_move_to = this.can_move_to({
                    size_x: size_x,
                    size_y: size_y
                }, c, r);

                if (can_move_to) {
                    valid_pos.push({
                        col: c,
                        row: r,
                        size_y: size_y,
                        size_x: size_x
                    });
                }
            }
        }

        if (valid_pos.length) {
            return this.sort_by_row_and_col_asc(valid_pos)[0];
        }
        return false;
    };


    /**
    * Remove a widget from the grid.
    *
    * @method remove_widget
    * @param {HTMLElement} el The jQuery wrapped HTMLElement you want to remove.
    * @param {Boolean|Function} silent If true, widgets below the removed one
    * will not move up. If a Function is passed it will be used as callback.
    * @param {Function} callback Function executed when the widget is removed.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.remove_widget = function(el, silent, callback) {
        var $el = el instanceof jQuery ? el : $(el);
        var wgd = $el.coords().grid;

        // if silent is a function assume it's a callback
        if ($.isFunction(silent)) {
            callback = silent;
            silent = false;
        }

        this.cells_occupied_by_placeholder = {};
        this.$widgets = this.$widgets.not($el);

        var $nexts = this.widgets_below($el);

        this.remove_from_gridmap(wgd);

        $el.fadeOut($.proxy(function() {
            $el.remove();

            if (!silent) {
                $nexts.each($.proxy(function(i, widget) {
                    this.move_widget_up( $(widget), wgd.size_y );
                }, this));
            }

            this.set_dom_grid_height();

            if (callback) {
                callback.call(this, el);
            }
        }, this));

        return this;
    };


    /**
    * Remove all widgets from the grid.
    *
    * @method remove_all_widgets
    * @param {Function} callback Function executed for each widget removed.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.remove_all_widgets = function(callback) {
        this.$widgets.each($.proxy(function(i, el){
              this.remove_widget(el, true, callback);
        }, this));

        return this;
    };


    /**
    * Returns a serialized array of the widgets in the grid.
    *
    * @method serialize
    * @param {HTMLElement} [$widgets] The collection of jQuery wrapped
    *  HTMLElements you want to serialize. If no argument is passed all widgets
    *  will be serialized.
    * @return {Array} Returns an Array of Objects with the data specified in
    *  the serialize_params option.
    */
    fn.serialize = function($widgets) {
        $widgets || ($widgets = this.$widgets);
        var result = [];
        $widgets.each($.proxy(function(i, widget) {
            result.push(this.options.serialize_params(
                $(widget), $(widget).coords().grid ) );
        }, this));

        return result;
    };


    /**
    * Returns a serialized array of the widgets that have changed their
    *  position.
    *
    * @method serialize_changed
    * @return {Array} Returns an Array of Objects with the data specified in
    *  the serialize_params option.
    */
    fn.serialize_changed = function() {
        return this.serialize(this.$changed);
    };


    /**
    * Creates the grid coords object representing the widget a add it to the
    * mapped array of positions.
    *
    * @method register_widget
    * @return {Array} Returns the instance of the Gridster class.
    */
    fn.register_widget = function($el) {
        var wgd = {
            'col': parseInt($el.attr('data-col'), 10),
            'row': parseInt($el.attr('data-row'), 10),
            'size_x': parseInt($el.attr('data-sizex'), 10),
            'size_y': parseInt($el.attr('data-sizey'), 10),
            'max_size_x': parseInt($el.attr('data-max-sizex'), 10) || false,
            'max_size_y': parseInt($el.attr('data-max-sizey'), 10) || false,
            'el': $el
        };

        if (this.options.avoid_overlapped_widgets &&
            !this.can_move_to(
             {size_x: wgd.size_x, size_y: wgd.size_y}, wgd.col, wgd.row)
        ) {
            $.extend(wgd, this.next_position(wgd.size_x, wgd.size_y));
            $el.attr({
                'data-col': wgd.col,
                'data-row': wgd.row,
                'data-sizex': wgd.size_x,
                'data-sizey': wgd.size_y
            });
        }

        // attach Coord object to player data-coord attribute
        $el.data('coords', $el.coords());
        // Extend Coord object with grid position info
        $el.data('coords').grid = wgd;

        this.add_to_gridmap(wgd, $el);

        this.options.resize.enabled && this.add_resize_handle($el);

        return this;
    };


    /**
    * Update in the mapped array of positions the value of cells represented by
    * the grid coords object passed in the `grid_data` param.
    *
    * @param {Object} grid_data The grid coords object representing the cells
    *  to update in the mapped array.
    * @param {HTMLElement|Boolean} value Pass `false` or the jQuery wrapped
    *  HTMLElement, depends if you want to delete an existing position or add
    *  a new one.
    * @method update_widget_position
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.update_widget_position = function(grid_data, value) {
        this.for_each_cell_occupied(grid_data, function(col, row) {
            if (!this.gridmap[col]) { return this; }
            this.gridmap[col][row] = value;
        });
        return this;
    };


    /**
    * Remove a widget from the mapped array of positions.
    *
    * @method remove_from_gridmap
    * @param {Object} grid_data The grid coords object representing the cells
    *  to update in the mapped array.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.remove_from_gridmap = function(grid_data) {
        return this.update_widget_position(grid_data, false);
    };


    /**
    * Add a widget to the mapped array of positions.
    *
    * @method add_to_gridmap
    * @param {Object} grid_data The grid coords object representing the cells
    *  to update in the mapped array.
    * @param {HTMLElement|Boolean} value The value to set in the specified
    *  position .
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.add_to_gridmap = function(grid_data, value) {
        this.update_widget_position(grid_data, value || grid_data.el);

        if (grid_data.el) {
            var $widgets = this.widgets_below(grid_data.el);
            $widgets.each($.proxy(function(i, widget) {
                this.move_widget_up( $(widget));
            }, this));
        }
    };


    /**
    * Make widgets draggable.
    *
    * @uses Draggable
    * @method draggable
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.draggable = function() {
        var self = this;
        var draggable_options = $.extend(true, {}, this.options.draggable, {
            offset_left: this.options.widget_margins[0],
            container_width: this.container_width,
            ignore_dragging: ['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON',
                '.' + this.options.resize.handle_class],
            start: function(event, ui) {
                self.$widgets.filter('.player-revert')
                    .removeClass('player-revert');

                self.$player = $(this);
                self.$helper = $(ui.$helper);

                self.helper = !self.$helper.is(self.$player);

                self.on_start_drag.call(self, event, ui);
                self.$el.trigger('gridster:dragstart');
            },
            stop: function(event, ui) {
                self.on_stop_drag.call(self, event, ui);
                self.$el.trigger('gridster:dragstop');
            },
            drag: throttle(function(event, ui) {
                self.on_drag.call(self, event, ui);
                self.$el.trigger('gridster:drag');
            }, 60)
          });

        this.drag_api = this.$el.drag(draggable_options);
        return this;
    };


    /**
    * Bind resize events to get resize working.
    *
    * @method resizable
    * @return {Class} Returns instance of gridster Class.
    */
    fn.resizable = function() {
        this.resize_api = this.$el.drag({
            items: '.' + this.options.resize.handle_class,
            offset_left: this.options.widget_margins[0],
            container_width: this.container_width,
            move_element: false,
            start: $.proxy(this.on_start_resize, this),
            stop: $.proxy(function(event, ui) {
                delay($.proxy(function() {
                    this.on_stop_resize(event, ui);
                }, this), 120);
            }, this),
            drag: throttle($.proxy(this.on_resize, this), 60)
        });

        return this;
    };


    /**
    * Setup things required for resizing. Like build templates for drag handles.
    *
    * @method setup_resize
    * @return {Class} Returns instance of gridster Class.
    */
    fn.setup_resize = function() {
        this.resize_handle_class = this.options.resize.handle_class;
        var axes = this.options.resize.axes;
        var handle_tpl = '<span class="' + this.resize_handle_class + ' ' +
            this.resize_handle_class + '-{type}" />';

        this.resize_handle_tpl = $.map(axes, function(type) {
            return handle_tpl.replace('{type}', type);
        }).join('');
        return this;
    };


    /**
    * This function is executed when the player begins to be dragged.
    *
    * @method on_start_drag
    * @param {Event} event The original browser event
    * @param {Object} ui A prepared ui object with useful drag-related data
    */
    fn.on_start_drag = function(event, ui) {
        this.$helper.add(this.$player).add(this.$wrapper).addClass('dragging');

        this.$player.addClass('player');
        this.player_grid_data = this.$player.coords().grid;
        this.placeholder_grid_data = $.extend({}, this.player_grid_data);

        //set new grid height along the dragging period
        this.$el.css('height', this.$el.height() +
          (this.player_grid_data.size_y * this.min_widget_height));

        var colliders = this.faux_grid;
        var coords = this.$player.data('coords').coords;

        this.cells_occupied_by_player = this.get_cells_occupied(
            this.player_grid_data);
        this.cells_occupied_by_placeholder = this.get_cells_occupied(
            this.placeholder_grid_data);

        this.last_cols = [];
        this.last_rows = [];

        // see jquery.collision.js
        this.collision_api = this.$helper.collision(
            colliders, this.options.collision);

        this.$preview_holder = $('<' + this.$player.get(0).tagName + ' />', {
              'class': 'preview-holder',
              'data-row': this.$player.attr('data-row'),
              'data-col': this.$player.attr('data-col'),
              css: {
                  width: coords.width,
                  height: coords.height
              }
        }).appendTo(this.$el);

        if (this.options.draggable.start) {
          this.options.draggable.start.call(this, event, ui);
        }
    };


    /**
    * This function is executed when the player is being dragged.
    *
    * @method on_drag
    * @param {Event} event The original browser event
    * @param {Object} ui A prepared ui object with useful drag-related data
    */
    fn.on_drag = function(event, ui) {
        //break if dragstop has been fired
        if (this.$player === null) {
            return false;
        }

        var abs_offset = {
            left: ui.position.left + this.baseX,
            top: ui.position.top + this.baseY
        };

        this.colliders_data = this.collision_api.get_closest_colliders(
            abs_offset);

        this.on_overlapped_column_change(
            this.on_start_overlapping_column,
            this.on_stop_overlapping_column
        );

        this.on_overlapped_row_change(
            this.on_start_overlapping_row,
            this.on_stop_overlapping_row
        );

        if (this.helper && this.$player) {
            this.$player.css({
                'left': ui.position.left,
                'top': ui.position.top
            });
        }

        if (this.options.draggable.drag) {
            this.options.draggable.drag.call(this, event, ui);
        }
    };

    /**
    * This function is executed when the player stops being dragged.
    *
    * @method on_stop_drag
    * @param {Event} event The original browser event
    * @param {Object} ui A prepared ui object with useful drag-related data
    */
    fn.on_stop_drag = function(event, ui) {
        this.$helper.add(this.$player).add(this.$wrapper)
            .removeClass('dragging');

        ui.position.left = ui.position.left + this.baseX;
        ui.position.top = ui.position.top + this.baseY;
        this.colliders_data = this.collision_api.get_closest_colliders(
            ui.position);

        this.on_overlapped_column_change(
            this.on_start_overlapping_column,
            this.on_stop_overlapping_column
        );

        this.on_overlapped_row_change(
            this.on_start_overlapping_row,
            this.on_stop_overlapping_row
        );

        this.$player.addClass('player-revert').removeClass('player')
            .attr({
                'data-col': this.placeholder_grid_data.col,
                'data-row': this.placeholder_grid_data.row
            }).css({
                'left': '',
                'top': ''
            });

        this.$changed = this.$changed.add(this.$player);

        this.cells_occupied_by_player = this.get_cells_occupied(
            this.placeholder_grid_data);
        this.set_cells_player_occupies(
            this.placeholder_grid_data.col, this.placeholder_grid_data.row);

        this.$player.coords().grid.row = this.placeholder_grid_data.row;
        this.$player.coords().grid.col = this.placeholder_grid_data.col;

        if (this.options.draggable.stop) {
          this.options.draggable.stop.call(this, event, ui);
        }

        this.$preview_holder.remove();

        this.$player = null;
        this.$helper = null;
        this.placeholder_grid_data = {};
        this.player_grid_data = {};
        this.cells_occupied_by_placeholder = {};
        this.cells_occupied_by_player = {};

        this.set_dom_grid_height();
    };



    /**
    * This function is executed every time a widget starts to be resized.
    *
    * @method on_start_resize
    * @param {Event} event The original browser event
    * @param {Object} ui A prepared ui object with useful drag-related data
    */
    fn.on_start_resize = function(event, ui) {
        this.$resized_widget = ui.$player.closest('.gs-w');
        this.resize_coords = this.$resized_widget.coords();
        this.resize_wgd = this.resize_coords.grid;
        this.resize_initial_width = this.resize_coords.coords.width;
        this.resize_initial_height = this.resize_coords.coords.height;
        this.resize_initial_sizex = this.resize_coords.grid.size_x;
        this.resize_initial_sizey = this.resize_coords.grid.size_y;
        this.resize_last_sizex = this.resize_initial_sizex;
        this.resize_last_sizey = this.resize_initial_sizey;
        this.resize_max_size_x = Math.min(this.resize_wgd.max_size_x ||
            this.options.resize.max_size[0], this.cols - this.resize_wgd.col + 1);
        this.resize_max_size_y = this.resize_wgd.max_size_y ||
            this.options.resize.max_size[1];

        this.resize_dir = {
            right: ui.$player.is('.' + this.resize_handle_class + '-x'),
            bottom: ui.$player.is('.' + this.resize_handle_class + '-y')
        };

        this.$resized_widget.css({
            'min-width': this.options.widget_base_dimensions[0],
            'min-height': this.options.widget_base_dimensions[1]
        });

        var nodeName = this.$resized_widget.get(0).tagName;
        this.$resize_preview_holder = $('<' + nodeName + ' />', {
              'class': 'preview-holder resize-preview-holder',
              'data-row': this.$resized_widget.attr('data-row'),
              'data-col': this.$resized_widget.attr('data-col'),
              'css': {
                  'width': this.resize_initial_width,
                  'height': this.resize_initial_height
              }
        }).appendTo(this.$el);

        this.$resized_widget.addClass('resizing');
    };


    /**
    * This function is executed every time a widget stops being resized.
    *
    * @method on_stop_resize
    * @param {Event} event The original browser event
    * @param {Object} ui A prepared ui object with useful drag-related data
    */
    fn.on_stop_resize = function(event, ui) {
        this.$resized_widget
            .removeClass('resizing')
            .css({
                'width': '',
                'height': ''
            });

        delay($.proxy(function() {
            this.$resize_preview_holder
                .remove()
                .css({
                    'min-width': '',
                    'min-height': ''
                });
        }, this), 300);
    };

    /**
    * This function is executed when a widget is being resized.
    *
    * @method on_resize
    * @param {Event} event The original browser event
    * @param {Object} ui A prepared ui object with useful drag-related data
    */
    fn.on_resize = function(event, ui) {
        var rel_x = (ui.pointer.diff_left);
        var rel_y = (ui.pointer.diff_top);
        var wbd_x = this.options.widget_base_dimensions[0];
        var wbd_y = this.options.widget_base_dimensions[1];
        var max_width = Infinity;
        var max_height = Infinity;

        var inc_units_x = Math.ceil((rel_x /
                (this.options.widget_base_dimensions[0] +
                    this.options.widget_margins[0] * 2)) - 0.2);

        var inc_units_y = Math.ceil((rel_y /
                (this.options.widget_base_dimensions[1] +
                 this.options.widget_margins[1] * 2)) - 0.2);

        var size_x = Math.max(1, this.resize_initial_sizex + inc_units_x);
        var size_y = Math.max(1, this.resize_initial_sizey + inc_units_y);

        size_x = Math.min(size_x, this.resize_max_size_x);
        max_width = (this.resize_max_size_x * wbd_x) +
            ((size_x - 1) * this.options.widget_margins[0] * 2);

        size_y = Math.min(size_y, this.resize_max_size_y);
        max_height = (this.resize_max_size_y * wbd_y) +
            ((size_y - 1) * this.options.widget_margins[1] * 2);


        if (this.resize_dir.right) {
            size_y = this.resize_initial_sizey;
        } else if (this.resize_dir.bottom) {
            size_x = this.resize_initial_sizex;
        }

        var css_props = {};
        !this.resize_dir.bottom && (css_props.width = Math.min(
            this.resize_initial_width + rel_x, max_width));
        !this.resize_dir.right && (css_props.height = Math.min(
            this.resize_initial_height + rel_y, max_height));

        this.$resized_widget.css(css_props);

        if (size_x !== this.resize_last_sizex ||
            size_y !== this.resize_last_sizey) {

            this.resize_widget(this.$resized_widget, size_x, size_y, false);

            this.$resize_preview_holder.css({
                'width': '',
                'height': ''
            }).attr({
                'data-row': this.$resized_widget.attr('data-row'),
                'data-sizex': size_x,
                'data-sizey': size_y
            });
        }

        this.resize_last_sizex = size_x;
        this.resize_last_sizey = size_y;
    };


    /**
    * Executes the callbacks passed as arguments when a column begins to be
    * overlapped or stops being overlapped.
    *
    * @param {Function} start_callback Function executed when a new column
    *  begins to be overlapped. The column is passed as first argument.
    * @param {Function} stop_callback Function executed when a column stops
    *  being overlapped. The column is passed as first argument.
    * @method on_overlapped_column_change
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.on_overlapped_column_change = function(start_callback, stop_callback) {
        if (!this.colliders_data.length) {
            return this;
        }
        var cols = this.get_targeted_columns(
            this.colliders_data[0].el.data.col);

        var last_n_cols = this.last_cols.length;
        var n_cols = cols.length;
        var i;

        for (i = 0; i < n_cols; i++) {
            if ($.inArray(cols[i], this.last_cols) === -1) {
                (start_callback || $.noop).call(this, cols[i]);
            }
        }

        for (i = 0; i< last_n_cols; i++) {
            if ($.inArray(this.last_cols[i], cols) === -1) {
                (stop_callback || $.noop).call(this, this.last_cols[i]);
            }
        }

        this.last_cols = cols;

        return this;
    };


    /**
    * Executes the callbacks passed as arguments when a row starts to be
    * overlapped or stops being overlapped.
    *
    * @param {Function} start_callback Function executed when a new row begins
    *  to be overlapped. The row is passed as first argument.
    * @param {Function} end_callback Function executed when a row stops being
    *  overlapped. The row is passed as first argument.
    * @method on_overlapped_row_change
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.on_overlapped_row_change = function(start_callback, end_callback) {
        if (!this.colliders_data.length) {
            return this;
        }
        var rows = this.get_targeted_rows(this.colliders_data[0].el.data.row);
        var last_n_rows = this.last_rows.length;
        var n_rows = rows.length;
        var i;

        for (i = 0; i < n_rows; i++) {
            if ($.inArray(rows[i], this.last_rows) === -1) {
                (start_callback || $.noop).call(this, rows[i]);
            }
        }

        for (i = 0; i < last_n_rows; i++) {
            if ($.inArray(this.last_rows[i], rows) === -1) {
                (end_callback || $.noop).call(this, this.last_rows[i]);
            }
        }

        this.last_rows = rows;
    };


    /**
    * Sets the current position of the player
    *
    * @param {Number} col
    * @param {Number} row
    * @param {Boolean} no_player
    * @method set_player
    * @return {object}
    */
    fn.set_player = function(col, row, no_player) {
        var self = this;
        if (!no_player) {
            this.empty_cells_player_occupies();
        }
        var cell = !no_player ? self.colliders_data[0].el.data : {col: col};
        var to_col = cell.col;
        var to_row = row || cell.row;

        this.player_grid_data = {
            col: to_col,
            row: to_row,
            size_y : this.player_grid_data.size_y,
            size_x : this.player_grid_data.size_x
        };

        this.cells_occupied_by_player = this.get_cells_occupied(
            this.player_grid_data);

        var $overlapped_widgets = this.get_widgets_overlapped(
            this.player_grid_data);

        var constraints = this.widgets_constraints($overlapped_widgets);

        this.manage_movements(constraints.can_go_up, to_col, to_row);
        this.manage_movements(constraints.can_not_go_up, to_col, to_row);

        /* if there is not widgets overlapping in the new player position,
         * update the new placeholder position. */
        if (!$overlapped_widgets.length) {
            var pp = this.can_go_player_up(this.player_grid_data);
            if (pp !== false) {
                to_row = pp;
            }
            this.set_placeholder(to_col, to_row);
        }

        return {
            col: to_col,
            row: to_row
        };
    };


    /**
    * See which of the widgets in the $widgets param collection can go to
    * a upper row and which not.
    *
    * @method widgets_contraints
    * @param {jQuery} $widgets A jQuery wrapped collection of
    * HTMLElements.
    * @return {object} Returns a literal Object with two keys: `can_go_up` &
    * `can_not_go_up`. Each contains a set of HTMLElements.
    */
    fn.widgets_constraints = function($widgets) {
        var $widgets_can_go_up = $([]);
        var $widgets_can_not_go_up;
        var wgd_can_go_up = [];
        var wgd_can_not_go_up = [];

        $widgets.each($.proxy(function(i, w) {
            var $w = $(w);
            var wgd = $w.coords().grid;
            if (this.can_go_widget_up(wgd)) {
                $widgets_can_go_up = $widgets_can_go_up.add($w);
                wgd_can_go_up.push(wgd);
            }else{
                wgd_can_not_go_up.push(wgd);
            }
        }, this));

        $widgets_can_not_go_up = $widgets.not($widgets_can_go_up);

        return {
            can_go_up: this.sort_by_row_asc(wgd_can_go_up),
            can_not_go_up: this.sort_by_row_desc(wgd_can_not_go_up)
        };
    };


    /**
    * Sorts an Array of grid coords objects (representing the grid coords of
    * each widget) in ascending way.
    *
    * @method sort_by_row_asc
    * @param {Array} widgets Array of grid coords objects
    * @return {Array} Returns the array sorted.
    */
    fn.sort_by_row_asc = function(widgets) {
        widgets = widgets.sort(function(a, b) {
            if (!a.row) {
                a = $(a).coords().grid;
                b = $(b).coords().grid;
            }

           if (a.row > b.row) {
               return 1;
           }
           return -1;
        });

        return widgets;
    };


    /**
    * Sorts an Array of grid coords objects (representing the grid coords of
    * each widget) placing first the empty cells upper left.
    *
    * @method sort_by_row_and_col_asc
    * @param {Array} widgets Array of grid coords objects
    * @return {Array} Returns the array sorted.
    */
    fn.sort_by_row_and_col_asc = function(widgets) {
        widgets = widgets.sort(function(a, b) {
           if (a.row > b.row || a.row === b.row && a.col > b.col) {
               return 1;
           }
           return -1;
        });

        return widgets;
    };


    /**
    * Sorts an Array of grid coords objects by column (representing the grid
    * coords of each widget) in ascending way.
    *
    * @method sort_by_col_asc
    * @param {Array} widgets Array of grid coords objects
    * @return {Array} Returns the array sorted.
    */
    fn.sort_by_col_asc = function(widgets) {
        widgets = widgets.sort(function(a, b) {
           if (a.col > b.col) {
               return 1;
           }
           return -1;
        });

        return widgets;
    };


    /**
    * Sorts an Array of grid coords objects (representing the grid coords of
    * each widget) in descending way.
    *
    * @method sort_by_row_desc
    * @param {Array} widgets Array of grid coords objects
    * @return {Array} Returns the array sorted.
    */
    fn.sort_by_row_desc = function(widgets) {
        widgets = widgets.sort(function(a, b) {
            if (a.row + a.size_y < b.row + b.size_y) {
                return 1;
            }
           return -1;
        });
        return widgets;
    };


    /**
    * Sorts an Array of grid coords objects (representing the grid coords of
    * each widget) in descending way.
    *
    * @method manage_movements
    * @param {jQuery} $widgets A jQuery collection of HTMLElements
    *  representing the widgets you want to move.
    * @param {Number} to_col The column to which we want to move the widgets.
    * @param {Number} to_row The row to which we want to move the widgets.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.manage_movements = function($widgets, to_col, to_row) {
        $.each($widgets, $.proxy(function(i, w) {
            var wgd = w;
            var $w = wgd.el;

            var can_go_widget_up = this.can_go_widget_up(wgd);

            if (can_go_widget_up) {
                //target CAN go up
                //so move widget up
                this.move_widget_to($w, can_go_widget_up);
                this.set_placeholder(to_col, can_go_widget_up + wgd.size_y);

            } else {
                //target can't go up
                var can_go_player_up = this.can_go_player_up(
                    this.player_grid_data);

                if (!can_go_player_up) {
                    // target can't go up
                    // player cant't go up
                    // so we need to move widget down to a position that dont
                    // overlaps player
                    var y = (to_row + this.player_grid_data.size_y) - wgd.row;

                    this.move_widget_down($w, y);
                    this.set_placeholder(to_col, to_row);
                }
            }
        }, this));

        return this;
    };

    /**
    * Determines if there is a widget in the row and col given. Or if the
    * HTMLElement passed as first argument is the player.
    *
    * @method is_player
    * @param {Number|HTMLElement} col_or_el A jQuery wrapped collection of
    * HTMLElements.
    * @param {Number} [row] The column to which we want to move the widgets.
    * @return {Boolean} Returns true or false.
    */
    fn.is_player = function(col_or_el, row) {
        if (row && !this.gridmap[col_or_el]) { return false; }
        var $w = row ? this.gridmap[col_or_el][row] : col_or_el;
        return $w && ($w.is(this.$player) || $w.is(this.$helper));
    };


    /**
    * Determines if the widget that is being dragged is currently over the row
    * and col given.
    *
    * @method is_player_in
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_player_in = function(col, row) {
        var c = this.cells_occupied_by_player || {};
        return $.inArray(col, c.cols) >= 0 && $.inArray(row, c.rows) >= 0;
    };


    /**
    * Determines if the placeholder is currently over the row and col given.
    *
    * @method is_placeholder_in
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_placeholder_in = function(col, row) {
        var c = this.cells_occupied_by_placeholder || {};
        return this.is_placeholder_in_col(col) && $.inArray(row, c.rows) >= 0;
    };


    /**
    * Determines if the placeholder is currently over the column given.
    *
    * @method is_placeholder_in_col
    * @param {Number} col The column to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_placeholder_in_col = function(col) {
        var c = this.cells_occupied_by_placeholder || [];
        return $.inArray(col, c.cols) >= 0;
    };


    /**
    * Determines if the cell represented by col and row params is empty.
    *
    * @method is_empty
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_empty = function(col, row) {
        if (typeof this.gridmap[col] !== 'undefined') {
			if(typeof this.gridmap[col][row] !== 'undefined' &&
				 this.gridmap[col][row] === false
			) {
				return true;
			}
			return false;
		}
		return true;
    };


    /**
    * Determines if the cell represented by col and row params is occupied.
    *
    * @method is_occupied
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_occupied = function(col, row) {
        if (!this.gridmap[col]) {
            return false;
        }

        if (this.gridmap[col][row]) {
            return true;
        }
        return false;
    };


    /**
    * Determines if there is a widget in the cell represented by col/row params.
    *
    * @method is_widget
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean|HTMLElement} Returns false if there is no widget,
    * else returns the jQuery HTMLElement
    */
    fn.is_widget = function(col, row) {
        var cell = this.gridmap[col];
        if (!cell) {
            return false;
        }

        cell = cell[row];

        if (cell) {
            return cell;
        }

        return false;
    };


    /**
    * Determines if there is a widget in the cell represented by col/row
    * params and if this is under the widget that is being dragged.
    *
    * @method is_widget_under_player
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_widget_under_player = function(col, row) {
        if (this.is_widget(col, row)) {
            return this.is_player_in(col, row);
        }
        return false;
    };


    /**
    * Get widgets overlapping with the player or with the object passed
    * representing the grid cells.
    *
    * @method get_widgets_under_player
    * @return {HTMLElement} Returns a jQuery collection of HTMLElements
    */
    fn.get_widgets_under_player = function(cells) {
        cells || (cells = this.cells_occupied_by_player || {cols: [], rows: []});
        var $widgets = $([]);

        $.each(cells.cols, $.proxy(function(i, col) {
            $.each(cells.rows, $.proxy(function(i, row) {
                if(this.is_widget(col, row)) {
                    $widgets = $widgets.add(this.gridmap[col][row]);
                }
            }, this));
        }, this));

        return $widgets;
    };


    /**
    * Put placeholder at the row and column specified.
    *
    * @method set_placeholder
    * @param {Number} col The column to which we want to move the
    *  placeholder.
    * @param {Number} row The row to which we want to move the
    *  placeholder.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.set_placeholder = function(col, row) {
        var phgd = $.extend({}, this.placeholder_grid_data);
        var $nexts = this.widgets_below({
                col: phgd.col,
                row: phgd.row,
                size_y: phgd.size_y,
                size_x: phgd.size_x
            });

        // Prevents widgets go out of the grid
        var right_col = (col + phgd.size_x - 1);
        if (right_col > this.cols) {
            col = col - (right_col - col);
        }

        var moved_down = this.placeholder_grid_data.row < row;
        var changed_column = this.placeholder_grid_data.col !== col;

        this.placeholder_grid_data.col = col;
        this.placeholder_grid_data.row = row;

        this.cells_occupied_by_placeholder = this.get_cells_occupied(
            this.placeholder_grid_data);

        this.$preview_holder.attr({
            'data-row' : row,
            'data-col' : col
        });

        if (moved_down || changed_column) {
            $nexts.each($.proxy(function(i, widget) {
                this.move_widget_up(
                 $(widget), this.placeholder_grid_data.col - col + phgd.size_y);
            }, this));
        }

        var $widgets_under_ph = this.get_widgets_under_player(
            this.cells_occupied_by_placeholder);

        if ($widgets_under_ph.length) {
            $widgets_under_ph.each($.proxy(function(i, widget) {
                var $w = $(widget);
                this.move_widget_down(
                 $w, row + phgd.size_y - $w.data('coords').grid.row);
            }, this));
        }

    };


    /**
    * Determines whether the player can move to a position above.
    *
    * @method can_go_player_up
    * @param {Object} widget_grid_data The actual grid coords object of the
    *  player.
    * @return {Number|Boolean} If the player can be moved to an upper row
    *  returns the row number, else returns false.
    */
    fn.can_go_player_up = function(widget_grid_data) {
        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;
        var result = true;
        var upper_rows = [];
        var min_row = 10000;
        var $widgets_under_player = this.get_widgets_under_player();

        /* generate an array with columns as index and array with upper rows
         * empty as value */
        this.for_each_column_occupied(widget_grid_data, function(tcol) {
            var grid_col = this.gridmap[tcol];
            var r = p_bottom_row + 1;
            upper_rows[tcol] = [];

            while (--r > 0) {
                if (this.is_empty(tcol, r) || this.is_player(tcol, r) ||
                    this.is_widget(tcol, r) &&
                    grid_col[r].is($widgets_under_player)
                ) {
                    upper_rows[tcol].push(r);
                    min_row = r < min_row ? r : min_row;
                }else{
                    break;
                }
            }

            if (upper_rows[tcol].length === 0) {
                result = false;
                return true; //break
            }

            upper_rows[tcol].sort(function(a, b) {
                return a - b;
            });
        });

        if (!result) { return false; }

        return this.get_valid_rows(widget_grid_data, upper_rows, min_row);
    };


    /**
    * Determines whether a widget can move to a position above.
    *
    * @method can_go_widget_up
    * @param {Object} widget_grid_data The actual grid coords object of the
    *  widget we want to check.
    * @return {Number|Boolean} If the widget can be moved to an upper row
    *  returns the row number, else returns false.
    */
    fn.can_go_widget_up = function(widget_grid_data) {
        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;
        var result = true;
        var upper_rows = [];
        var min_row = 10000;

        /* generate an array with columns as index and array with topmost rows
         * empty as value */
        this.for_each_column_occupied(widget_grid_data, function(tcol) {
            var grid_col = this.gridmap[tcol];
            upper_rows[tcol] = [];

            var r = p_bottom_row + 1;
            // iterate over each row
            while (--r > 0) {
                if (this.is_widget(tcol, r) && !this.is_player_in(tcol, r)) {
                    if (!grid_col[r].is(widget_grid_data.el)) {
                        break;
                    }
                }

                if (!this.is_player(tcol, r) &&
                    !this.is_placeholder_in(tcol, r) &&
                    !this.is_player_in(tcol, r)) {
                    upper_rows[tcol].push(r);
                }

                if (r < min_row) {
                    min_row = r;
                }
            }

            if (upper_rows[tcol].length === 0) {
                result = false;
                return true; //break
            }

            upper_rows[tcol].sort(function(a, b) {
                return a - b;
            });
        });

        if (!result) { return false; }

        return this.get_valid_rows(widget_grid_data, upper_rows, min_row);
    };


    /**
    * Search a valid row for the widget represented by `widget_grid_data' in
    * the `upper_rows` array. Iteration starts from row specified in `min_row`.
    *
    * @method get_valid_rows
    * @param {Object} widget_grid_data The actual grid coords object of the
    *  player.
    * @param {Array} upper_rows An array with columns as index and arrays
    *  of valid rows as values.
    * @param {Number} min_row The upper row from which the iteration will start.
    * @return {Number|Boolean} Returns the upper row valid from the `upper_rows`
    *  for the widget in question.
    */
    fn.get_valid_rows = function(widget_grid_data, upper_rows, min_row) {
        var p_top_row = widget_grid_data.row;
        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;
        var size_y = widget_grid_data.size_y;
        var r = min_row - 1;
        var valid_rows = [];

        while (++r <= p_bottom_row ) {
            var common = true;
            $.each(upper_rows, function(col, rows) {
                if ($.isArray(rows) && $.inArray(r, rows) === -1) {
                    common = false;
                }
            });

            if (common === true) {
                valid_rows.push(r);
                if (valid_rows.length === size_y) {
                    break;
                }
            }
        }

        var new_row = false;
        if (size_y === 1) {
            if (valid_rows[0] !== p_top_row) {
                new_row = valid_rows[0] || false;
            }
        }else{
            if (valid_rows[0] !== p_top_row) {
                new_row = this.get_consecutive_numbers_index(
                    valid_rows, size_y);
            }
        }

        return new_row;
    };


    fn.get_consecutive_numbers_index = function(arr, size_y) {
        var max = arr.length;
        var result = [];
        var first = true;
        var prev = -1; // or null?

        for (var i=0; i < max; i++) {
            if (first || arr[i] === prev + 1) {
                result.push(i);
                if (result.length === size_y) {
                    break;
                }
                first = false;
            }else{
                result = [];
                first = true;
            }

            prev = arr[i];
        }

        return result.length >= size_y ? arr[result[0]] : false;
    };


    /**
    * Get widgets overlapping with the player.
    *
    * @method get_widgets_overlapped
    * @return {jQuery} Returns a jQuery collection of HTMLElements.
    */
    fn.get_widgets_overlapped = function() {
        var $w;
        var $widgets = $([]);
        var used = [];
        var rows_from_bottom = this.cells_occupied_by_player.rows.slice(0);
        rows_from_bottom.reverse();

        $.each(this.cells_occupied_by_player.cols, $.proxy(function(i, col) {
            $.each(rows_from_bottom, $.proxy(function(i, row) {
                // if there is a widget in the player position
                if (!this.gridmap[col]) { return true; } //next iteration
                var $w = this.gridmap[col][row];
                if (this.is_occupied(col, row) && !this.is_player($w) &&
                    $.inArray($w, used) === -1
                ) {
                    $widgets = $widgets.add($w);
                    used.push($w);
                }

            }, this));
        }, this));

        return $widgets;
    };


    /**
    * This callback is executed when the player begins to collide with a column.
    *
    * @method on_start_overlapping_column
    * @param {Number} col The collided column.
    * @return {jQuery} Returns a jQuery collection of HTMLElements.
    */
    fn.on_start_overlapping_column = function(col) {
        this.set_player(col, false);
    };


    /**
    * A callback executed when the player begins to collide with a row.
    *
    * @method on_start_overlapping_row
    * @param {Number} row The collided row.
    * @return {jQuery} Returns a jQuery collection of HTMLElements.
    */
    fn.on_start_overlapping_row = function(row) {
        this.set_player(false, row);
    };


    /**
    * A callback executed when the the player ends to collide with a column.
    *
    * @method on_stop_overlapping_column
    * @param {Number} col The collided row.
    * @return {jQuery} Returns a jQuery collection of HTMLElements.
    */
    fn.on_stop_overlapping_column = function(col) {
        this.set_player(col, false);

        var self = this;
        this.for_each_widget_below(col, this.cells_occupied_by_player.rows[0],
            function(tcol, trow) {
                self.move_widget_up(this, self.player_grid_data.size_y);
        });
    };


    /**
    * This callback is executed when the player ends to collide with a row.
    *
    * @method on_stop_overlapping_row
    * @param {Number} row The collided row.
    * @return {jQuery} Returns a jQuery collection of HTMLElements.
    */
    fn.on_stop_overlapping_row = function(row) {
        this.set_player(false, row);

        var self = this;
        var cols = this.cells_occupied_by_player.cols;
        for (var c = 0, cl = cols.length; c < cl; c++) {
            this.for_each_widget_below(cols[c], row, function(tcol, trow) {
                self.move_widget_up(this, self.player_grid_data.size_y);
            });
        }
    };


    /**
    * Move a widget to a specific row. The cell or cells must be empty.
    * If the widget has widgets below, all of these widgets will be moved also
    * if they can.
    *
    * @method move_widget_to
    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement of the
    * widget is going to be moved.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.move_widget_to = function($widget, row) {
        var self = this;
        var widget_grid_data = $widget.coords().grid;
        var diff = row - widget_grid_data.row;
        var $next_widgets = this.widgets_below($widget);

        var can_move_to_new_cell = this.can_move_to(
            widget_grid_data, widget_grid_data.col, row, $widget);

        if (can_move_to_new_cell === false) {
            return false;
        }

        this.remove_from_gridmap(widget_grid_data);
        widget_grid_data.row = row;
        this.add_to_gridmap(widget_grid_data);
        $widget.attr('data-row', row);
        this.$changed = this.$changed.add($widget);


        $next_widgets.each(function(i, widget) {
            var $w = $(widget);
            var wgd = $w.coords().grid;
            var can_go_up = self.can_go_widget_up(wgd);
            if (can_go_up && can_go_up !== wgd.row) {
                self.move_widget_to($w, can_go_up);
            }
        });

        return this;
    };


    /**
    * Move up the specified widget and all below it.
    *
    * @method move_widget_up
    * @param {HTMLElement} $widget The widget you want to move.
    * @param {Number} [y_units] The number of cells that the widget has to move.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.move_widget_up = function($widget, y_units) {
        var el_grid_data = $widget.coords().grid;
        var actual_row = el_grid_data.row;
        var moved = [];
        var can_go_up = true;
        y_units || (y_units = 1);

        if (!this.can_go_up($widget)) { return false; } //break;

        this.for_each_column_occupied(el_grid_data, function(col) {
            // can_go_up
            if ($.inArray($widget, moved) === -1) {
                var widget_grid_data = $widget.coords().grid;
                var next_row = actual_row - y_units;
                next_row = this.can_go_up_to_row(
                    widget_grid_data, col, next_row);

                if (!next_row) {
                    return true;
                }

                var $next_widgets = this.widgets_below($widget);

                this.remove_from_gridmap(widget_grid_data);
                widget_grid_data.row = next_row;
                this.add_to_gridmap(widget_grid_data);
                $widget.attr('data-row', widget_grid_data.row);
                this.$changed = this.$changed.add($widget);

                moved.push($widget);

                $next_widgets.each($.proxy(function(i, widget) {
                    this.move_widget_up($(widget), y_units);
                }, this));
            }
        });

    };


    /**
    * Move down the specified widget and all below it.
    *
    * @method move_widget_down
    * @param {jQuery} $widget The jQuery object representing the widget
    *  you want to move.
    * @param {Number} y_units The number of cells that the widget has to move.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.move_widget_down = function($widget, y_units) {
        var el_grid_data, actual_row, moved, y_diff;

        if (y_units <= 0) { return false; }

        el_grid_data = $widget.coords().grid;
        actual_row = el_grid_data.row;
        moved = [];
        y_diff = y_units;

        if (!$widget) { return false; }

        if ($.inArray($widget, moved) === -1) {

            var widget_grid_data = $widget.coords().grid;
            var next_row = actual_row + y_units;
            var $next_widgets = this.widgets_below($widget);

            this.remove_from_gridmap(widget_grid_data);

            $next_widgets.each($.proxy(function(i, widget) {
                var $w = $(widget);
                var wd = $w.coords().grid;
                var tmp_y = this.displacement_diff(
                             wd, widget_grid_data, y_diff);

                if (tmp_y > 0) {
                    this.move_widget_down($w, tmp_y);
                }
            }, this));

            widget_grid_data.row = next_row;
            this.update_widget_position(widget_grid_data, $widget);
            $widget.attr('data-row', widget_grid_data.row);
            this.$changed = this.$changed.add($widget);

            moved.push($widget);
        }
    };


    /**
    * Check if the widget can move to the specified row, else returns the
    * upper row possible.
    *
    * @method can_go_up_to_row
    * @param {Number} widget_grid_data The current grid coords object of the
    *  widget.
    * @param {Number} col The target column.
    * @param {Number} row The target row.
    * @return {Boolean|Number} Returns the row number if the widget can move
    *  to the target position, else returns false.
    */
    fn.can_go_up_to_row = function(widget_grid_data, col, row) {
        var ga = this.gridmap;
        var result = true;
        var urc = []; // upper_rows_in_columns
        var actual_row = widget_grid_data.row;
        var r;

        /* generate an array with columns as index and array with
         * upper rows empty in the column */
        this.for_each_column_occupied(widget_grid_data, function(tcol) {
            var grid_col = ga[tcol];
            urc[tcol] = [];

            r = actual_row;
            while (r--) {
                if (this.is_empty(tcol, r) &&
                    !this.is_placeholder_in(tcol, r)
                ) {
                    urc[tcol].push(r);
                }else{
                    break;
                }
            }

            if (!urc[tcol].length) {
                result = false;
                return true;
            }

        });

        if (!result) { return false; }

        /* get common rows starting from upper position in all the columns
         * that widget occupies */
        r = row;
        for (r = 1; r < actual_row; r++) {
            var common = true;

            for (var uc = 0, ucl = urc.length; uc < ucl; uc++) {
                if (urc[uc] && $.inArray(r, urc[uc]) === -1) {
                    common = false;
                }
            }

            if (common === true) {
                result = r;
                break;
            }
        }

        return result;
    };


    fn.displacement_diff = function(widget_grid_data, parent_bgd, y_units) {
        var actual_row = widget_grid_data.row;
        var diffs = [];
        var parent_max_y = parent_bgd.row + parent_bgd.size_y;

        this.for_each_column_occupied(widget_grid_data, function(col) {
            var temp_y_units = 0;

            for (var r = parent_max_y; r < actual_row; r++) {
                if (this.is_empty(col, r)) {
                    temp_y_units = temp_y_units + 1;
                }
            }

            diffs.push(temp_y_units);
        });

        var max_diff = Math.max.apply(Math, diffs);
        y_units = (y_units - max_diff);

        return y_units > 0 ? y_units : 0;
    };


    /**
    * Get widgets below a widget.
    *
    * @method widgets_below
    * @param {HTMLElement} $el The jQuery wrapped HTMLElement.
    * @return {jQuery} A jQuery collection of HTMLElements.
    */
    fn.widgets_below = function($el) {
        var el_grid_data = $.isPlainObject($el) ? $el : $el.coords().grid;
        var self = this;
        var ga = this.gridmap;
        var next_row = el_grid_data.row + el_grid_data.size_y - 1;
        var $nexts = $([]);

        this.for_each_column_occupied(el_grid_data, function(col) {
            self.for_each_widget_below(col, next_row, function(tcol, trow) {
                if (!self.is_player(this) && $.inArray(this, $nexts) === -1) {
                    $nexts = $nexts.add(this);
                    return true; // break
                }
            });
        });

        return this.sort_by_row_asc($nexts);
    };


    /**
    * Update the array of mapped positions with the new player position.
    *
    * @method set_cells_player_occupies
    * @param {Number} col The new player col.
    * @param {Number} col The new player row.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.set_cells_player_occupies = function(col, row) {
        this.remove_from_gridmap(this.placeholder_grid_data);
        this.placeholder_grid_data.col = col;
        this.placeholder_grid_data.row = row;
        this.add_to_gridmap(this.placeholder_grid_data, this.$player);
        return this;
    };


    /**
    * Remove from the array of mapped positions the reference to the player.
    *
    * @method empty_cells_player_occupies
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.empty_cells_player_occupies = function() {
        this.remove_from_gridmap(this.placeholder_grid_data);
        return this;
    };


    fn.can_go_up = function($el) {
        var el_grid_data = $el.coords().grid;
        var initial_row = el_grid_data.row;
        var prev_row = initial_row - 1;
        var ga = this.gridmap;
        var upper_rows_by_column = [];

        var result = true;
        if (initial_row === 1) { return false; }

        this.for_each_column_occupied(el_grid_data, function(col) {
            var $w = this.is_widget(col, prev_row);

            if (this.is_occupied(col, prev_row) ||
                this.is_player(col, prev_row) ||
                this.is_placeholder_in(col, prev_row) ||
                this.is_player_in(col, prev_row)
            ) {
                result = false;
                return true; //break
            }
        });

        return result;
    };



    /**
    * Check if it's possible to move a widget to a specific col/row. It takes
    * into account the dimensions (`size_y` and `size_x` attrs. of the grid
    *  coords object) the widget occupies.
    *
    * @method can_move_to
    * @param {Object} widget_grid_data The grid coords object that represents
    *  the widget.
    * @param {Object} col The col to check.
    * @param {Object} row The row to check.
    * @param {Number} [max_row] The max row allowed.
    * @return {Boolean} Returns true if all cells are empty, else return false.
    */
    fn.can_move_to = function(widget_grid_data, col, row, max_row) {
        var ga = this.gridmap;
        var $w = widget_grid_data.el;
        var future_wd = {
            size_y: widget_grid_data.size_y,
            size_x: widget_grid_data.size_x,
            col: col,
            row: row
        };
        var result = true;

        //Prevents widgets go out of the grid
        var right_col = col + widget_grid_data.size_x - 1;
        if (right_col > this.cols) {
            return false;
        }

        if (max_row && max_row < row + widget_grid_data.size_y - 1) {
            return false;
        }

        this.for_each_cell_occupied(future_wd, function(tcol, trow) {
            var $tw = this.is_widget(tcol, trow);
            if ($tw && (!widget_grid_data.el || $tw.is($w))) {
                result = false;
            }
        });

        return result;
    };


    /**
    * Given the leftmost column returns all columns that are overlapping
    *  with the player.
    *
    * @method get_targeted_columns
    * @param {Number} [from_col] The leftmost column.
    * @return {Array} Returns an array with column numbers.
    */
    fn.get_targeted_columns = function(from_col) {
        var max = (from_col || this.player_grid_data.col) +
            (this.player_grid_data.size_x - 1);
        var cols = [];
        for (var col = from_col; col <= max; col++) {
            cols.push(col);
        }
        return cols;
    };


    /**
    * Given the upper row returns all rows that are overlapping with the player.
    *
    * @method get_targeted_rows
    * @param {Number} [from_row] The upper row.
    * @return {Array} Returns an array with row numbers.
    */
    fn.get_targeted_rows = function(from_row) {
        var max = (from_row || this.player_grid_data.row) +
            (this.player_grid_data.size_y - 1);
        var rows = [];
        for (var row = from_row; row <= max; row++) {
            rows.push(row);
        }
        return rows;
    };

    /**
    * Get all columns and rows that a widget occupies.
    *
    * @method get_cells_occupied
    * @param {Object} el_grid_data The grid coords object of the widget.
    * @return {Object} Returns an object like `{ cols: [], rows: []}`.
    */
    fn.get_cells_occupied = function(el_grid_data) {
        var cells = { cols: [], rows: []};
        var i;
        if (arguments[1] instanceof jQuery) {
            el_grid_data = arguments[1].coords().grid;
        }

        for (i = 0; i < el_grid_data.size_x; i++) {
            var col = el_grid_data.col + i;
            cells.cols.push(col);
        }

        for (i = 0; i < el_grid_data.size_y; i++) {
            var row = el_grid_data.row + i;
            cells.rows.push(row);
        }

        return cells;
    };


    /**
    * Iterate over the cells occupied by a widget executing a function for
    * each one.
    *
    * @method for_each_cell_occupied
    * @param {Object} el_grid_data The grid coords object that represents the
    *  widget.
    * @param {Function} callback The function to execute on each column
    *  iteration. Column and row are passed as arguments.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_cell_occupied = function(grid_data, callback) {
        this.for_each_column_occupied(grid_data, function(col) {
            this.for_each_row_occupied(grid_data, function(row) {
                callback.call(this, col, row);
            });
        });
        return this;
    };


    /**
    * Iterate over the columns occupied by a widget executing a function for
    * each one.
    *
    * @method for_each_column_occupied
    * @param {Object} el_grid_data The grid coords object that represents
    *  the widget.
    * @param {Function} callback The function to execute on each column
    *  iteration. The column number is passed as first argument.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_column_occupied = function(el_grid_data, callback) {
        for (var i = 0; i < el_grid_data.size_x; i++) {
            var col = el_grid_data.col + i;
            callback.call(this, col, el_grid_data);
        }
    };


    /**
    * Iterate over the rows occupied by a widget executing a function for
    * each one.
    *
    * @method for_each_row_occupied
    * @param {Object} el_grid_data The grid coords object that represents
    *  the widget.
    * @param {Function} callback The function to execute on each column
    *  iteration. The row number is passed as first argument.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_row_occupied = function(el_grid_data, callback) {
        for (var i = 0; i < el_grid_data.size_y; i++) {
            var row = el_grid_data.row + i;
            callback.call(this, row, el_grid_data);
        }
    };



    fn._traversing_widgets = function(type, direction, col, row, callback) {
        var ga = this.gridmap;
        if (!ga[col]) { return; }

        var cr, max;
        var action = type + '/' + direction;
        if (arguments[2] instanceof jQuery) {
            var el_grid_data = arguments[2].coords().grid;
            col = el_grid_data.col;
            row = el_grid_data.row;
            callback = arguments[3];
        }
        var matched = [];
        var trow = row;


        var methods = {
            'for_each/above': function() {
                while (trow--) {
                    if (trow > 0 && this.is_widget(col, trow) &&
                        $.inArray(ga[col][trow], matched) === -1
                    ) {
                        cr = callback.call(ga[col][trow], col, trow);
                        matched.push(ga[col][trow]);
                        if (cr) { break; }
                    }
                }
            },
            'for_each/below': function() {
                for (trow = row + 1, max = ga[col].length; trow < max; trow++) {
                    if (this.is_widget(col, trow) &&
                        $.inArray(ga[col][trow], matched) === -1
                    ) {
                        cr = callback.call(ga[col][trow], col, trow);
                        matched.push(ga[col][trow]);
                        if (cr) { break; }
                    }
                }
            }
        };

        if (methods[action]) {
            methods[action].call(this);
        }
    };


    /**
    * Iterate over each widget above the column and row specified.
    *
    * @method for_each_widget_above
    * @param {Number} col The column to start iterating.
    * @param {Number} row The row to start iterating.
    * @param {Function} callback The function to execute on each widget
    *  iteration. The value of `this` inside the function is the jQuery
    *  wrapped HTMLElement.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_widget_above = function(col, row, callback) {
        this._traversing_widgets('for_each', 'above', col, row, callback);
        return this;
    };


    /**
    * Iterate over each widget below the column and row specified.
    *
    * @method for_each_widget_below
    * @param {Number} col The column to start iterating.
    * @param {Number} row The row to start iterating.
    * @param {Function} callback The function to execute on each widget
    *  iteration. The value of `this` inside the function is the jQuery wrapped
    *  HTMLElement.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_widget_below = function(col, row, callback) {
        this._traversing_widgets('for_each', 'below', col, row, callback);
        return this;
    };


    /**
    * Returns the highest occupied cell in the grid.
    *
    * @method get_highest_occupied_cell
    * @return {Object} Returns an object with `col` and `row` numbers.
    */
    fn.get_highest_occupied_cell = function() {
        var r;
        var gm = this.gridmap;
        var rows = [];
        var row_in_col = [];
        for (var c = gm.length - 1; c >= 1; c--) {
            for (r = gm[c].length - 1; r >= 1; r--) {
                if (this.is_widget(c, r)) {
                    rows.push(r);
                    row_in_col[r] = c;
                    break;
                }
            }
        }

        var highest_row = Math.max.apply(Math, rows);

        this.highest_occupied_cell = {
            col: row_in_col[highest_row],
            row: highest_row
        };

        return this.highest_occupied_cell;
    };


    fn.get_widgets_from = function(col, row) {
        var ga = this.gridmap;
        var $widgets = $();

        if (col) {
            $widgets = $widgets.add(
                this.$widgets.filter(function() {
                    var tcol = $(this).attr('data-col');
                    return (tcol === col || tcol > col);
                })
            );
        }

        if (row) {
            $widgets = $widgets.add(
                this.$widgets.filter(function() {
                    var trow = $(this).attr('data-row');
                    return (trow === row || trow > row);
                })
            );
        }

        return $widgets;
    };


    /**
    * Set the current height of the parent grid.
    *
    * @method set_dom_grid_height
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.set_dom_grid_height = function() {
        var r = this.get_highest_occupied_cell().row;
        this.$el.css('height', r * this.min_widget_height);
        return this;
    };


    /**
    * It generates the neccessary styles to position the widgets.
    *
    * @method generate_stylesheet
    * @param {Number} rows Number of columns.
    * @param {Number} cols Number of rows.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.generate_stylesheet = function(opts) {
        var styles = '';
        var max_size_x = this.options.max_size_x || this.cols;
        var max_rows = 0;
        var max_cols = 0;
        var i;
        var rules;

        opts || (opts = {});
        opts.cols || (opts.cols = this.cols);
        opts.rows || (opts.rows = this.rows);
        opts.namespace || (opts.namespace = this.options.namespace);
        opts.widget_base_dimensions ||
            (opts.widget_base_dimensions = this.options.widget_base_dimensions);
        opts.widget_margins ||
            (opts.widget_margins = this.options.widget_margins);
        opts.min_widget_width = (opts.widget_margins[0] * 2) +
            opts.widget_base_dimensions[0];
        opts.min_widget_height = (opts.widget_margins[1] * 2) +
            opts.widget_base_dimensions[1];

        // don't duplicate stylesheets for the same configuration
        var serialized_opts = $.param(opts);
        if ($.inArray(serialized_opts, Gridster.generated_stylesheets) >= 0) {
            return false;
        }

        Gridster.generated_stylesheets.push(serialized_opts);

        /* generate CSS styles for cols */
        for (i = opts.cols; i >= 0; i--) {
            styles += (opts.namespace + ' [data-col="'+ (i + 1) + '"] { left:' +
                ((i * opts.widget_base_dimensions[0]) +
                (i * opts.widget_margins[0]) +
                ((i + 1) * opts.widget_margins[0])) + 'px; }\n');
        }

        /* generate CSS styles for rows */
        for (i = opts.rows; i >= 0; i--) {
            styles += (opts.namespace + ' [data-row="' + (i + 1) + '"] { top:' +
                ((i * opts.widget_base_dimensions[1]) +
                (i * opts.widget_margins[1]) +
                ((i + 1) * opts.widget_margins[1]) ) + 'px; }\n');
        }

        for (var y = 1; y <= opts.rows; y++) {
            styles += (opts.namespace + ' [data-sizey="' + y + '"] { height:' +
                (y * opts.widget_base_dimensions[1] +
                (y - 1) * (opts.widget_margins[1] * 2)) + 'px; }\n');
        }

        for (var x = 1; x <= max_size_x; x++) {
            styles += (opts.namespace + ' [data-sizex="' + x + '"] { width:' +
                (x * opts.widget_base_dimensions[0] +
                (x - 1) * (opts.widget_margins[0] * 2)) + 'px; }\n');
        }

        return this.add_style_tag(styles);
    };


    /**
    * Injects the given CSS as string to the head of the document.
    *
    * @method add_style_tag
    * @param {String} css The styles to apply.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.add_style_tag = function(css) {
      var d = document;
      var tag = d.createElement('style');

      d.getElementsByTagName('head')[0].appendChild(tag);
      tag.setAttribute('type', 'text/css');

      if (tag.styleSheet) {
        tag.styleSheet.cssText = css;
      }else{
        tag.appendChild(document.createTextNode(css));
      }

      this.$style_tags = this.$style_tags.add(tag);

      return this;
    };


    /**
    * Remove the style tag with the associated id from the head of the document
    *
    * @method  remove_style_tag
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.remove_style_tags = function() {
        this.$style_tags.remove();
    };


    /**
    * Generates a faux grid to collide with it when a widget is dragged and
    * detect row or column that we want to go.
    *
    * @method generate_faux_grid
    * @param {Number} rows Number of columns.
    * @param {Number} cols Number of rows.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.generate_faux_grid = function(rows, cols) {
        this.faux_grid = [];
        this.gridmap = [];
        var col;
        var row;
        for (col = cols; col > 0; col--) {
            this.gridmap[col] = [];
            for (row = rows; row > 0; row--) {
                this.add_faux_cell(row, col);
            }
        }
        return this;
    };


    /**
    * Add cell to the faux grid.
    *
    * @method add_faux_cell
    * @param {Number} row The row for the new faux cell.
    * @param {Number} col The col for the new faux cell.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.add_faux_cell = function(row, col) {
        var coords = $({
                        left: this.baseX + ((col - 1) * this.min_widget_width),
                        top: this.baseY + (row -1) * this.min_widget_height,
                        width: this.min_widget_width,
                        height: this.min_widget_height,
                        col: col,
                        row: row,
                        original_col: col,
                        original_row: row
                    }).coords();

        if (!$.isArray(this.gridmap[col])) {
            this.gridmap[col] = [];
        }

        this.gridmap[col][row] = false;
        this.faux_grid.push(coords);

        return this;
    };


    /**
    * Add rows to the faux grid.
    *
    * @method add_faux_rows
    * @param {Number} rows The number of rows you want to add to the faux grid.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.add_faux_rows = function(rows) {
        var actual_rows = this.rows;
        var max_rows = actual_rows + (rows || 1);

        for (var r = max_rows; r > actual_rows; r--) {
            for (var c = this.cols; c >= 1; c--) {
                this.add_faux_cell(r, c);
            }
        }

        this.rows = max_rows;

        if (this.options.autogenerate_stylesheet) {
            this.generate_stylesheet();
        }

        return this;
    };

     /**
    * Add cols to the faux grid.
    *
    * @method add_faux_cols
    * @param {Number} cols The number of cols you want to add to the faux grid.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.add_faux_cols = function(cols) {
        var actual_cols = this.cols;
        var max_cols = actual_cols + (cols || 1);

        for (var c = actual_cols; c < max_cols; c++) {
            for (var r = this.rows; r >= 1; r--) {
                this.add_faux_cell(r, c);
            }
        }

        this.cols = max_cols;

        if (this.options.autogenerate_stylesheet) {
            this.generate_stylesheet();
        }

        return this;
    };


    /**
    * Recalculates the offsets for the faux grid. You need to use it when
    * the browser is resized.
    *
    * @method recalculate_faux_grid
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.recalculate_faux_grid = function() {
        var aw = this.$wrapper.width();
        this.baseX = ($(window).width() - aw) / 2;
        this.baseY = this.$wrapper.offset().top;

        $.each(this.faux_grid, $.proxy(function(i, coords) {
            this.faux_grid[i] = coords.update({
                left: this.baseX + (coords.data.col -1) * this.min_widget_width,
                top: this.baseY + (coords.data.row -1) * this.min_widget_height
            });

        }, this));

        return this;
    };


    /**
    * Get all widgets in the DOM and register them.
    *
    * @method get_widgets_from_DOM
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.get_widgets_from_DOM = function() {
        this.$widgets.each($.proxy(function(i, widget) {
            this.register_widget($(widget));
        }, this));
        return this;
    };


    /**
    * Calculate columns and rows to be set based on the configuration
    *  parameters, grid dimensions, etc ...
    *
    * @method generate_grid_and_stylesheet
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.generate_grid_and_stylesheet = function() {
        var aw = this.$wrapper.width();
        var ah = this.$wrapper.height();
        var max_cols = this.options.max_cols;

        var cols = Math.floor(aw / this.min_widget_width) +
                   this.options.extra_cols;

        var actual_cols = this.$widgets.map(function() {
            return $(this).attr('data-col');
        }).get();

        //needed to pass tests with phantomjs
        actual_cols.length || (actual_cols = [0]);

        var min_cols = Math.max.apply(Math, actual_cols);

        // get all rows that could be occupied by the current widgets
        var max_rows = this.options.extra_rows;
        this.$widgets.each(function(i, w) {
            max_rows += (+$(w).attr('data-sizey'));
        });

        this.cols = Math.max(min_cols, cols, this.options.min_cols);

        if (max_cols && max_cols >= min_cols && max_cols < this.cols) {
            this.cols = max_cols;
        }

        this.rows = Math.max(max_rows, this.options.min_rows);

        this.baseX = ($(window).width() - aw) / 2;
        this.baseY = this.$wrapper.offset().top;

        // left and right gutters not included
        this.container_width = (this.cols *
            this.options.widget_base_dimensions[0]) + ((this.cols - 1) * 2 *
            this.options.widget_margins[0]);

        if (this.options.autogenerate_stylesheet) {
            this.generate_stylesheet();
        }

        return this.generate_faux_grid(this.rows, this.cols);
    };

    /**
     * Destroy this gridster by removing any sign of its presence, making it easy to avoid memory leaks
     *
     * @method destroy
     * @return {undefined}
     */
    fn.destroy = function(){
        // remove bound callback on window resize
        $(window).unbind('.gridster');

        if (this.drag_api) {
            this.drag_api.destroy();
        }

        this.remove_style_tags();

        // lastly, remove gridster element
        // this will additionally cause any data associated to this element to be removed, including this
        // very gridster instance
        this.$el.remove();

        return this;
    };


    //jQuery adapter
    $.fn.gridster = function(options) {
     return this.each(function() {
       if (!$(this).data('gridster')) {
         $(this).data('gridster', new Gridster( this, options ));
       }
     });
    };

    $.Gridster = fn;

}(jQuery, window, document));

/**
 * Based on the plunk from Ryan Randall
 * @link http://plnkr.co/edit/6Kqg1u?p=info
 */
angular.module('angular-gridster', [])
    .directive('gridster', ['$timeout', function ($timeout) {
        return {
            restrict: 'AE',
            scope: { model: '=model' },
            template: '<ul><div widget ng-repeat="item in model" widget-model="item"></div></ul>',
            link: function ($scope, $element, $attributes, $controller) {
                var gridster;
                var ul = $element.find('ul');
                var defaultOptions = {
                    widget_margins: [5, 5],
                    widget_base_dimensions: [70, 70]
                };
                var options = angular.extend(defaultOptions, $scope.$eval($attributes.options));

                $timeout(function () {
                    gridster = ul.gridster(options).data('gridster');

                    gridster.options.draggable.stop = function (event, ui) {
                        //update model
                        angular.forEach(ul.find('li'), function (item, index) {
                            var li = angular.element(item);
                            if (li.attr('class') === 'preview-holder') return;
                            var widget = $scope.model[index];
                            widget.row = li.attr('data-row');
                            widget.col = li.attr('data-col');
                        });
                        $scope.$apply();
                    };
                });

                var attachElementToGridster = function (li) {
                    //attaches a new element to gridster
                    var $w = li.addClass('gs_w').appendTo(gridster.$el).hide();
                    gridster.$widgets = gridster.$widgets.add($w);
                    gridster.register_widget($w).add_faux_rows(1).set_dom_grid_height();
                    $w.fadeIn();
                };
                $scope.$watch('model.length', function (newValue, oldValue) {
                    if (newValue != oldValue + 1) return; //not an add
                    var li = ul.find('li').eq(newValue - 1); //latest li element
                    $timeout(function () {
                        attachElementToGridster(li);
                    }); //attach to gridster
                });
            }
        };
    }])
    .directive('widget', [function () {
        return {
            restrict: 'AE',
            scope: { widgetModel: '=' },
            replace: true,
            template: '<li data-col="{{widgetModel.col}}" data-row="{{widgetModel.row}}" data-sizex="{{widgetModel.sizex}}" data-sizey="{{widgetModel.sizey}}">' +
                '{{widgetModel.html}}' +
                '</li>',
            link: function ($scope, $element, $attributes, $controller) {
            }
        };
    }]);